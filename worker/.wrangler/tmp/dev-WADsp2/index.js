var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value6) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value6 }) : obj[key] = value6;
var __name = (target2, value6) => __defProp(target2, "name", { value: value6, configurable: true });
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all12) => {
  for (var name in all12)
    __defProp(target2, name, { get: all12[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __publicField = (obj, key, value6) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value6);
  return value6;
};

// .wrangler/tmp/bundle-gWfDcw/strip-cf-connecting-ip-header.js
function stripCfConnectingIPHeader(input, init) {
  const request2 = new Request(input, init);
  request2.headers.delete("CF-Connecting-IP");
  return request2;
}
var init_strip_cf_connecting_ip_header = __esm({
  ".wrangler/tmp/bundle-gWfDcw/strip-cf-connecting-ip-header.js"() {
    __name(stripCfConnectingIPHeader, "stripCfConnectingIPHeader");
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target2, thisArg, argArray) {
        return Reflect.apply(target2, thisArg, [
          stripCfConnectingIPHeader.apply(null, argArray)
        ]);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
  }
});

// node_modules/.pnpm/wrangler@3.114.15_@cloudflare+workers-types@4.20251004.0/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/.pnpm/wrangler@3.114.15_@cloudflare+workers-types@4.20251004.0/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/index.js
var require_browser = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/index.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_globalThis(), exports);
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/version.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.9.0";
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCompatible = exports._makeCompatibilityCheck = void 0;
    var version_1 = require_version();
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      const rejectedVersions = /* @__PURE__ */ new Set();
      const myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return () => false;
      }
      const ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        const globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        const globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    exports._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = void 0;
    var platform_1 = require_browser();
    var version_1 = require_version();
    var semver_1 = require_semver();
    var major = version_1.VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
    var _global = platform_1._globalThis;
    function registerGlobal(type3, instance, diag, allowOverride = false) {
      var _a;
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type3]) {
        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type3}`);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== version_1.VERSION) {
        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type3} does not match previously registered API v${version_1.VERSION}`);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type3] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type3} v${version_1.VERSION}.`);
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    exports.registerGlobal = registerGlobal;
    function getGlobal(type3) {
      var _a, _b;
      const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type3];
    }
    __name(getGlobal, "getGlobal");
    exports.getGlobal = getGlobal;
    function unregisterGlobal(type3, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type3} v${version_1.VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type3];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    exports.unregisterGlobal = unregisterGlobal;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils();
    var DiagComponentLogger = class {
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args2) {
        return logProxy("debug", this._namespace, args2);
      }
      error(...args2) {
        return logProxy("error", this._namespace, args2);
      }
      info(...args2) {
        return logProxy("info", this._namespace, args2);
      }
      warn(...args2) {
        return logProxy("warn", this._namespace, args2);
      }
      verbose(...args2) {
        return logProxy("verbose", this._namespace, args2);
      }
    };
    __name(DiagComponentLogger, "DiagComponentLogger");
    exports.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args2) {
      const logger3 = (0, global_utils_1.getGlobal)("diag");
      if (!logger3) {
        return;
      }
      args2.unshift(namespace);
      return logger3[funcName](...args2);
    }
    __name(logProxy, "logProxy");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/types.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagLogLevel = void 0;
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogLevelDiagLogger = void 0;
    var types_1 = require_types();
    function createLogLevelDiagLogger(maxLevel, logger3) {
      if (maxLevel < types_1.DiagLogLevel.NONE) {
        maxLevel = types_1.DiagLogLevel.NONE;
      } else if (maxLevel > types_1.DiagLogLevel.ALL) {
        maxLevel = types_1.DiagLogLevel.ALL;
      }
      logger3 = logger3 || {};
      function _filterFunc(funcName, theLevel) {
        const theFunc = logger3[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger3);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/diag.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger();
    var logLevelLogger_1 = require_logLevelLogger();
    var types_1 = require_types();
    var global_utils_1 = require_global_utils();
    var API_NAME = "diag";
    var DiagAPI = class {
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args2) {
            const logger3 = (0, global_utils_1.getGlobal)("diag");
            if (!logger3)
              return;
            return logger3[funcName](...args2);
          };
        }
        __name(_logProxy, "_logProxy");
        const self2 = this;
        const setLogger = /* @__PURE__ */ __name((logger3, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
          var _a, _b, _c;
          if (logger3 === self2) {
            const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          const oldLogger = (0, global_utils_1.getGlobal)("diag");
          const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger3);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`);
            newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
        }, "setLogger");
        self2.setLogger = setLogger;
        self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        };
        self2.createComponentLogger = (options4) => {
          return new ComponentLogger_1.DiagComponentLogger(options4);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        if (!this._instance) {
          this._instance = new DiagAPI();
        }
        return this._instance;
      }
    };
    __name(DiagAPI, "DiagAPI");
    exports.DiagAPI = DiagAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaggageImpl = void 0;
    var BaggageImpl = class {
      constructor(entries3) {
        this._entries = entries3 ? new Map(entries3) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        const entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
        const newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      }
      removeEntry(key) {
        const newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      }
      removeEntries(...keys6) {
        const newBaggage = new BaggageImpl(this._entries);
        for (const key of keys6) {
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      }
      clear() {
        return new BaggageImpl();
      }
    };
    __name(BaggageImpl, "BaggageImpl");
    exports.BaggageImpl = BaggageImpl;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataSymbol = void 0;
    exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
    var diag_1 = require_diag();
    var baggage_impl_1 = require_baggage_impl();
    var symbol_1 = require_symbol();
    var diag = diag_1.DiagAPI.instance();
    function createBaggage(entries3 = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries3)));
    }
    __name(createBaggage, "createBaggage");
    exports.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
        str = "";
      }
      return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/context.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ROOT_CONTEXT = exports.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    exports.createContextKey = createContextKey;
    var BaseContext = class {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        const self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = (key) => self2._currentContext.get(key);
        self2.setValue = (key, value6) => {
          const context11 = new BaseContext(self2._currentContext);
          context11._currentContext.set(key, value6);
          return context11;
        };
        self2.deleteValue = (key) => {
          const context11 = new BaseContext(self2._currentContext);
          context11._currentContext.delete(key);
          return context11;
        };
      }
    };
    __name(BaseContext, "BaseContext");
    exports.ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagConsoleLogger = void 0;
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = class {
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args2) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args2);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (let i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
    };
    __name(DiagConsoleLogger, "DiagConsoleLogger");
    exports.DiagConsoleLogger = DiagConsoleLogger;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
    var NoopMeter = class {
      constructor() {
      }
      /**
       * @see {@link Meter.createGauge}
       */
      createGauge(_name, _options) {
        return exports.NOOP_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    __name(NoopMeter, "NoopMeter");
    exports.NoopMeter = NoopMeter;
    var NoopMetric = class {
    };
    __name(NoopMetric, "NoopMetric");
    exports.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    __name(NoopCounterMetric, "NoopCounterMetric");
    exports.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    __name(NoopUpDownCounterMetric, "NoopUpDownCounterMetric");
    exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopGaugeMetric = class extends NoopMetric {
      record(_value, _attributes) {
      }
    };
    __name(NoopGaugeMetric, "NoopGaugeMetric");
    exports.NoopGaugeMetric = NoopGaugeMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      record(_value, _attributes) {
      }
    };
    __name(NoopHistogramMetric, "NoopHistogramMetric");
    exports.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    __name(NoopObservableMetric, "NoopObservableMetric");
    exports.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
    };
    __name(NoopObservableCounterMetric, "NoopObservableCounterMetric");
    exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
    };
    __name(NoopObservableGaugeMetric, "NoopObservableGaugeMetric");
    exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
    };
    __name(NoopObservableUpDownCounterMetric, "NoopObservableUpDownCounterMetric");
    exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports.NOOP_METER = new NoopMeter();
    exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports.NOOP_METER;
    }
    __name(createNoopMeter, "createNoopMeter");
    exports.createNoopMeter = createNoopMeter;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueType = void 0;
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType = exports.ValueType || (exports.ValueType = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
    exports.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    exports.defaultTextMapSetter = {
      set(carrier, key, value6) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value6;
      }
    };
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopContextManager = void 0;
    var context_1 = require_context();
    var NoopContextManager = class {
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn2, thisArg, ...args2) {
        return fn2.call(thisArg, ...args2);
      }
      bind(_context, target2) {
        return target2;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    __name(NoopContextManager, "NoopContextManager");
    exports.NoopContextManager = NoopContextManager;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/context.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
    var ContextAPI = class {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new ContextAPI();
        }
        return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context11, fn2, thisArg, ...args2) {
        return this._getContextManager().with(context11, fn2, thisArg, ...args2);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context11, target2) {
        return this._getContextManager().bind(context11, target2);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable();
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    __name(ContextAPI, "ContextAPI");
    exports.ContextAPI = ContextAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceFlags = void 0;
    var TraceFlags2;
    (function(TraceFlags3) {
      TraceFlags3[TraceFlags3["NONE"] = 0] = "NONE";
      TraceFlags3[TraceFlags3["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags2 = exports.TraceFlags || (exports.TraceFlags = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports.INVALID_SPANID = "0000000000000000";
    exports.INVALID_TRACEID = "00000000000000000000000000000000";
    exports.INVALID_SPAN_CONTEXT = {
      traceId: exports.INVALID_TRACEID,
      spanId: exports.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan = class {
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      addLink(_link) {
        return this;
      }
      addLinks(_links) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    __name(NonRecordingSpan, "NonRecordingSpan");
    exports.NonRecordingSpan = NonRecordingSpan;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = void 0;
    var context_1 = require_context();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var context_2 = require_context2();
    var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context11) {
      return context11.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    exports.getSpan = getSpan;
    function getActiveSpan() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    __name(getActiveSpan, "getActiveSpan");
    exports.getActiveSpan = getActiveSpan;
    function setSpan(context11, span4) {
      return context11.setValue(SPAN_KEY, span4);
    }
    __name(setSpan, "setSpan");
    exports.setSpan = setSpan;
    function deleteSpan(context11) {
      return context11.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    exports.deleteSpan = deleteSpan;
    function setSpanContext(context11, spanContext) {
      return setSpan(context11, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    exports.setSpanContext = setSpanContext;
    function getSpanContext(context11) {
      var _a;
      return (_a = getSpan(context11)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    exports.getSpanContext = getSpanContext;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    exports.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    exports.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    exports.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    exports.wrapSpanContext = wrapSpanContext;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracer = void 0;
    var context_1 = require_context2();
    var context_utils_1 = require_context_utils();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var spancontext_utils_1 = require_spancontext_utils();
    var contextApi = context_1.ContextAPI.getInstance();
    var NoopTracer = class {
      // startSpan starts a noop span.
      startSpan(name, options4, context11 = contextApi.active()) {
        const root = Boolean(options4 === null || options4 === void 0 ? void 0 : options4.root);
        if (root) {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
        const parentFromContext = context11 && (0, context_utils_1.getSpanContext)(context11);
        if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
          return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn2;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn2 = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn2 = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn2 = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        const span4 = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span4);
        return contextApi.with(contextWithSpanSet, fn2, void 0, span4);
      }
    };
    __name(NoopTracer, "NoopTracer");
    exports.NoopTracer = NoopTracer;
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NOOP_TRACER = new NoopTracer_1.NoopTracer();
    var ProxyTracer = class {
      constructor(_provider, name, version, options4) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options4;
      }
      startSpan(name, options4, context11) {
        return this._getTracer().startSpan(name, options4, context11);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        const tracer4 = this._getTracer();
        return Reflect.apply(tracer4.startActiveSpan, tracer4, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate) {
          return this._delegate;
        }
        const tracer4 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer4) {
          return NOOP_TRACER;
        }
        this._delegate = tracer4;
        return this._delegate;
      }
    };
    __name(ProxyTracer, "ProxyTracer");
    exports.ProxyTracer = ProxyTracer;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NoopTracerProvider = class {
      getTracer(_name, _version2, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    __name(NoopTracerProvider, "NoopTracerProvider");
    exports.NoopTracerProvider = NoopTracerProvider;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer();
    var NoopTracerProvider_1 = require_NoopTracerProvider();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
    var ProxyTracerProvider = class {
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name, version, options4) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options4)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options4);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name, version, options4) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options4);
      }
    };
    __name(ProxyTracerProvider, "ProxyTracerProvider");
    exports.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanKind = void 0;
    var SpanKind3;
    (function(SpanKind4) {
      SpanKind4[SpanKind4["INTERNAL"] = 0] = "INTERNAL";
      SpanKind4[SpanKind4["SERVER"] = 1] = "SERVER";
      SpanKind4[SpanKind4["CLIENT"] = 2] = "CLIENT";
      SpanKind4[SpanKind4["PRODUCER"] = 3] = "PRODUCER";
      SpanKind4[SpanKind4["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind3 = exports.SpanKind || (exports.SpanKind = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/status.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanStatusCode = void 0;
    var SpanStatusCode2;
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode2 = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    exports.validateKey = validateKey;
    function validateValue(value6) {
      return VALID_VALUE_BASE_REGEX.test(value6) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value6);
    }
    __name(validateValue, "validateValue");
    exports.validateValue = validateValue;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = class {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value6) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value6);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value6 = listMember.slice(i + 1, part.length);
            if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value6)) {
              agg.set(key, value6);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    __name(TraceStateImpl, "TraceStateImpl");
    exports.TraceStateImpl = TraceStateImpl;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState2(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    __name(createTraceState2, "createTraceState");
    exports.createTraceState = createTraceState2;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context-api.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.context = void 0;
    var context_1 = require_context2();
    exports.context = context_1.ContextAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag-api.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diag = void 0;
    var diag_1 = require_diag();
    exports.diag = diag_1.DiagAPI.instance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter();
    var NoopMeterProvider = class {
      getMeter(_name, _version2, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    __name(NoopMeterProvider, "NoopMeterProvider");
    exports.NoopMeterProvider = NoopMeterProvider;
    exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "metrics";
    var MetricsAPI = class {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new MetricsAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name, version, options4) {
        return this.getMeterProvider().getMeter(name, version, options4);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    __name(MetricsAPI, "MetricsAPI");
    exports.MetricsAPI = MetricsAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metrics = void 0;
    var metrics_1 = require_metrics();
    exports.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context11, _carrier) {
        return context11;
      }
      fields() {
        return [];
      }
    };
    __name(NoopTextMapPropagator, "NoopTextMapPropagator");
    exports.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = void 0;
    var context_1 = require_context2();
    var context_2 = require_context();
    var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context11) {
      return context11.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    exports.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    __name(getActiveBaggage, "getActiveBaggage");
    exports.getActiveBaggage = getActiveBaggage;
    function setBaggage(context11, baggage) {
      return context11.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    exports.setBaggage = setBaggage;
    function deleteBaggage(context11) {
      return context11.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    exports.deleteBaggage = deleteBaggage;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
    var TextMapPropagator_1 = require_TextMapPropagator();
    var context_helpers_1 = require_context_helpers();
    var utils_1 = require_utils();
    var diag_1 = require_diag();
    var API_NAME = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
    var PropagationAPI = class {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage;
        this.getBaggage = context_helpers_1.getBaggage;
        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
        this.setBaggage = context_helpers_1.setBaggage;
        this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new PropagationAPI();
        }
        return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context11, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context11, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context11, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context11, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    __name(PropagationAPI, "PropagationAPI");
    exports.PropagationAPI = PropagationAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.propagation = void 0;
    var propagation_1 = require_propagation();
    exports.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/trace.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceAPI = void 0;
    var global_utils_1 = require_global_utils();
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    var spancontext_utils_1 = require_spancontext_utils();
    var context_utils_1 = require_context_utils();
    var diag_1 = require_diag();
    var API_NAME = "trace";
    var TraceAPI = class {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
        this.deleteSpan = context_utils_1.deleteSpan;
        this.getSpan = context_utils_1.getSpan;
        this.getActiveSpan = context_utils_1.getActiveSpan;
        this.getSpanContext = context_utils_1.getSpanContext;
        this.setSpan = context_utils_1.setSpan;
        this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new TraceAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    __name(TraceAPI, "TraceAPI");
    exports.TraceAPI = TraceAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace-api.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = void 0;
    var trace_1 = require_trace();
    exports.trace = trace_1.TraceAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/index.js"(exports) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
      return utils_1.baggageEntryMetadataFromString;
    } });
    var context_1 = require_context();
    Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
      return context_1.createContextKey;
    } });
    Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
      return context_1.ROOT_CONTEXT;
    } });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
      return consoleLogger_1.DiagConsoleLogger;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
      return types_1.DiagLogLevel;
    } });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
      return NoopMeter_1.createNoopMeter;
    } });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
      return Metric_1.ValueType;
    } });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
      return TextMapPropagator_1.defaultTextMapGetter;
    } });
    Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
      return TextMapPropagator_1.defaultTextMapSetter;
    } });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
      return ProxyTracer_1.ProxyTracer;
    } });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    } });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
      return SamplingResult_1.SamplingDecision;
    } });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
      return span_kind_1.SpanKind;
    } });
    var status_1 = require_status();
    Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
      return status_1.SpanStatusCode;
    } });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
      return trace_flags_1.TraceFlags;
    } });
    var utils_2 = require_utils2();
    Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
      return utils_2.createTraceState;
    } });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
      return spancontext_utils_1.isSpanContextValid;
    } });
    Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
      return spancontext_utils_1.isValidTraceId;
    } });
    Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
      return spancontext_utils_1.isValidSpanId;
    } });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_SPANID;
    } });
    Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_TRACEID;
    } });
    Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    } });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports, "context", { enumerable: true, get: function() {
      return context_api_1.context;
    } });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
      return diag_api_1.diag;
    } });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
      return metrics_api_1.metrics;
    } });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
      return propagation_api_1.propagation;
    } });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
      return trace_api_1.trace;
    } });
    exports.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// .wrangler/tmp/bundle-gWfDcw/middleware-loader.entry.ts
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// .wrangler/tmp/bundle-gWfDcw/middleware-insertion-facade.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// src/index.ts
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/durable-object.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
import { DurableObject } from "cloudflare:workers";

// node_modules/.pnpm/@livestore+common-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/common-cf/dist/do-rpc/mod.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/global.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do3,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all7,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen6,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap2,
  as: () => as7,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid5,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind4,
  bindAll: () => bindAll2,
  bindTo: () => bindTo4,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die7,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either3,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring2,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every10,
  exists: () => exists4,
  exit: () => exit3,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter11,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap7,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst8,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap14,
  flatten: () => flatten10,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach10,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen3,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_4,
  liftPredicate: () => liftPredicate3,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map20,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth4,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause3,
  mapInputContext: () => mapInputContext2,
  match: () => match14,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect3,
  merge: () => merge7,
  mergeAll: () => mergeAll4,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once3,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse6,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition6,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce12,
  reduceEffect: () => reduceEffect2,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped3,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed10,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync6,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_3,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip8,
  zipLeft: () => zipLeft6,
  zipRight: () => zipRight6,
  zipWith: () => zipWith8
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Function.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isFunction = /* @__PURE__ */ __name((input) => typeof input === "function", "isFunction");
var dual = /* @__PURE__ */ __name(function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self2) {
          return body(self2, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self2) {
          return body(self2, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self2) {
          return body(self2, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self2) {
          return body(self2, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self2) {
          return body(self2, ...args2);
        };
      };
  }
}, "dual");
var identity = /* @__PURE__ */ __name((a) => a, "identity");
var unsafeCoerce = identity;
var constant = /* @__PURE__ */ __name((value6) => () => value6, "constant");
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
__name(pipe, "pipe");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cause.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Either.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Equivalence.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make = /* @__PURE__ */ __name((isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that), "make");
var isStrictEquivalent = /* @__PURE__ */ __name((x, y) => x === y, "isStrictEquivalent");
var strict = /* @__PURE__ */ __name(() => isStrictEquivalent, "strict");
var string = /* @__PURE__ */ strict();
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date4) => date4.getTime());
var array = /* @__PURE__ */ __name((item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
}), "array");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/doNotation.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var let_ = /* @__PURE__ */ __name((map33) => dual(3, (self2, name, f) => map33(self2, (a) => ({
  ...a,
  [name]: f(a)
}))), "let_");
var bindTo = /* @__PURE__ */ __name((map33) => dual(2, (self2, name) => map33(self2, (a) => ({
  [name]: a
}))), "bindTo");
var bind = /* @__PURE__ */ __name((map33, flatMap23) => dual(3, (self2, name, f) => flatMap23(self2, (a) => map33(f(a), (b) => ({
  ...a,
  [name]: b
})))), "bind");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/either.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Equal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  array: () => array2,
  cached: () => cached,
  combine: () => combine,
  hash: () => hash,
  isHash: () => isHash,
  number: () => number2,
  optimize: () => optimize,
  random: () => random,
  string: () => string2,
  structure: () => structure,
  structureKeys: () => structureKeys,
  symbol: () => symbol
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/GlobalValue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = /* @__PURE__ */ __name((id3, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id3)) {
    globalStore.set(id3, compute());
  }
  return globalStore.get(id3);
}, "globalValue");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Predicate.js
var Predicate_exports = {};
__export(Predicate_exports, {
  all: () => all,
  and: () => and,
  compose: () => compose,
  eqv: () => eqv,
  every: () => every,
  hasProperty: () => hasProperty,
  implies: () => implies,
  isBigInt: () => isBigInt,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isIterable: () => isIterable,
  isMap: () => isMap,
  isNever: () => isNever,
  isNotNull: () => isNotNull,
  isNotNullable: () => isNotNullable,
  isNotUndefined: () => isNotUndefined,
  isNull: () => isNull,
  isNullable: () => isNullable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isPromiseLike: () => isPromiseLike,
  isPropertyKey: () => isPropertyKey,
  isReadonlyRecord: () => isReadonlyRecord,
  isRecord: () => isRecord,
  isRecordOrArray: () => isRecordOrArray,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTagged: () => isTagged,
  isTruthy: () => isTruthy,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  isUint8Array: () => isUint8Array,
  isUndefined: () => isUndefined,
  isUnknown: () => isUnknown,
  mapInput: () => mapInput2,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  product: () => product,
  productMany: () => productMany,
  some: () => some,
  struct: () => struct,
  tuple: () => tuple,
  xor: () => xor
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => (b) => self2(f(b)));
var isTupleOf = /* @__PURE__ */ dual(2, (self2, n) => self2.length === n);
var isTupleOfAtLeast = /* @__PURE__ */ dual(2, (self2, n) => self2.length >= n);
var isTruthy = /* @__PURE__ */ __name((input) => !!input, "isTruthy");
var isSet = /* @__PURE__ */ __name((input) => input instanceof Set, "isSet");
var isMap = /* @__PURE__ */ __name((input) => input instanceof Map, "isMap");
var isString = /* @__PURE__ */ __name((input) => typeof input === "string", "isString");
var isNumber = /* @__PURE__ */ __name((input) => typeof input === "number", "isNumber");
var isBoolean = /* @__PURE__ */ __name((input) => typeof input === "boolean", "isBoolean");
var isBigInt = /* @__PURE__ */ __name((input) => typeof input === "bigint", "isBigInt");
var isSymbol = /* @__PURE__ */ __name((input) => typeof input === "symbol", "isSymbol");
var isPropertyKey = /* @__PURE__ */ __name((u) => isString(u) || isNumber(u) || isSymbol(u), "isPropertyKey");
var isFunction2 = isFunction;
var isUndefined = /* @__PURE__ */ __name((input) => input === void 0, "isUndefined");
var isNotUndefined = /* @__PURE__ */ __name((input) => input !== void 0, "isNotUndefined");
var isNull = /* @__PURE__ */ __name((input) => input === null, "isNull");
var isNotNull = /* @__PURE__ */ __name((input) => input !== null, "isNotNull");
var isNever = /* @__PURE__ */ __name((_) => false, "isNever");
var isUnknown = /* @__PURE__ */ __name((_) => true, "isUnknown");
var isRecordOrArray = /* @__PURE__ */ __name((input) => typeof input === "object" && input !== null, "isRecordOrArray");
var isObject = /* @__PURE__ */ __name((input) => isRecordOrArray(input) || isFunction2(input), "isObject");
var hasProperty = /* @__PURE__ */ dual(2, (self2, property2) => isObject(self2) && property2 in self2);
var isTagged = /* @__PURE__ */ dual(2, (self2, tag8) => hasProperty(self2, "_tag") && self2["_tag"] === tag8);
var isNullable = /* @__PURE__ */ __name((input) => input === null || input === void 0, "isNullable");
var isNotNullable = /* @__PURE__ */ __name((input) => input !== null && input !== void 0, "isNotNullable");
var isError = /* @__PURE__ */ __name((input) => input instanceof Error, "isError");
var isUint8Array = /* @__PURE__ */ __name((input) => input instanceof Uint8Array, "isUint8Array");
var isDate = /* @__PURE__ */ __name((input) => input instanceof Date, "isDate");
var isIterable = /* @__PURE__ */ __name((input) => typeof input === "string" || hasProperty(input, Symbol.iterator), "isIterable");
var isRecord = /* @__PURE__ */ __name((input) => isRecordOrArray(input) && !Array.isArray(input), "isRecord");
var isReadonlyRecord = isRecord;
var isPromise = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && "catch" in input && isFunction2(input.then) && isFunction2(input.catch), "isPromise");
var isPromiseLike = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && isFunction2(input.then), "isPromiseLike");
var isRegExp = /* @__PURE__ */ __name((input) => input instanceof RegExp, "isRegExp");
var compose = /* @__PURE__ */ dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var product = /* @__PURE__ */ __name((self2, that) => ([a, b]) => self2(a) && that(b), "product");
var all = /* @__PURE__ */ __name((collection) => {
  return (as14) => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as14.length) {
        break;
      }
      if (p(as14[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
}, "all");
var productMany = /* @__PURE__ */ __name((self2, collection) => {
  const rest = all(collection);
  return ([head10, ...tail2]) => self2(head10) === false ? false : rest(tail2);
}, "productMany");
var tuple = /* @__PURE__ */ __name((...elements) => all(elements), "tuple");
var struct = /* @__PURE__ */ __name((fields) => {
  const keys6 = Object.keys(fields);
  return (a) => {
    for (const key of keys6) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
}, "struct");
var not = /* @__PURE__ */ __name((self2) => (a) => !self2(a), "not");
var or = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) || that(a));
var and = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) && that(a));
var xor = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) !== that(a));
var eqv = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) === that(a));
var implies = /* @__PURE__ */ dual(2, (antecedent, consequent) => (a) => antecedent(a) ? consequent(a) : true);
var nor = /* @__PURE__ */ dual(2, (self2, that) => (a) => !(self2(a) || that(a)));
var nand = /* @__PURE__ */ dual(2, (self2, that) => (a) => !(self2(a) && that(a)));
var every = /* @__PURE__ */ __name((collection) => (a) => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
}, "every");
var some = /* @__PURE__ */ __name((collection) => (a) => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
}, "some");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Utils.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/errors.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var getBugErrorMessage = /* @__PURE__ */ __name((message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`, "getBugErrorMessage");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var isGenKind = /* @__PURE__ */ __name((u) => isObject(u) && GenKindTypeId in u, "isGenKind");
var GenKindImpl = class {
  value;
  constructor(value6) {
    this.value = value6;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
__name(GenKindImpl, "GenKindImpl");
var SingleShotGen = class {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
};
__name(SingleShotGen, "SingleShotGen");
var adapter = /* @__PURE__ */ __name(() => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
}, "adapter");
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max8) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max8;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
__name(PCGRandom, "PCGRandom");
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
__name(mul64, "mul64");
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
__name(add64, "add64");
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value6) {
    this.#value = value6;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
__name(YieldWrap, "YieldWrap");
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
__name(yieldWrapGet, "yieldWrapGet");
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = /* @__PURE__ */ __name((u) => isObject(u) && u.constructor === genConstructor, "isGeneratorFunction");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = /* @__PURE__ */ __name((self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string2(self2.toString(10));
    case "boolean":
      return string2(String(self2));
    case "symbol":
      return string2(String(self2));
    case "string":
      return string2(self2);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string2("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
}, "hash");
var random = /* @__PURE__ */ __name((self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
}, "random");
var combine = /* @__PURE__ */ __name((b) => (self2) => self2 * 53 ^ b, "combine");
var optimize = /* @__PURE__ */ __name((n) => n & 3221225471 | n >>> 1 & 1073741824, "optimize");
var isHash = /* @__PURE__ */ __name((u) => hasProperty(u, symbol), "isHash");
var number2 = /* @__PURE__ */ __name((n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
}, "number");
var string2 = /* @__PURE__ */ __name((str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
}, "string");
var structureKeys = /* @__PURE__ */ __name((o, keys6) => {
  let h = 12289;
  for (let i = 0; i < keys6.length; i++) {
    h ^= pipe(string2(keys6[i]), combine(hash(o[keys6[i]])));
  }
  return optimize(h);
}, "structureKeys");
var structure = /* @__PURE__ */ __name((o) => structureKeys(o, Object.keys(o)), "structure");
var array2 = /* @__PURE__ */ __name((arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
}, "array");
var cached = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash6) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash6;
        },
        enumerable: false
      });
      return hash6;
    };
  }
  const self2 = arguments[0];
  const hash5 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash5;
    },
    enumerable: false
  });
  return hash5;
}, "cached");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
__name(equals, "equals");
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
__name(compareBoth, "compareBoth");
var isEqual = /* @__PURE__ */ __name((u) => hasProperty(u, symbol2), "isEqual");
var equivalence = /* @__PURE__ */ __name(() => equals, "equivalence");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Inspectable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = /* @__PURE__ */ __name((x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
}, "toJSON");
var format = /* @__PURE__ */ __name((x) => JSON.stringify(x, null, 2), "format");
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
__name(Class, "Class");
var toStringUnknown = /* @__PURE__ */ __name((u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
}, "toStringUnknown");
var stringifyCircular = /* @__PURE__ */ __name((obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value6) => typeof value6 === "object" && value6 !== null ? cache.includes(value6) ? void 0 : cache.push(value6) && (redactableState.fiberRefs !== void 0 && isRedactable(value6) ? value6[symbolRedactable](redactableState.fiberRefs) : value6) : value6, whitespace);
  cache = void 0;
  return retVal;
}, "stringifyCircular");
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && symbolRedactable in u, "isRedactable");
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = /* @__PURE__ */ __name((context11, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context11;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
}, "withRedactableContext");
var redact = /* @__PURE__ */ __name((u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
}, "redact");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/effectable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Pipeable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var pipeArguments = /* @__PURE__ */ __name((self2, args2) => {
  switch (args2.length) {
    case 0:
      return self2;
    case 1:
      return args2[0](self2);
    case 2:
      return args2[1](args2[0](self2));
    case 3:
      return args2[2](args2[1](args2[0](self2)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self2))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
}, "pipeArguments");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/effect.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/version.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var moduleVersion = "3.18.4";
var getCurrentVersion = /* @__PURE__ */ __name(() => moduleVersion, "getCurrentVersion");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base3() {
  }
  __name(Base3, "Base");
  Base3.prototype = CommitPrototype;
  return Base3;
}();
var StructuralBase = /* @__PURE__ */ function() {
  function Base3() {
  }
  __name(Base3, "Base");
  Base3.prototype = StructuralCommitPrototype;
  return Base3;
}();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/option.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId), "isOption");
var isNone = /* @__PURE__ */ __name((fa) => fa._tag === "None", "isNone");
var isSome = /* @__PURE__ */ __name((fa) => fa._tag === "Some", "isSome");
var none = /* @__PURE__ */ Object.create(NoneProto);
var some2 = /* @__PURE__ */ __name((value6) => {
  const a = Object.create(SomeProto);
  a.value = value6;
  return a;
}, "some");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId2), "isEither");
var isLeft = /* @__PURE__ */ __name((ma) => ma._tag === "Left", "isLeft");
var isRight = /* @__PURE__ */ __name((ma) => ma._tag === "Right", "isRight");
var left = /* @__PURE__ */ __name((left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
}, "left");
var right = /* @__PURE__ */ __name((right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
}, "right");
var getLeft = /* @__PURE__ */ __name((self2) => isRight(self2) ? none : some2(self2.left), "getLeft");
var getRight = /* @__PURE__ */ __name((self2) => isLeft(self2) ? none : some2(self2.right), "getRight");
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = /* @__PURE__ */ __name((evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
}, "try_");
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getEquivalence = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right)), "getEquivalence");
var mapBoth = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isNonEmptyArray = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmptyArray");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Iterable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do,
  TypeId: () => TypeId3,
  all: () => all3,
  andThen: () => andThen,
  ap: () => ap,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind2,
  bindTo: () => bindTo2,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable,
  gen: () => gen,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined,
  getOrder: () => getOrder,
  getRight: () => getRight2,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_2,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product2,
  productMany: () => productMany2,
  reduceCompact: () => reduceCompact,
  some: () => some3,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Order.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make2 = /* @__PURE__ */ __name((compare3) => (self2, that) => self2 === that ? 0 : compare3(self2, that), "make");
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var bigint = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var mapInput3 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
var all2 = /* @__PURE__ */ __name((collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
}, "all");
var tuple2 = /* @__PURE__ */ __name((...elements) => all2(elements), "tuple");
var lessThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === -1), "lessThan");
var greaterThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === 1), "greaterThan");
var lessThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== 1), "lessThanOrEqualTo");
var greaterThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== -1), "greaterThanOrEqualTo");
var min = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) < 1 ? self2 : that), "min");
var max = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) > -1 ? self2 : that), "max");
var clamp = /* @__PURE__ */ __name((O) => dual(2, (self2, options4) => min(O)(options4.maximum, max(O)(options4.minimum, self2))), "clamp");
var between = /* @__PURE__ */ __name((O) => dual(2, (self2, options4) => !lessThan(O)(self2, options4.minimum) && !greaterThan(O)(self2, options4.maximum)), "between");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Option.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Option");
var none2 = /* @__PURE__ */ __name(() => none, "none");
var some3 = some2;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var toRefinement = /* @__PURE__ */ __name((f) => (a) => isSome2(f(a)), "toRefinement");
var fromIterable = /* @__PURE__ */ __name((collection) => {
  for (const a of collection) {
    return some3(a);
  }
  return none2();
}, "fromIterable");
var getRight2 = getRight;
var getLeft2 = getLeft;
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some3(onNone()) : self2);
var orElseEither = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? map2(that(), right) : map2(self2, left));
var firstSomeOf = /* @__PURE__ */ __name((collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
}, "firstSomeOf");
var fromNullable = /* @__PURE__ */ __name((nullableValue) => nullableValue == null ? none2() : some3(nullableValue), "fromNullable");
var liftNullable = /* @__PURE__ */ __name((f) => (...a) => fromNullable(f(...a)), "liftNullable");
var getOrNull = /* @__PURE__ */ getOrElse(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = /* @__PURE__ */ __name((f) => (...a) => {
  try {
    return some3(f(...a));
  } catch {
    return none2();
  }
}, "liftThrowable");
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some3(f(self2.value)));
var as = /* @__PURE__ */ dual(2, (self2, b) => map2(self2, () => b));
var asVoid = /* @__PURE__ */ as(void 0);
var void_ = /* @__PURE__ */ some3(void 0);
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var andThen = /* @__PURE__ */ dual(2, (self2, f) => flatMap(self2, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isOption2(b) ? b : some3(b);
}));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
var flatten = /* @__PURE__ */ flatMap(identity);
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap(self2, () => that));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => tap(self2, () => that));
var composeK = /* @__PURE__ */ dual(2, (afb, bfc) => (a) => flatMap(afb(a), bfc));
var tap = /* @__PURE__ */ dual(2, (self2, f) => flatMap(self2, (a) => map2(f(a), () => a)));
var product2 = /* @__PURE__ */ __name((self2, that) => isSome2(self2) && isSome2(that) ? some3([self2.value, that.value]) : none2(), "product");
var productMany2 = /* @__PURE__ */ __name((self2, collection) => {
  if (isNone2(self2)) {
    return none2();
  }
  const out = [self2.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some3(out);
}, "productMany");
var all3 = /* @__PURE__ */ __name((input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some3(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some3(out);
}, "all");
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => map2(product2(self2, that), ([a, b]) => f(a, b)));
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, (f, a) => f(a)));
var reduceCompact = /* @__PURE__ */ dual(3, (self2, b, f) => {
  let out = b;
  for (const oa of self2) {
    if (isSome2(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
var toArray = /* @__PURE__ */ __name((self2) => isNone2(self2) ? [] : [self2.value], "toArray");
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isNone2(self2)) {
    return [none2(), none2()];
  }
  const e = f(self2.value);
  return isLeft(e) ? [some3(e.left), none2()] : [none2(), some3(e.right)];
});
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some2(b) : none));
var getEquivalence2 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value)), "getEquivalence");
var getOrder = /* @__PURE__ */ __name((O) => make2((self2, that) => isSome2(self2) ? isSome2(that) ? O(self2.value, that.value) : 1 : -1), "getOrder");
var lift2 = /* @__PURE__ */ __name((f) => dual(2, (self2, that) => zipWith(self2, that, f)), "lift2");
var liftPredicate = /* @__PURE__ */ dual(2, (b, predicate) => predicate(b) ? some3(b) : none2());
var containsWith = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a)), "containsWith");
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var bindTo2 = /* @__PURE__ */ bindTo(map2);
var let_2 = /* @__PURE__ */ let_(map2);
var bind2 = /* @__PURE__ */ bind(map2, flatMap);
var Do = /* @__PURE__ */ some3({});
var adapter2 = /* @__PURE__ */ adapter();
var gen = /* @__PURE__ */ __name((...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter2);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isNone2(current2)) {
      return current2;
    }
    state = iterator.next(current2.value);
  }
  return some3(state.value);
}, "gen");
var mergeWith = /* @__PURE__ */ __name((f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some3(f(o1.value, o2.value));
}, "mergeWith");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Tuple.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make3 = /* @__PURE__ */ __name((...elements) => elements, "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Iterable.js
var unsafeHead = /* @__PURE__ */ __name((self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
}, "unsafeHead");
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty = /* @__PURE__ */ __name(() => constEmpty, "empty");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Record.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isEmptyRecord = /* @__PURE__ */ __name((self2) => keys(self2).length === 0, "isEmptyRecord");
var has = /* @__PURE__ */ dual(2, (self2, key) => Object.prototype.hasOwnProperty.call(self2, key));
var get = /* @__PURE__ */ dual(2, (self2, key) => has(self2, key) ? some3(self2[key]) : none2());
var map3 = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = {
    ...self2
  };
  for (const key of keys(self2)) {
    out[key] = f(self2[key], key);
  }
  return out;
});
var keys = /* @__PURE__ */ __name((self2) => Object.keys(self2), "keys");
var isSubrecordBy = /* @__PURE__ */ __name((equivalence3) => dual(2, (self2, that) => {
  for (const key of keys(self2)) {
    if (!has(that, key) || !equivalence3(self2[key], that[key])) {
      return false;
    }
  }
  return true;
}), "isSubrecordBy");
var getEquivalence3 = /* @__PURE__ */ __name((equivalence3) => {
  const is4 = isSubrecordBy(equivalence3);
  return (self2, that) => is4(self2, that) && is4(that, self2);
}, "getEquivalence");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Array.js
var allocate = /* @__PURE__ */ __name((n) => new Array(n), "allocate");
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max8 = Math.max(1, Math.floor(n));
  const out = new Array(max8);
  for (let i = 0; i < max8; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable2 = /* @__PURE__ */ __name((collection) => Array.isArray(collection) ? collection : Array.from(collection), "fromIterable");
var ensure = /* @__PURE__ */ __name((self2) => Array.isArray(self2) ? self2 : [self2], "ensure");
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head10) => [head10, ...self2]);
var append = /* @__PURE__ */ dual(2, (self2, last5) => [...self2, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable2(self2).concat(fromIterable2(that)));
var isArray = Array.isArray;
var isEmptyArray = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmptyArray");
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = /* @__PURE__ */ __name((i, as14) => i < 0 || i >= as14.length, "isOutOfBounds");
var clamp2 = /* @__PURE__ */ __name((i, as14) => Math.floor(Math.min(Math.max(0, i), as14.length)), "clamp");
var get2 = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i = Math.floor(index2);
  return isOutOfBounds(i, self2) ? none2() : some3(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i = Math.floor(index2);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var head = /* @__PURE__ */ get2(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = /* @__PURE__ */ __name((self2) => isNonEmptyReadonlyArray(self2) ? some3(lastNonEmpty(self2)) : none2(), "last");
var lastNonEmpty = /* @__PURE__ */ __name((self2) => self2[self2.length - 1], "lastNonEmpty");
var tailNonEmpty = /* @__PURE__ */ __name((self2) => self2.slice(1), "tailNonEmpty");
var spanIndex = /* @__PURE__ */ __name((self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
}, "spanIndex");
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  return input.slice(clamp2(n, input), input.length);
});
var findFirstIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (predicate(a, i)) {
      return some3(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const input = fromIterable2(self2);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some3(i);
    }
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self2, f) => {
  const input = fromIterable2(self2);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var modify = /* @__PURE__ */ dual(3, (self2, i, f) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
var remove = /* @__PURE__ */ dual(2, (self2, i) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var reverse = /* @__PURE__ */ __name((self2) => Array.from(self2).reverse(), "reverse");
var sort = /* @__PURE__ */ dual(2, (self2, O) => {
  const out = Array.from(self2);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith2(self2, that, make3));
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as14 = fromIterable2(self2);
  const bs = fromIterable2(that);
  if (isNonEmptyReadonlyArray(as14) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as14), headNonEmpty(bs))];
    const len = Math.min(as14.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as14[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = /* @__PURE__ */ __name((self2) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
}, "unzip");
var containsWith2 = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => {
  for (const i of self2) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
}), "containsWith");
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var copy = /* @__PURE__ */ __name((self2) => self2.slice(), "copy");
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable2(self2);
  const b = fromIterable2(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var intersectionWith = /* @__PURE__ */ __name((isEquivalent) => {
  const has11 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable2(self2).filter((a) => has11(that, a)));
}, "intersectionWith");
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var differenceWith = /* @__PURE__ */ __name((isEquivalent) => {
  const has11 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable2(self2).filter((a) => !has11(that, a)));
}, "differenceWith");
var difference = /* @__PURE__ */ differenceWith(_equivalence2);
var empty2 = /* @__PURE__ */ __name(() => [], "empty");
var of = /* @__PURE__ */ __name((a) => [a], "of");
var map4 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self2.length; i++) {
    const inner = f(self2[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten2 = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const as14 = fromIterable2(self2);
  const out = [];
  for (let i = 0; i < as14.length; i++) {
    const o = f(as14[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as14 = fromIterable2(self2);
  for (let i = 0; i < as14.length; i++) {
    const e = f(as14[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const as14 = fromIterable2(self2);
  const out = [];
  for (let i = 0; i < as14.length; i++) {
    if (predicate(as14[i], i)) {
      out.push(as14[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const left3 = [];
  const right3 = [];
  const as14 = fromIterable2(self2);
  for (let i = 0; i < as14.length; i++) {
    if (predicate(as14[i], i)) {
      right3.push(as14[i]);
    } else {
      left3.push(as14[i]);
    }
  }
  return [left3, right3];
});
var separate = /* @__PURE__ */ partitionMap2(identity);
var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
var every2 = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var unfold = /* @__PURE__ */ __name((b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
}, "unfold");
var getEquivalence4 = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = /* @__PURE__ */ __name((self2) => dedupeWith(self2, equivalence()), "dedupe");
var dedupeAdjacentWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self2) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some3(a);
    }
  }
  return out;
});
var dedupeAdjacent = /* @__PURE__ */ dedupeAdjacentWith(/* @__PURE__ */ equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable2(self2).join(sep));
var mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self2) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append2,
  appendAll: () => appendAll2,
  chunksOf: () => chunksOf,
  compact: () => compact,
  contains: () => contains3,
  containsWith: () => containsWith3,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent2,
  difference: () => difference2,
  differenceWith: () => differenceWith2,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty3,
  every: () => every3,
  filter: () => filter3,
  filterMap: () => filterMap3,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst3,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap3,
  flatten: () => flatten3,
  forEach: () => forEach,
  fromIterable: () => fromIterable3,
  get: () => get3,
  getEquivalence: () => getEquivalence5,
  head: () => head2,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection2,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  join: () => join2,
  last: () => last2,
  lastNonEmpty: () => lastNonEmpty2,
  make: () => make4,
  makeBy: () => makeBy2,
  map: () => map5,
  mapAccum: () => mapAccum2,
  modify: () => modify2,
  modifyOption: () => modifyOption,
  of: () => of2,
  partition: () => partition2,
  partitionMap: () => partitionMap3,
  prepend: () => prepend2,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce2,
  reduceRight: () => reduceRight2,
  remove: () => remove2,
  removeOption: () => removeOption,
  replace: () => replace,
  replaceOption: () => replaceOption,
  reverse: () => reverse2,
  separate: () => separate2,
  size: () => size,
  some: () => some4,
  sort: () => sort2,
  sortWith: () => sortWith,
  split: () => split,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile,
  toArray: () => toArray2,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union2,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet2,
  unsafeHead: () => unsafeHead2,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip2,
  zipWith: () => zipWith3
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src2, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src2.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src2[i];
  }
  return dest;
}
__name(copy2, "copy");
var emptyArray = [];
var getEquivalence5 = /* @__PURE__ */ __name((isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value6, i) => isEquivalent(value6, unsafeGet2(that, i)))), "getEquivalence");
var _equivalence3 = /* @__PURE__ */ getEquivalence5(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = /* @__PURE__ */ __name((backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
  }
  return chunk4;
}, "makeChunk");
var isChunk = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId4), "isChunk");
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty3 = /* @__PURE__ */ __name(() => _empty, "empty");
var make4 = /* @__PURE__ */ __name((...as14) => unsafeFromNonEmptyArray(as14), "make");
var of2 = /* @__PURE__ */ __name((a) => makeChunk({
  _tag: "ISingleton",
  a
}), "of");
var fromIterable3 = /* @__PURE__ */ __name((self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable2(self2)), "fromIterable");
var copyToArray = /* @__PURE__ */ __name((self2, array6, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array6, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array6, initial);
      copyToArray(self2.right, array6, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array6[j] = unsafeGet2(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
}, "copyToArray");
var toArray_ = /* @__PURE__ */ __name((self2) => toReadonlyArray(self2).slice(), "toArray_");
var toArray2 = toArray_;
var toReadonlyArray_ = /* @__PURE__ */ __name((self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty;
      self2.right = _empty;
      self2.depth = 0;
      return arr;
    }
  }
}, "toReadonlyArray_");
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = /* @__PURE__ */ __name((self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
}, "reverseChunk");
var reverse2 = reverseChunk;
var get3 = /* @__PURE__ */ dual(2, (self2, index2) => index2 < 0 || index2 >= self2.length ? none2() : some3(unsafeGet2(self2, index2)));
var unsafeFromArray = /* @__PURE__ */ __name((self2) => self2.length === 0 ? empty3() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
}), "unsafeFromArray");
var unsafeFromNonEmptyArray = /* @__PURE__ */ __name((self2) => unsafeFromArray(self2), "unsafeFromNonEmptyArray");
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, index2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index2 !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index2 >= self2.length || index2 < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index2];
    }
    case "IConcat": {
      return index2 < self2.left.length ? unsafeGet2(self2.left, index2) : unsafeGet2(self2.right, index2 - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self2.backing.chunk, index2 + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take(self2.right, n - self2.left.length)
          });
        }
        return take(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var dropRight = /* @__PURE__ */ dual(2, (self2, n) => take(self2, Math.max(0, self2.length - n)));
var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const arr = toReadonlyArray(self2);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self2, i);
});
var prependAll = /* @__PURE__ */ dual(2, (self2, that) => appendAll2(that, self2));
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff9 = that.depth - self2.depth;
  if (Math.abs(diff9) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff9 < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap3 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap2(self2, f)));
var filter3 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter2(self2, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
var compact = /* @__PURE__ */ __name((self2) => filterMap3(self2, identity), "compact");
var flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (self2.backing._tag === "ISingleton") {
    return f(self2.backing.a, 0);
  }
  let out = _empty;
  let i = 0;
  for (const k of self2) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var forEach = /* @__PURE__ */ dual(2, (self2, f) => toReadonlyArray(self2).forEach(f));
var flatten3 = /* @__PURE__ */ flatMap3(identity);
var chunksOf = /* @__PURE__ */ dual(2, (self2, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self2).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(intersection(toReadonlyArray(self2), toReadonlyArray(that))));
var isEmpty = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmpty");
var isNonEmpty = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");
var head2 = /* @__PURE__ */ get3(0);
var unsafeHead2 = /* @__PURE__ */ __name((self2) => unsafeGet2(self2, 0), "unsafeHead");
var headNonEmpty2 = unsafeHead2;
var last2 = /* @__PURE__ */ __name((self2) => get3(self2, self2.length - 1), "last");
var unsafeLast = /* @__PURE__ */ __name((self2) => unsafeGet2(self2, self2.length - 1), "unsafeLast");
var lastNonEmpty2 = unsafeLast;
var map5 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map4((a, i) => f(a, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const [s1, as14] = mapAccum(self2, s, f);
  return [s1, unsafeFromArray(as14)];
});
var partition2 = /* @__PURE__ */ dual(2, (self2, predicate) => pipe(partition(toReadonlyArray(self2), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap3 = /* @__PURE__ */ dual(2, (self2, f) => pipe(partitionMap2(toReadonlyArray(self2), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate2 = /* @__PURE__ */ __name((self2) => pipe(separate(toReadonlyArray(self2)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]), "separate");
var size = /* @__PURE__ */ __name((self2) => self2.length, "size");
var sort2 = /* @__PURE__ */ dual(2, (self2, O) => unsafeFromArray(sort(toReadonlyArray(self2), O)));
var sortWith = /* @__PURE__ */ dual(3, (self2, f, order) => sort2(self2, mapInput3(order, f)));
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
var splitNonEmptyAt2 = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [self2, empty3()] : [take(self2, _n), drop2(self2, _n)];
});
var split = /* @__PURE__ */ dual(2, (self2, n) => chunksOf(self2, Math.ceil(self2.length / Math.floor(n))));
var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self2, i);
});
var tail = /* @__PURE__ */ __name((self2) => self2.length > 0 ? some3(drop2(self2, 1)) : none2(), "tail");
var tailNonEmpty2 = /* @__PURE__ */ __name((self2) => drop2(self2, 1), "tailNonEmpty");
var takeRight = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(union(toReadonlyArray(self2), toReadonlyArray(that))));
var dedupe2 = /* @__PURE__ */ __name((self2) => unsafeFromArray(dedupe(toReadonlyArray(self2))), "dedupe");
var dedupeAdjacent2 = /* @__PURE__ */ __name((self2) => unsafeFromArray(dedupeAdjacent(self2)), "dedupeAdjacent");
var unzip2 = /* @__PURE__ */ __name((self2) => {
  const [left3, right3] = unzip(self2);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
}, "unzip");
var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith2(self2, that, f)));
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith3(self2, that, (a, b) => [a, b]));
var remove2 = /* @__PURE__ */ dual(2, (self2, i) => {
  if (i < 0 || i >= self2.length)
    return self2;
  return unsafeFromArray(remove(toReadonlyArray(self2), i));
});
var removeOption = /* @__PURE__ */ dual(2, (self2, i) => {
  if (i < 0 || i >= self2.length)
    return none2();
  return some3(unsafeFromArray(remove(toReadonlyArray(self2), i)));
});
var modifyOption = /* @__PURE__ */ dual(3, (self2, i, f) => {
  if (i < 0 || i >= self2.length)
    return none2();
  return some3(unsafeFromArray(modify(toReadonlyArray(self2), i, f)));
});
var modify2 = /* @__PURE__ */ dual(3, (self2, i, f) => getOrElse(modifyOption(self2, i, f), () => self2));
var replace = /* @__PURE__ */ dual(3, (self2, i, b) => modify2(self2, i, () => b));
var replaceOption = /* @__PURE__ */ dual(3, (self2, i, b) => modifyOption(self2, i, () => b));
var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable3(makeBy(n, f)));
var range = /* @__PURE__ */ __name((start3, end6) => start3 <= end6 ? makeBy2(end6 - start3 + 1, (i) => start3 + i) : of2(start3), "range");
var contains3 = contains2;
var containsWith3 = containsWith2;
var findFirst3 = findFirst2;
var findFirstIndex2 = findFirstIndex;
var findLast2 = findLast;
var findLastIndex2 = findLastIndex;
var every3 = /* @__PURE__ */ dual(2, (self2, refinement) => fromIterable2(self2).every(refinement));
var some4 = /* @__PURE__ */ dual(2, (self2, predicate) => fromIterable2(self2).some(predicate));
var join2 = join;
var reduce2 = reduce;
var reduceRight2 = reduceRight;
var differenceWith2 = /* @__PURE__ */ __name((isEquivalent) => {
  return dual(2, (self2, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self2)));
}, "differenceWith");
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(difference(that, self2)));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashSet.js
var HashSet_exports = {};
__export(HashSet_exports, {
  add: () => add2,
  beginMutation: () => beginMutation3,
  difference: () => difference4,
  empty: () => empty6,
  endMutation: () => endMutation3,
  every: () => every6,
  filter: () => filter6,
  flatMap: () => flatMap6,
  forEach: () => forEach4,
  fromIterable: () => fromIterable6,
  has: () => has4,
  intersection: () => intersection4,
  isHashSet: () => isHashSet2,
  isSubset: () => isSubset2,
  make: () => make8,
  map: () => map8,
  mutate: () => mutate3,
  partition: () => partition4,
  reduce: () => reduce5,
  remove: () => remove5,
  size: () => size4,
  some: () => some7,
  toValues: () => toValues,
  toggle: () => toggle2,
  union: () => union5,
  values: () => values3
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/config.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
__name(popcount, "popcount");
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
__name(hashFragment, "hashFragment");
function toBitmap(x) {
  return 1 << x;
}
__name(toBitmap, "toBitmap");
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
__name(fromBitmap, "fromBitmap");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/node.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stack.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make5 = /* @__PURE__ */ __name((value6, previous2) => ({
  value: value6,
  previous: previous2
}), "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function arrayUpdate(mutate6, at, v, arr) {
  let out = arr;
  if (!mutate6) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
__name(arrayUpdate, "arrayUpdate");
function arraySpliceOut(mutate6, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate6) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate6) {
    out.length = newLen;
  }
  return out;
}
__name(arraySpliceOut, "arraySpliceOut");
function arraySpliceIn(mutate6, at, v, arr) {
  const len = arr.length;
  if (mutate6) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}
__name(arraySpliceIn, "arraySpliceIn");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash5, key, size18) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode();
    ++size18.value;
    return new LeafNode(edit, hash5, key, v);
  }
};
__name(EmptyNode, "EmptyNode");
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
__name(isEmptyNode, "isEmptyNode");
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
__name(isLeafNode, "isLeafNode");
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
__name(canEditNode, "canEditNode");
var LeafNode = class {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash5, key, value6) {
    this.edit = edit;
    this.hash = hash5;
    this.key = key;
    this.value = value6;
  }
  modify(edit, shift2, f, hash5, key, size18) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size18.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash5, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size18.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash5, new LeafNode(edit, hash5, key, v));
  }
};
__name(LeafNode, "LeafNode");
var CollisionNode = class {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash5, children3) {
    this.edit = edit;
    this.hash = hash5;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size18) {
    if (hash5 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size18);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size18.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash5, new LeafNode(edit, hash5, key, v));
  }
  updateCollisionList(mutate6, edit, hash5, list, f, key, size18) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value6 = child.value;
        const newValue2 = f(value6);
        if (newValue2 === value6)
          return list;
        if (isNone2(newValue2)) {
          --size18.value;
          return arraySpliceOut(mutate6, i, list);
        }
        return arrayUpdate(mutate6, i, new LeafNode(edit, hash5, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size18.value;
    return arrayUpdate(mutate6, len, new LeafNode(edit, hash5, key, newValue), list);
  }
};
__name(CollisionNode, "CollisionNode");
var IndexedNode = class {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children3) {
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size18) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash5);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists5 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists5) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash5, key, size18);
      if (!_newChild)
        return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f, hash5, key, size18);
    if (current2 === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
};
__name(IndexedNode, "IndexedNode");
var ArrayNode = class {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size18, children3) {
    this.edit = edit;
    this.size = size18;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size18) {
    let count4 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash5);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash5, key, size18);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count4;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count4;
      if (count4 <= MIN_ARRAY_NODE) {
        return pack(edit, count4, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count4;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count4, newChildren);
  }
};
__name(ArrayNode, "ArrayNode");
function pack(edit, count4, removed, elements) {
  const children3 = new Array(count4 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
__name(pack, "pack");
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count4 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count4++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count4 + 1, arr);
}
__name(expand, "expand");
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
__name(mergeLeavesInner, "mergeLeavesInner");
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make5(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
__name(mergeLeaves, "mergeLeaves");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash5 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash5 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash5);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = /* @__PURE__ */ __name((editable, edit, root, size18) => {
  const map33 = Object.create(HashMapProto);
  map33._editable = editable;
  map33._edit = edit;
  map33._root = root;
  map33._size = size18;
  return map33;
}, "makeImpl");
var HashMapIterator = class {
  map;
  f;
  v;
  constructor(map33, f) {
    this.map = map33;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
};
__name(HashMapIterator, "HashMapIterator");
var applyCont = /* @__PURE__ */ __name((cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2(), "applyCont");
var visitLazy = /* @__PURE__ */ __name((node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some3({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}, "visitLazy");
var visitLazyChildren = /* @__PURE__ */ __name((len, children3, i, f, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children3, i, f, cont]);
    }
  }
  return applyCont(cont);
}, "visitLazyChildren");
var _empty2 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty4 = /* @__PURE__ */ __name(() => _empty2, "empty");
var make6 = /* @__PURE__ */ __name((...entries3) => fromIterable4(entries3), "make");
var fromIterable4 = /* @__PURE__ */ __name((entries3) => {
  const map33 = beginMutation(empty4());
  for (const entry of entries3) {
    set(map33, entry[0], entry[1]);
  }
  return endMutation(map33);
}, "fromIterable");
var isHashMap = /* @__PURE__ */ __name((u) => hasProperty(u, HashMapTypeId), "isHashMap");
var isEmpty2 = /* @__PURE__ */ __name((self2) => self2 && isEmptyNode(self2._root), "isEmpty");
var get4 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash5) => {
  let node = self2._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash5 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash5);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash5)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet3 = /* @__PURE__ */ dual(2, (self2, key) => {
  const element2 = getHash(self2, key, hash(key));
  if (isNone2(element2)) {
    throw new Error("Expected map to contain key");
  }
  return element2.value;
});
var has2 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var hasHash = /* @__PURE__ */ dual(3, (self2, key, hash5) => isSome2(getHash(self2, key, hash5)));
var hasBy = /* @__PURE__ */ dual(2, (self2, predicate) => isSome2(findFirst4(self2, predicate)));
var set = /* @__PURE__ */ dual(3, (self2, key, value6) => modifyAt(self2, key, () => some3(value6)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    ;
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys2 = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (key) => key), "keys");
var values = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (_, value6) => value6), "values");
var entries = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (key, value6) => [key, value6]), "entries");
var size2 = /* @__PURE__ */ __name((self2) => self2._size, "size");
var countBy = /* @__PURE__ */ dual(2, (self2, f) => {
  let count4 = 0;
  for (const [k, a] of self2) {
    if (f(a, k)) {
      count4++;
    }
  }
  return count4;
});
var beginMutation = /* @__PURE__ */ __name((self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size), "beginMutation");
var endMutation = /* @__PURE__ */ __name((self2) => {
  ;
  self2._editable = false;
  return self2;
}, "endMutation");
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash5, f) => {
  const size18 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash5, key, size18);
  return pipe(self2, setTree(newRoot, size18.value));
});
var modify3 = /* @__PURE__ */ dual(3, (self2, key, f) => modifyAt(self2, key, map2(f)));
var union3 = /* @__PURE__ */ dual(2, (self2, that) => {
  const result = beginMutation(self2);
  forEach2(that, (v, k) => set(result, k, v));
  return endMutation(result);
});
var remove3 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var removeMany = /* @__PURE__ */ dual(2, (self2, keys6) => mutate(self2, (map33) => {
  for (const key of keys6) {
    remove3(key)(map33);
  }
}));
var map6 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty4(), (map33, value6, key) => set(map33, key, f(value6, key))));
var flatMap4 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty4(), (zero3, value6, key) => mutate(zero3, (map33) => forEach2(f(value6, key), (value7, key2) => set(map33, key2, value7)))));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, void 0, (_, value6, key) => f(value6, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter4 = /* @__PURE__ */ dual(2, (self2, f) => mutate(empty4(), (map33) => {
  for (const [k, a] of self2) {
    if (f(a, k)) {
      set(map33, k, a);
    }
  }
}));
var compact2 = /* @__PURE__ */ __name((self2) => filterMap4(self2, identity), "compact");
var filterMap4 = /* @__PURE__ */ dual(2, (self2, f) => mutate(empty4(), (map33) => {
  for (const [k, a] of self2) {
    const option7 = f(a, k);
    if (isSome2(option7)) {
      set(map33, k, option7.value);
    }
  }
}));
var findFirst4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const ka of self2) {
    if (predicate(ka[1], ka[0])) {
      return some3(ka);
    }
  }
  return none2();
});
var some5 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const ka of self2) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every4 = /* @__PURE__ */ dual(2, (self2, predicate) => !some5(self2, (a, k) => !predicate(a, k)));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size2(this._keyMap) === size2(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = /* @__PURE__ */ __name((keyMap) => {
  const set15 = Object.create(HashSetProto);
  set15._keyMap = keyMap;
  return set15;
}, "makeImpl");
var isHashSet = /* @__PURE__ */ __name((u) => hasProperty(u, HashSetTypeId), "isHashSet");
var _empty3 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty4());
var empty5 = /* @__PURE__ */ __name(() => _empty3, "empty");
var fromIterable5 = /* @__PURE__ */ __name((elements) => {
  const set15 = beginMutation2(empty5());
  for (const value6 of elements) {
    add(set15, value6);
  }
  return endMutation2(set15);
}, "fromIterable");
var make7 = /* @__PURE__ */ __name((...elements) => {
  const set15 = beginMutation2(empty5());
  for (const value6 of elements) {
    add(set15, value6);
  }
  return endMutation2(set15);
}, "make");
var has3 = /* @__PURE__ */ dual(2, (self2, value6) => has2(self2._keyMap, value6));
var some6 = /* @__PURE__ */ dual(2, (self2, f) => {
  let found = false;
  for (const value6 of self2) {
    found = f(value6);
    if (found) {
      break;
    }
  }
  return found;
});
var every5 = /* @__PURE__ */ dual(2, (self2, refinement) => !some6(self2, (a) => !refinement(a)));
var isSubset = /* @__PURE__ */ dual(2, (self2, that) => every5(self2, (value6) => has3(that, value6)));
var values2 = /* @__PURE__ */ __name((self2) => keys2(self2._keyMap), "values");
var size3 = /* @__PURE__ */ __name((self2) => size2(self2._keyMap), "size");
var beginMutation2 = /* @__PURE__ */ __name((self2) => makeImpl2(beginMutation(self2._keyMap)), "beginMutation");
var endMutation2 = /* @__PURE__ */ __name((self2) => {
  ;
  self2._keyMap._editable = false;
  return self2;
}, "endMutation");
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add = /* @__PURE__ */ dual(2, (self2, value6) => self2._keyMap._editable ? (set(value6, true)(self2._keyMap), self2) : makeImpl2(set(value6, true)(self2._keyMap)));
var remove4 = /* @__PURE__ */ dual(2, (self2, value6) => self2._keyMap._editable ? (remove3(value6)(self2._keyMap), self2) : makeImpl2(remove3(value6)(self2._keyMap)));
var difference3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set15) => {
  for (const value6 of that) {
    remove4(set15, value6);
  }
}));
var intersection3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty5(), (set15) => {
  for (const value6 of that) {
    if (has3(value6)(self2)) {
      add(value6)(set15);
    }
  }
}));
var union4 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty5(), (set15) => {
  forEach3(self2, (value6) => add(set15, value6));
  for (const value6 of that) {
    add(set15, value6);
  }
}));
var toggle = /* @__PURE__ */ dual(2, (self2, value6) => has3(self2, value6) ? remove4(self2, value6) : add(self2, value6));
var map7 = /* @__PURE__ */ dual(2, (self2, f) => mutate2(empty5(), (set15) => {
  forEach3(self2, (a) => {
    const b = f(a);
    if (!has3(set15, b)) {
      add(set15, b);
    }
  });
}));
var flatMap5 = /* @__PURE__ */ dual(2, (self2, f) => mutate2(empty5(), (set15) => {
  forEach3(self2, (a) => {
    for (const b of f(a)) {
      if (!has3(set15, b)) {
        add(set15, b);
      }
    }
  });
}));
var forEach3 = /* @__PURE__ */ dual(2, (self2, f) => forEach2(self2._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduce3(self2._keyMap, zero3, (z, _, a) => f(z, a)));
var filter5 = /* @__PURE__ */ dual(2, (self2, f) => {
  return mutate2(empty5(), (set15) => {
    const iterator = values2(self2);
    let next;
    while (!(next = iterator.next()).done) {
      const value6 = next.value;
      if (f(value6)) {
        add(set15, value6);
      }
    }
  });
});
var partition3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const iterator = values2(self2);
  let next;
  const right3 = beginMutation2(empty5());
  const left3 = beginMutation2(empty5());
  while (!(next = iterator.next()).done) {
    const value6 = next.value;
    if (predicate(value6)) {
      add(right3, value6);
    } else {
      add(left3, value6);
    }
  }
  return [endMutation2(left3), endMutation2(right3)];
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty6 = empty5;
var fromIterable6 = fromIterable5;
var make8 = make7;
var has4 = has3;
var some7 = some6;
var every6 = every5;
var isSubset2 = isSubset;
var values3 = values2;
var toValues = /* @__PURE__ */ __name((self2) => Array.from(values3(self2)), "toValues");
var size4 = size3;
var beginMutation3 = beginMutation2;
var endMutation3 = endMutation2;
var mutate3 = mutate2;
var add2 = add;
var remove5 = remove4;
var difference4 = difference3;
var intersection4 = intersection3;
var union5 = union4;
var toggle2 = toggle;
var map8 = map7;
var flatMap6 = flatMap5;
var forEach4 = forEach3;
var reduce5 = reduce4;
var filter6 = filter5;
var partition4 = partition3;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/cause.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty7 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = /* @__PURE__ */ __name((error3) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error3;
  return o;
}, "fail");
var die = /* @__PURE__ */ __name((defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
}, "die");
var interrupt = /* @__PURE__ */ __name((fiberId3) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId3;
  return o;
}, "interrupt");
var parallel = /* @__PURE__ */ __name((left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
}, "parallel");
var sequential = /* @__PURE__ */ __name((left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
}, "sequential");
var isCause = /* @__PURE__ */ __name((u) => hasProperty(u, CauseTypeId), "isCause");
var isEmptyType = /* @__PURE__ */ __name((self2) => self2._tag === OP_EMPTY, "isEmptyType");
var isFailType = /* @__PURE__ */ __name((self2) => self2._tag === OP_FAIL, "isFailType");
var isDieType = /* @__PURE__ */ __name((self2) => self2._tag === OP_DIE, "isDieType");
var isInterruptType = /* @__PURE__ */ __name((self2) => self2._tag === OP_INTERRUPT, "isInterruptType");
var isSequentialType = /* @__PURE__ */ __name((self2) => self2._tag === OP_SEQUENTIAL, "isSequentialType");
var isParallelType = /* @__PURE__ */ __name((self2) => self2._tag === OP_PARALLEL, "isParallelType");
var size5 = /* @__PURE__ */ __name((self2) => reduceWithContext(self2, void 0, SizeCauseReducer), "size");
var isEmpty3 = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self2, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some3(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some3(false);
      }
      default: {
        return none2();
      }
    }
  });
}, "isEmpty");
var isFailure = /* @__PURE__ */ __name((self2) => isSome2(failureOption(self2)), "isFailure");
var isDie = /* @__PURE__ */ __name((self2) => isSome2(dieOption(self2)), "isDie");
var isInterrupted = /* @__PURE__ */ __name((self2) => isSome2(interruptOption(self2)), "isInterrupted");
var isInterruptedOnly = /* @__PURE__ */ __name((self2) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self2), "isInterruptedOnly");
var failures = /* @__PURE__ */ __name((self2) => reverse2(reduce6(self2, empty3(), (list, cause3) => cause3._tag === OP_FAIL ? some3(pipe(list, prepend2(cause3.error))) : none2())), "failures");
var defects = /* @__PURE__ */ __name((self2) => reverse2(reduce6(self2, empty3(), (list, cause3) => cause3._tag === OP_DIE ? some3(pipe(list, prepend2(cause3.defect))) : none2())), "defects");
var interruptors = /* @__PURE__ */ __name((self2) => reduce6(self2, empty6(), (set15, cause3) => cause3._tag === OP_INTERRUPT ? some3(pipe(set15, add2(cause3.fiberId))) : none2()), "interruptors");
var failureOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_FAIL ? some3(cause3.error) : none2()), "failureOption");
var failureOrCause = /* @__PURE__ */ __name((self2) => {
  const option7 = failureOption(self2);
  switch (option7._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option7.value);
    }
  }
}, "failureOrCause");
var dieOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_DIE ? some3(cause3.defect) : none2()), "dieOption");
var flipCauseOption = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: some3(empty7),
  onFail: map2(fail),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: (fiberId3) => some3(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "flipCauseOption");
var interruptOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_INTERRUPT ? some3(cause3.fiberId) : none2()), "interruptOption");
var keepDefects = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefects");
var keepDefectsAndElectFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: none2(),
  onFail: (failure) => some3(die(failure)),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefectsAndElectFailures");
var linearize = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty6(),
  onFail: (error3) => make8(fail(error3)),
  onDie: (defect) => make8(die(defect)),
  onInterrupt: (fiberId3) => make8(interrupt(fiberId3)),
  onSequential: (leftSet, rightSet) => flatMap6(leftSet, (leftCause) => map8(rightSet, (rightCause) => sequential(leftCause, rightCause))),
  onParallel: (leftSet, rightSet) => flatMap6(leftSet, (leftCause) => map8(rightSet, (rightCause) => parallel(leftCause, rightCause)))
}), "linearize");
var stripFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty7,
  onFail: () => empty7,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "stripFailures");
var electFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty7,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "electFailures");
var stripSomeDefects = /* @__PURE__ */ dual(2, (self2, pf) => match4(self2, {
  onEmpty: some3(empty7),
  onFail: (error3) => some3(fail(error3)),
  onDie: (defect) => {
    const option7 = pf(defect);
    return isSome2(option7) ? none2() : some3(die(defect));
  },
  onInterrupt: (fiberId3) => some3(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}));
var as2 = /* @__PURE__ */ dual(2, (self2, error3) => map9(self2, () => error3));
var map9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (e) => fail(f(e))));
var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => match4(self2, {
  onEmpty: empty7,
  onFail: (error3) => f(error3),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId3) => interrupt(fiberId3),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten4 = /* @__PURE__ */ __name((self2) => flatMap7(self2, identity), "flatten");
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => isFunction2(f) ? flatMap7(self2, f) : flatMap7(self2, () => f));
var contains4 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (that._tag === OP_EMPTY || self2 === that) {
    return true;
  }
  return reduce6(self2, false, (accumulator, cause3) => {
    return some3(accumulator || causeEquals(cause3, that));
  });
});
var causeEquals = /* @__PURE__ */ __name((left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty6(), empty3()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty6(), empty3()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
}, "causeEquals");
var flattenCause = /* @__PURE__ */ __name((cause3) => {
  return flattenCauseLoop(of2(cause3), empty3());
}, "flattenCause");
var flattenCauseLoop = /* @__PURE__ */ __name((causes, flattened) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce([empty6(), empty3()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel6, union5(par2)), pipe(sequential6, appendAll2(seq2))];
    }));
    const updated = size4(parallel5) > 0 ? pipe(flattened, prepend2(parallel5)) : flattened;
    if (isEmpty(sequential5)) {
      return reverse2(updated);
    }
    causes = sequential5;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
}, "flattenCauseLoop");
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option7 = pf(item);
    switch (option7._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option7;
      }
    }
  }
  return none2();
});
var filter7 = /* @__PURE__ */ dual(2, (self2, predicate) => reduceWithContext(self2, void 0, FilterCauseReducer(predicate)));
var evaluateCause = /* @__PURE__ */ __name((self2) => {
  let cause3 = self2;
  const stack = [];
  let _parallel = empty6();
  let _sequential = empty3();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add2(_parallel, make4(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add2(_parallel, make4(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add2(_parallel, make4(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
}, "evaluateCause");
var SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left3, right3) => left3 + right3,
  parallelCase: (_, left3, right3) => left3 + right3
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var FilterCauseReducer = /* @__PURE__ */ __name((predicate) => ({
  emptyCase: () => empty7,
  failCase: (_, error3) => fail(error3),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId3) => interrupt(fiberId3),
  sequentialCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return sequential(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty7;
  },
  parallelCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return parallel(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty7;
  }
}), "FilterCauseReducer");
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error3) => onFail(error3),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId3) => onInterrupt3(fiberId3),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self2, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self2;
  const causes = [];
  while (cause3 !== void 0) {
    const option7 = pf(accumulator, cause3);
    accumulator = isSome2(option7) ? option7.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context11, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context11)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context11, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context11, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context11, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either9 = output.pop();
    switch (either9._tag) {
      case "Left": {
        switch (either9.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.sequentialCase(context11, left3, right3);
            accumulator.push(value6);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.parallelCase(context11, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either9.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = /* @__PURE__ */ __name((cause3, options4) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if (options4?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
}, "pretty");
var renderErrorCause = /* @__PURE__ */ __name((cause3, prefix3) => {
  const lines = cause3.stack.split("\n");
  let stack = `${prefix3}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix3}${lines[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix3}  `)}
${prefix3}}`;
  }
  return stack;
}, "renderErrorCause");
var PrettyError = class extends globalThis.Error {
  span = void 0;
  constructor(originalError2) {
    const originalErrorIsObject = typeof originalError2 === "object" && originalError2 !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError2), originalErrorIsObject && "cause" in originalError2 && typeof originalError2.cause !== "undefined" ? {
      cause: new PrettyError(originalError2.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError2 instanceof Error ? originalError2.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError2) {
        this.span = originalError2[spanSymbol];
      }
      Object.keys(originalError2).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError2[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError2 instanceof Error && originalError2.stack ? originalError2.stack : "", this.span);
  }
};
__name(PrettyError, "PrettyError");
var prettyErrorMessage = /* @__PURE__ */ __name((u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
}, "prettyErrorMessage");
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = /* @__PURE__ */ __name((message, stack, span4) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match21 = false;
          for (const [, location2] of locationMatchAll) {
            match21 = true;
            out.push(`    at ${current2.name} (${location2})`);
          }
          if (!match21) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined(current2.parent);
      i++;
    }
  }
  return out.join("\n");
}, "prettyErrorStack");
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = /* @__PURE__ */ __name((cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error3) => {
    return [new PrettyError(error3)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
}), "prettyErrors");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/console.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Context.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/context.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make9(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = /* @__PURE__ */ __name((key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag8 = Object.create(TagProto);
  Object.defineProperty(tag8, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag8.key = key;
  return tag8;
}, "makeGenericTag");
var Tag = /* @__PURE__ */ __name((id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
}, "Tag");
var Reference = /* @__PURE__ */ __name(() => (id3, options4) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  __name(ReferenceClass, "ReferenceClass");
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id3;
  ReferenceClass.defaultValue = options4.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
}, "Reference");
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId5]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = /* @__PURE__ */ __name((unsafeMap) => {
  const context11 = Object.create(ContextProto);
  context11.unsafeMap = unsafeMap;
  return context11;
}, "makeContext");
var serviceNotFoundError = /* @__PURE__ */ __name((tag8) => {
  const error3 = new Error(`Service not found${tag8.key ? `: ${String(tag8.key)}` : ""}`);
  if (tag8.stack) {
    const lines = tag8.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error3.message = error3.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error3.stack) {
    const lines = error3.stack.split("\n");
    lines.splice(1, 3);
    error3.stack = lines.join("\n");
  }
  return error3;
}, "serviceNotFoundError");
var isContext = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId5), "isContext");
var isTag = /* @__PURE__ */ __name((u) => hasProperty(u, TagTypeId), "isTag");
var isReference = /* @__PURE__ */ __name((u) => hasProperty(u, ReferenceTypeId), "isReference");
var _empty4 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty8 = /* @__PURE__ */ __name(() => _empty4, "empty");
var make9 = /* @__PURE__ */ __name((tag8, service3) => makeContext(/* @__PURE__ */ new Map([[tag8.key, service3]])), "make");
var add3 = /* @__PURE__ */ dual(3, (self2, tag8, service3) => {
  const map33 = new Map(self2.unsafeMap);
  map33.set(tag8.key, service3);
  return makeContext(map33);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = /* @__PURE__ */ __name((tag8) => {
  if (defaultValueCache.has(tag8.key)) {
    return defaultValueCache.get(tag8.key);
  }
  const value6 = tag8.defaultValue();
  defaultValueCache.set(tag8.key, value6);
  return value6;
}, "getDefaultValue");
var unsafeGetReference = /* @__PURE__ */ __name((self2, tag8) => {
  return self2.unsafeMap.has(tag8.key) ? self2.unsafeMap.get(tag8.key) : getDefaultValue(tag8);
}, "unsafeGetReference");
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, tag8) => {
  if (!self2.unsafeMap.has(tag8.key)) {
    if (ReferenceTypeId in tag8)
      return getDefaultValue(tag8);
    throw serviceNotFoundError(tag8);
  }
  return self2.unsafeMap.get(tag8.key);
});
var get5 = unsafeGet4;
var getOption = /* @__PURE__ */ dual(2, (self2, tag8) => {
  if (!self2.unsafeMap.has(tag8.key)) {
    return isReference(tag8) ? some2(getDefaultValue(tag8)) : none;
  }
  return some2(self2.unsafeMap.get(tag8.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map33 = new Map(self2.unsafeMap);
  for (const [tag8, s] of that.unsafeMap) {
    map33.set(tag8, s);
  }
  return makeContext(map33);
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var empty9 = empty8;
var make10 = make9;
var add4 = add3;
var get6 = get5;
var unsafeGet5 = unsafeGet4;
var getOption2 = getOption;
var merge3 = merge2;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp3,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide,
  equals: () => equals2,
  format: () => format2,
  formatIso: () => formatIso,
  fromIso: () => fromIso,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  isZero: () => isZero,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  match: () => match5,
  matchWith: () => matchWith,
  max: () => max2,
  micros: () => micros,
  millis: () => millis,
  min: () => min2,
  minutes: () => minutes,
  nanos: () => nanos,
  parts: () => parts,
  seconds: () => seconds,
  subtract: () => subtract,
  sum: () => sum,
  times: () => times,
  toDays: () => toDays,
  toHours: () => toHours,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toMinutes: () => toMinutes,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  toWeeks: () => toWeeks,
  unsafeDivide: () => unsafeDivide,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = /* @__PURE__ */ __name((input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match21 = DURATION_REGEX.exec(input);
    if (match21) {
      const [_, valueStr, unit] = match21;
      const value6 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value6);
        case "second":
        case "seconds":
          return seconds(value6);
        case "minute":
        case "minutes":
          return minutes(value6);
        case "hour":
        case "hours":
          return hours(value6);
        case "day":
        case "days":
          return days(value6);
        case "week":
        case "weeks":
          return weeks(value6);
      }
    }
  }
  throw new Error("Invalid DurationInput");
}, "decode");
var decodeUnknown = /* @__PURE__ */ liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId6]: TypeId6,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make11 = /* @__PURE__ */ __name((input) => {
  const duration3 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration3.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration3.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration3.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration3.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration3.value = zeroValue;
  } else {
    duration3.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration3;
}, "make");
var isDuration = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId6), "isDuration");
var isFinite = /* @__PURE__ */ __name((self2) => self2.value._tag !== "Infinity", "isFinite");
var isZero = /* @__PURE__ */ __name((self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
}, "isZero");
var zero = /* @__PURE__ */ make11(0);
var infinity = /* @__PURE__ */ make11(Infinity);
var nanos = /* @__PURE__ */ __name((nanos2) => make11(nanos2), "nanos");
var micros = /* @__PURE__ */ __name((micros2) => make11(micros2 * bigint1e3), "micros");
var millis = /* @__PURE__ */ __name((millis2) => make11(millis2), "millis");
var seconds = /* @__PURE__ */ __name((seconds2) => make11(seconds2 * 1e3), "seconds");
var minutes = /* @__PURE__ */ __name((minutes2) => make11(minutes2 * 6e4), "minutes");
var hours = /* @__PURE__ */ __name((hours2) => make11(hours2 * 36e5), "hours");
var days = /* @__PURE__ */ __name((days2) => make11(days2 * 864e5), "days");
var weeks = /* @__PURE__ */ __name((weeks2) => make11(weeks2 * 6048e5), "weeks");
var toMillis = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
}), "toMillis");
var toSeconds = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2 / 1e3,
  onNanos: (nanos2) => Number(nanos2) / 1e9
}), "toSeconds");
var toMinutes = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2 / 6e4,
  onNanos: (nanos2) => Number(nanos2) / 6e10
}), "toMinutes");
var toHours = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2 / 36e5,
  onNanos: (nanos2) => Number(nanos2) / 36e11
}), "toHours");
var toDays = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2 / 864e5,
  onNanos: (nanos2) => Number(nanos2) / 864e11
}), "toDays");
var toWeeks = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: (millis2) => millis2 / 6048e5,
  onNanos: (nanos2) => Number(nanos2) / 6048e11
}), "toWeeks");
var toNanos = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some3(_self.value.nanos);
    case "Millis":
      return some3(BigInt(Math.round(_self.value.millis * 1e6)));
  }
}, "toNanos");
var unsafeToNanos = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
}, "unsafeToNanos");
var toHrTime = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
}, "toHrTime");
var match5 = /* @__PURE__ */ dual(2, (self2, options4) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options4.onNanos(_self.value.nanos);
    case "Infinity":
      return options4.onMillis(Infinity);
    case "Millis":
      return options4.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options4) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options4.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options4.onNanos(selfNanos, thatNanos);
  }
  return options4.onMillis(_self.value.millis, _that.value.millis);
});
var Order = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0,
  onNanos: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0
}));
var between2 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput3(Order, decode));
var Equivalence = /* @__PURE__ */ __name((self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
}), "Equivalence");
var _min = /* @__PURE__ */ min(Order);
var min2 = /* @__PURE__ */ dual(2, (self2, that) => _min(decode(self2), decode(that)));
var _max = /* @__PURE__ */ max(Order);
var max2 = /* @__PURE__ */ dual(2, (self2, that) => _max(decode(self2), decode(that)));
var _clamp = /* @__PURE__ */ clamp(Order);
var clamp3 = /* @__PURE__ */ dual(2, (self2, options4) => _clamp(decode(self2), {
  minimum: decode(options4.minimum),
  maximum: decode(options4.maximum)
}));
var divide = /* @__PURE__ */ dual(2, (self2, by) => match5(self2, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some3(make11(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some3(make11(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide = /* @__PURE__ */ dual(2, (self2, by) => match5(self2, {
  onMillis: (millis2) => make11(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make11(nanos2 / BigInt(by));
  }
}));
var times = /* @__PURE__ */ dual(2, (self2, times2) => match5(self2, {
  onMillis: (millis2) => make11(millis2 * times2),
  onNanos: (nanos2) => make11(nanos2 * BigInt(times2))
}));
var subtract = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make11(self3 - that2),
  onNanos: (self3, that2) => make11(self3 - that2)
}));
var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make11(self3 + that2),
  onNanos: (self3, that2) => make11(self3 + that2)
}));
var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2,
  onNanos: (self3, that2) => self3 < that2
}));
var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 <= that2,
  onNanos: (self3, that2) => self3 <= that2
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
var parts = /* @__PURE__ */ __name((self2) => {
  const duration3 = decode(self2);
  if (duration3.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration3);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min5 = sec / bigint60;
  const hr = min5 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min5 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
}, "parts");
var format2 = /* @__PURE__ */ __name((self2) => {
  const duration3 = decode(self2);
  if (duration3.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration3)) {
    return "0";
  }
  const fragments = parts(duration3);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
}, "format");
var unsafeFormatIso = /* @__PURE__ */ __name((self2) => {
  const duration3 = decode(self2);
  if (!isFinite(duration3)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration3);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
}, "unsafeFormatIso");
var formatIso = /* @__PURE__ */ __name((self2) => {
  const duration3 = decode(self2);
  return isFinite(duration3) ? some3(unsafeFormatIso(duration3)) : none2();
}, "formatIso");
var fromIso = /* @__PURE__ */ __name((iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value6 = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some3(seconds(value6));
}, "fromIso");
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberId.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberId.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableRef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId7]: TypeId7,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = /* @__PURE__ */ __name((value6) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value6;
  return ref;
}, "make");
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get7 = /* @__PURE__ */ __name((self2) => self2.current, "get");
var set2 = /* @__PURE__ */ dual(2, (self2, value6) => {
  self2.current = value6;
  return self2;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string2(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
__name(None, "None");
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id3, startTimeMillis) {
    this.id = id3;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
__name(Runtime, "Runtime");
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
__name(Composite, "Composite");
var none3 = /* @__PURE__ */ new None();
var runtime = /* @__PURE__ */ __name((id3, startTimeMillis) => {
  return new Runtime(id3, startTimeMillis);
}, "runtime");
var composite = /* @__PURE__ */ __name((left3, right3) => {
  return new Composite(left3, right3);
}, "composite");
var isFiberId = /* @__PURE__ */ __name((self2) => hasProperty(self2, FiberIdTypeId), "isFiberId");
var isNone3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_NONE || pipe(toSet(self2), every6((id3) => isNone3(id3)));
}, "isNone");
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var combineAll = /* @__PURE__ */ __name((fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
}, "combineAll");
var getOrElse3 = /* @__PURE__ */ dual(2, (self2, that) => isNone3(self2) ? that : self2);
var ids = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty6();
    }
    case OP_RUNTIME: {
      return make8(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union5(ids(self2.right)));
    }
  }
}, "ids");
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
var make13 = /* @__PURE__ */ __name((id3, startTimeSeconds) => {
  return new Runtime(id3, startTimeSeconds);
}, "make");
var threadName = /* @__PURE__ */ __name((self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
}, "threadName");
var toSet = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty6();
    }
    case OP_RUNTIME: {
      return make8(self2);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self2.left), union5(toSet(self2.right)));
    }
  }
}, "toSet");
var unsafeMake2 = /* @__PURE__ */ __name(() => {
  const id3 = get7(_fiberCounter);
  pipe(_fiberCounter, set2(id3 + 1));
  return new Runtime(id3, Date.now());
}, "unsafeMake");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine3 = combine2;
var combineAll2 = combineAll;
var getOrElse4 = getOrElse3;
var ids2 = ids;
var make14 = make13;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation4,
  compact: () => compact3,
  countBy: () => countBy2,
  empty: () => empty10,
  endMutation: () => endMutation4,
  entries: () => entries2,
  every: () => every7,
  filter: () => filter8,
  filterMap: () => filterMap5,
  findFirst: () => findFirst5,
  flatMap: () => flatMap8,
  forEach: () => forEach5,
  fromIterable: () => fromIterable7,
  get: () => get8,
  getHash: () => getHash2,
  has: () => has5,
  hasBy: () => hasBy2,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty4,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys3,
  make: () => make15,
  map: () => map10,
  modify: () => modify4,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate4,
  reduce: () => reduce7,
  remove: () => remove6,
  removeMany: () => removeMany2,
  set: () => set3,
  size: () => size6,
  some: () => some8,
  toEntries: () => toEntries,
  toValues: () => toValues2,
  union: () => union6,
  unsafeGet: () => unsafeGet6,
  values: () => values4
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/keySet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function keySet(self2) {
  return makeImpl2(self2);
}
__name(keySet, "keySet");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty10 = empty4;
var make15 = make6;
var fromIterable7 = fromIterable4;
var isEmpty4 = isEmpty2;
var get8 = get4;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet3;
var has5 = has2;
var hasHash2 = hasHash;
var hasBy2 = hasBy;
var set3 = set;
var keys3 = keys2;
var keySet2 = keySet;
var values4 = values;
var toValues2 = /* @__PURE__ */ __name((self2) => Array.from(values4(self2)), "toValues");
var entries2 = entries;
var toEntries = /* @__PURE__ */ __name((self2) => Array.from(entries2(self2)), "toEntries");
var size6 = size2;
var countBy2 = countBy;
var beginMutation4 = beginMutation;
var endMutation4 = endMutation;
var mutate4 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify4 = modify3;
var union6 = union3;
var remove6 = remove3;
var removeMany2 = removeMany;
var map10 = map6;
var flatMap8 = flatMap4;
var forEach5 = forEach2;
var reduce7 = reduce3;
var filter8 = filter4;
var compact3 = compact2;
var filterMap5 = filterMap4;
var findFirst5 = findFirst4;
var some8 = some5;
var every7 = every4;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/List.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = /* @__PURE__ */ __name((self2) => fromIterable2(self2), "toArray");
var getEquivalence6 = /* @__PURE__ */ __name((isEquivalent) => mapInput(getEquivalence4(isEquivalent), toArray3), "getEquivalence");
var _equivalence4 = /* @__PURE__ */ getEquivalence6(equals);
var ConsProto = {
  [TypeId8]: TypeId8,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done12 = false;
    let self2 = this;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done12 = true;
          return this.return();
        }
        const value6 = self2.head;
        self2 = self2.tail;
        return {
          done: done12,
          value: value6
        };
      },
      return(value6) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = /* @__PURE__ */ __name((head10, tail2) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head10;
  cons2.tail = tail2;
  return cons2;
}, "makeCons");
var NilHash = /* @__PURE__ */ string2("Nil");
var NilProto = {
  [TypeId8]: TypeId8,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId8), "isList");
var isNil = /* @__PURE__ */ __name((self2) => self2._tag === "Nil", "isNil");
var isCons = /* @__PURE__ */ __name((self2) => self2._tag === "Cons", "isCons");
var nil = /* @__PURE__ */ __name(() => _Nil, "nil");
var cons = /* @__PURE__ */ __name((head10, tail2) => makeCons(head10, tail2), "cons");
var empty11 = nil;
var of3 = /* @__PURE__ */ __name((value6) => makeCons(value6, _Nil), "of");
var fromIterable8 = /* @__PURE__ */ __name((prefix3) => {
  const iterator = prefix3[Symbol.iterator]();
  let next;
  if ((next = iterator.next()) && !next.done) {
    const result = makeCons(next.value, _Nil);
    let curr = result;
    while ((next = iterator.next()) && !next.done) {
      const temp = makeCons(next.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
}, "fromIterable");
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll2(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element2) => cons(element2, self2));
var prependAll2 = /* @__PURE__ */ dual(2, (self2, prefix3) => {
  if (isNil(self2)) {
    return prefix3;
  } else if (isNil(prefix3)) {
    return self2;
  } else {
    const result = makeCons(prefix3.head, self2);
    let curr = result;
    let that = prefix3.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  let acc = zero3;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = /* @__PURE__ */ __name((self2) => {
  let result = empty11();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
}, "reverse");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtimeFlags.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/data.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  __name(Structural2, "Structural");
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct2 = /* @__PURE__ */ __name((as14) => Object.assign(Object.create(StructuralPrototype), as14), "struct");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/contextPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
__name(variance2, "variance");
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty12 = /* @__PURE__ */ __name(() => _empty5, "empty");
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = /* @__PURE__ */ __name((key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
}, "makeAddService");
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = /* @__PURE__ */ __name((key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
}, "makeRemoveService");
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = /* @__PURE__ */ __name((key, update6) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update6;
  return o;
}, "makeUpdateService");
var diff = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch12 = empty12();
  for (const [tag8, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag8)) {
      const old = missingServices.get(tag8);
      missingServices.delete(tag8);
      if (!equals(old, newService)) {
        patch12 = combine4(makeUpdateService(tag8, () => newService))(patch12);
      }
    } else {
      missingServices.delete(tag8);
      patch12 = combine4(makeAddService(tag8, newService))(patch12);
    }
  }
  for (const [tag8] of missingServices.entries()) {
    patch12 = combine4(makeRemoveService(tag8))(patch12);
  }
  return patch12;
}, "diff");
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context11) => {
  if (self2._tag === "Empty") {
    return context11;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context11.unsafeMap);
  while (isNonEmpty(patches)) {
    const head10 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head10._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AddService": {
        updatedContext.set(head10.key, head10.service);
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail2, head10.second), head10.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head10.key);
        patches = tail2;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head10.key, head10.update(updatedContext.get(head10.key)));
        wasServiceUpdated = true;
        patches = tail2;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map33 = /* @__PURE__ */ new Map();
  for (const [tag8] of context11.unsafeMap) {
    if (updatedContext.has(tag8)) {
      map33.set(tag8, updatedContext.get(tag8));
      updatedContext.delete(tag8);
    }
  }
  for (const [tag8, s] of updatedContext) {
    map33.set(tag8, s);
  }
  return makeContext(map33);
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance3(a) {
  return a;
}
__name(variance3, "variance");
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty13 = /* @__PURE__ */ __name(() => _empty6, "empty");
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = /* @__PURE__ */ __name((value6) => {
  const o = Object.create(AddProto);
  o.value = value6;
  return o;
}, "makeAdd");
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = /* @__PURE__ */ __name((value6) => {
  const o = Object.create(RemoveProto);
  o.value = value6;
  return o;
}, "makeRemove");
var diff2 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const [removed, patch12] = reduce5([oldValue, empty13()], ([set15, patch13], value6) => {
    if (has4(value6)(set15)) {
      return [remove5(value6)(set15), patch13];
    }
    return [set15, combine5(makeAdd(value6))(patch13)];
  })(newValue);
  return reduce5(patch12, (patch13, value6) => combine5(makeRemove(value6))(patch13))(removed);
}, "diff");
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set15 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty(patches)) {
    const head10 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head10._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(head10.first)(prepend2(head10.second)(tail2));
        break;
      }
      case "Add": {
        set15 = add2(head10.value)(set15);
        patches = tail2;
        break;
      }
      case "Remove": {
        set15 = remove5(head10.value)(set15);
        patches = tail2;
      }
    }
  }
  return set15;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance4(a) {
  return a;
}
__name(variance4, "variance");
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance4,
    _Patch: variance4
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty14 = /* @__PURE__ */ __name(() => _empty7, "empty");
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = /* @__PURE__ */ __name((values6) => {
  const o = Object.create(AppendProto);
  o.values = values6;
  return o;
}, "makeAppend");
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = /* @__PURE__ */ __name((from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
}, "makeSlice");
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = /* @__PURE__ */ __name((index2, patch12) => {
  const o = Object.create(UpdateProto);
  o.index = index2;
  o.patch = patch12;
  return o;
}, "makeUpdate");
var diff3 = /* @__PURE__ */ __name((options4) => {
  let i = 0;
  let patch12 = empty14();
  while (i < options4.oldValue.length && i < options4.newValue.length) {
    const oldElement = options4.oldValue[i];
    const newElement = options4.newValue[i];
    const valuePatch = options4.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options4.differ.empty)) {
      patch12 = combine6(patch12, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options4.oldValue.length) {
    patch12 = combine6(patch12, makeSlice(0, i));
  }
  if (i < options4.newValue.length) {
    patch12 = combine6(patch12, makeAppend(drop(i)(options4.newValue)));
  }
  return patch12;
}, "diff");
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ3) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head10 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head10._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        tail2.unshift(head10.first, head10.second);
        patches = tail2;
        break;
      }
      case "Append": {
        for (const value6 of head10.values) {
          readonlyArray2.push(value6);
        }
        patches = tail2;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head10.from, head10.until);
        patches = tail2;
        break;
      }
      case "Update": {
        readonlyArray2[head10.index] = differ3.patch(head10.patch, readonlyArray2[head10.index]);
        patches = tail2;
        break;
      }
    }
  }
  return readonlyArray2;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make16 = /* @__PURE__ */ __name((params2) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params2.empty;
  differ3.diff = params2.diff;
  differ3.combine = params2.combine;
  differ3.patch = params2.patch;
  return differ3;
}, "make");
var environment = /* @__PURE__ */ __name(() => make16({
  empty: empty12(),
  combine: (first2, second) => combine4(second)(first2),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch12, oldValue) => patch(oldValue)(patch12)
}), "environment");
var hashSet = /* @__PURE__ */ __name(() => make16({
  empty: empty13(),
  combine: (first2, second) => combine5(second)(first2),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch12, oldValue) => patch2(oldValue)(patch12)
}), "hashSet");
var readonlyArray = /* @__PURE__ */ __name((differ3) => make16({
  empty: empty14(),
  combine: (first2, second) => combine6(first2, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch12, oldValue) => patch3(patch12, oldValue, differ3)
}), "readonlyArray");
var update = /* @__PURE__ */ __name(() => updateWith((_, a) => a), "update");
var updateWith = /* @__PURE__ */ __name((f) => make16({
  empty: identity,
  combine: (first2, second) => {
    if (first2 === identity) {
      return second;
    }
    if (second === identity) {
      return first2;
    }
    return (a) => second(first2(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch12, oldValue) => f(oldValue, patch12(oldValue))
}), "updateWith");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = /* @__PURE__ */ __name((patch12) => patch12 & BIT_MASK, "active");
var enabled = /* @__PURE__ */ __name((patch12) => patch12 >> BIT_SHIFT & BIT_MASK, "enabled");
var make17 = /* @__PURE__ */ __name((active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT), "make");
var empty15 = /* @__PURE__ */ make17(0, 0);
var enable = /* @__PURE__ */ __name((flag) => make17(flag, flag), "enable");
var disable = /* @__PURE__ */ __name((flag) => make17(flag, 0), "disable");
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make17(active(self2) & ~flag, enabled(self2)));
var andThen3 = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = /* @__PURE__ */ __name((n) => ~n >>> 0 & BIT_MASK, "invert");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = /* @__PURE__ */ __name((self2) => isEnabled(self2, CooperativeYielding), "cooperativeYielding");
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = /* @__PURE__ */ __name((self2) => interruption(self2) && !windDown(self2), "interruptible");
var interruption = /* @__PURE__ */ __name((self2) => isEnabled(self2, Interruption), "interruption");
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make18 = /* @__PURE__ */ __name((...flags) => flags.reduce((a, b) => a | b, 0), "make");
var none5 = /* @__PURE__ */ make18(None2);
var runtimeMetrics = /* @__PURE__ */ __name((self2) => isEnabled(self2, RuntimeMetrics), "runtimeMetrics");
var windDown = /* @__PURE__ */ __name((self2) => isEnabled(self2, WindDown), "windDown");
var diff4 = /* @__PURE__ */ dual(2, (self2, that) => make17(self2 ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self2, patch12) => self2 & (invert(active(patch12)) | enabled(patch12)) | active(patch12) & enabled(patch12));
var differ = /* @__PURE__ */ make16({
  empty: empty15,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first2, second) => andThen3(second)(first2),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty16 = empty15;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/blockedRequests.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var empty17 = {
  _tag: "Empty"
};
var par = /* @__PURE__ */ __name((self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
}), "par");
var seq = /* @__PURE__ */ __name((self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
}), "seq");
var single = /* @__PURE__ */ __name((dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
}), "single");
var flatten5 = /* @__PURE__ */ __name((self2) => {
  let current2 = of3(self2);
  let updated = empty11();
  while (1) {
    const [parallel5, sequential5] = reduce8(current2, [parallelCollectionEmpty(), empty11()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse3(updated);
    }
    current2 = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "flatten");
var step = /* @__PURE__ */ __name((requests) => {
  let current2 = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty11();
  let sequential5 = empty11();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current2);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "step");
var merge4 = /* @__PURE__ */ __name((sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
}, "merge");
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request2, result, listeners, ownerId, state) {
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
__name(EntryImpl, "EntryImpl");
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var makeEntry = /* @__PURE__ */ __name((options4) => new EntryImpl(options4.request, options4.result, options4.listeners, options4.ownerId, options4.state), "makeEntry");
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map33) {
    this.map = map33;
  }
};
__name(ParallelImpl, "ParallelImpl");
var parallelCollectionEmpty = /* @__PURE__ */ __name(() => new ParallelImpl(empty10()), "parallelCollectionEmpty");
var parallelCollectionAdd = /* @__PURE__ */ __name((self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest)))), "parallelCollectionAdd");
var parallelCollectionCombine = /* @__PURE__ */ __name((self2, that) => new ParallelImpl(reduce7(self2.map, that.map, (map33, value6, key) => set3(map33, key, match2(get8(map33, key), {
  onNone: () => value6,
  onSome: (other) => appendAll2(value6, other)
})))), "parallelCollectionCombine");
var parallelCollectionIsEmpty = /* @__PURE__ */ __name((self2) => isEmpty4(self2.map), "parallelCollectionIsEmpty");
var parallelCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys3(self2.map)), "parallelCollectionKeys");
var parallelCollectionToSequentialCollection = /* @__PURE__ */ __name((self2) => sequentialCollectionMake(map10(self2.map, (x) => of2(x))), "parallelCollectionToSequentialCollection");
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map33) {
    this.map = map33;
  }
};
__name(SequentialImpl, "SequentialImpl");
var sequentialCollectionMake = /* @__PURE__ */ __name((map33) => new SequentialImpl(map33), "sequentialCollectionMake");
var sequentialCollectionCombine = /* @__PURE__ */ __name((self2, that) => new SequentialImpl(reduce7(that.map, self2.map, (map33, value6, key) => set3(map33, key, match2(get8(map33, key), {
  onNone: () => empty3(),
  onSome: (a) => appendAll2(a, value6)
})))), "sequentialCollectionCombine");
var sequentialCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys3(self2.map)), "sequentialCollectionKeys");
var sequentialCollectionToChunk = /* @__PURE__ */ __name((self2) => Array.from(self2.map), "sequentialCollectionToChunk");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/deferred.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/deferred.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = /* @__PURE__ */ __name((joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
}, "pending");
var done = /* @__PURE__ */ __name((effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
}, "done");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/singleShotGen.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SingleShotGen2 = class {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
};
__name(SingleShotGen2, "SingleShotGen");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core.js
var blocked = /* @__PURE__ */ __name((blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
}, "blocked");
var runRequestBlock = /* @__PURE__ */ __name((blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
}, "runRequestBlock");
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch12, op) {
    this.patch = patch12;
    this.op = op;
  }
};
__name(RevertFlags, "RevertFlags");
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
__name(EffectPrimitive, "EffectPrimitive");
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
__name(EffectPrimitiveFailure, "EffectPrimitiveFailure");
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
__name(EffectPrimitiveSuccess, "EffectPrimitiveSuccess");
var isEffect = /* @__PURE__ */ __name((u) => hasProperty(u, EffectTypeId2), "isEffect");
var withFiberRuntime = /* @__PURE__ */ __name((withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
}, "withFiberRuntime");
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use3, release) => uninterruptibleMask((restore) => flatMap9(acquire, (a) => flatMap9(exit(suspend(() => restore(use3(a)))), (exit4) => {
  return suspend(() => release(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as3 = /* @__PURE__ */ dual(2, (self2, value6) => flatMap9(self2, () => succeed(value6)));
var asVoid2 = /* @__PURE__ */ __name((self2) => as3(self2, void 0), "asVoid");
var custom = /* @__PURE__ */ __name(function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
}, "custom");
var unsafeAsync = /* @__PURE__ */ __name((register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_2);
}, "unsafeAsync");
var asyncInterrupt = /* @__PURE__ */ __name((register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn)), "asyncInterrupt");
var async_ = /* @__PURE__ */ __name((resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    __name(proxyResume, "proxyResume");
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_2;
    }) : effect4;
  });
}, "async_");
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause3) => {
  const either9 = failureOrCause(cause3);
  switch (either9._tag) {
    case "Left":
      return predicate(either9.left) ? f(either9.left) : failCause(cause3);
    case "Right":
      return failCause(either9.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const either9 = failureOrCause(cause3);
  switch (either9._tag) {
    case "Left":
      return pipe(pf(either9.left), getOrElse(() => failCause(cause3)));
    case "Right":
      return failCause(either9.right);
  }
}));
var checkInterruptible = /* @__PURE__ */ __name((f) => withFiberRuntime((_, status3) => f(interruption(status3.runtimeFlags))), "checkInterruptible");
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var originalInstance = /* @__PURE__ */ __name((obj) => {
  if (hasProperty(obj, originalSymbol)) {
    return obj[originalSymbol];
  }
  return obj;
}, "originalInstance");
var capture = /* @__PURE__ */ __name((obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target2, p) {
        return p === spanSymbol || p === originalSymbol || p in target2;
      },
      get(target2, p) {
        if (p === spanSymbol) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target2[p];
      }
    });
  }
  return obj;
}, "capture");
var die2 = /* @__PURE__ */ __name((defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect)), "die");
var dieMessage = /* @__PURE__ */ __name((message) => failCauseSync(() => die(new RuntimeException(message))), "dieMessage");
var dieSync = /* @__PURE__ */ __name((evaluate3) => flatMap9(sync(evaluate3), die2), "dieSync");
var either2 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
}), "either");
var exit = /* @__PURE__ */ __name((self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
}), "exit");
var fail2 = /* @__PURE__ */ __name((error3) => isObject(error3) && !(spanSymbol in error3) ? withFiberRuntime((fiber) => failCause(fail(capture(error3, currentSpanFromFiber(fiber))))) : failCause(fail(error3)), "fail");
var failSync = /* @__PURE__ */ __name((evaluate3) => flatMap9(sync(evaluate3), fail2), "failSync");
var failCause = /* @__PURE__ */ __name((cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
}, "failCause");
var failCauseSync = /* @__PURE__ */ __name((evaluate3) => flatMap9(sync(evaluate3), failCause), "failCauseSync");
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => f(state.id())), "fiberIdWith");
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var andThen4 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self2;
  return effect4;
}, "step");
var flatten6 = /* @__PURE__ */ __name((self2) => flatMap9(self2, identity), "flatten");
var flip = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
}), "flip");
var matchCause = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect(self2, {
  onFailure: (cause3) => succeed(options4.onFailure(cause3)),
  onSuccess: (a) => succeed(options4.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options4) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = options4.onFailure;
  effect4.effect_instruction_i2 = options4.onSuccess;
  return effect4;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures3 = failures(cause3);
    if (failures3.length > 0) {
      return options4.onFailure(unsafeHead2(failures3));
    }
    return failCause(cause3);
  },
  onSuccess: options4.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable2(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as3(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable2(self2);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self2, options4) => isEffect(self2) ? flatMap9(self2, (b) => b ? options4.onTrue() : options4.onFalse()) : self2 ? options4.onTrue() : options4.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap9(fiberId, (fiberId3) => interruptWith(fiberId3));
var interruptWith = /* @__PURE__ */ __name((fiberId3) => failCause(interrupt(fiberId3)), "interruptWith");
var interruptible2 = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
}, "interruptible");
var interruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
}), "interruptibleMask");
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap9(exit(restore(self2)), (exit4) => deferredDone(deferred, exit4))));
var map11 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self2, options4) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options4.onFailure(e)),
  onSuccess: (a) => sync(() => options4.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either9 = failureOrCause(cause3);
    switch (either9._tag) {
      case "Left": {
        return failSync(() => f(either9.left));
      }
      case "Right": {
        return failCause(either9.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit4) => exitIsSuccess(exit4) ? void_2 : cleanup(exit4.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_2,
  onSuccess: () => void_2
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = /* @__PURE__ */ __name((self2) => orDieWith(self2, identity), "orDie");
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap4 = partitionMap2;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = /* @__PURE__ */ __name((value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
}, "succeed");
var suspend = /* @__PURE__ */ __name((evaluate3) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate3;
  return effect4;
}, "suspend");
var sync = /* @__PURE__ */ __name((thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
}, "sync");
var tap2 = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self2, f) => flatMap9(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as3(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some3(scope5)));
}), "transplant");
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
}, "uninterruptible");
var uninterruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
}), "uninterruptibleMask");
var void_2 = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = /* @__PURE__ */ __name((patch12) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch12;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
}, "updateRuntimeFlags");
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap9(condition, (b) => {
  if (b) {
    return pipe(self2, map11(some3));
  }
  return succeed(none2());
}));
var whileLoop = /* @__PURE__ */ __name((options4) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options4.while;
  effect4.effect_instruction_i1 = options4.body;
  effect4.effect_instruction_i2 = options4.step;
  return effect4;
}, "whileLoop");
var fromIterator = /* @__PURE__ */ __name((iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
}), "fromIterator");
var gen2 = /* @__PURE__ */ __name(function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
}, "gen");
var fnUntraced = /* @__PURE__ */ __name((body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
}), "fnUntraced");
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update6) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update6;
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = /* @__PURE__ */ __name((options4) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options4?.priority !== "undefined" ? withSchedulingPriority(effect4, options4.priority) : effect4;
}, "yieldNow");
var zip3 = /* @__PURE__ */ dual(2, (self2, that) => flatMap9(self2, (a) => map11(that, (b) => [a, b])));
var zipLeft2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap9(self2, (a) => as3(that, a)));
var zipRight2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap9(self2, () => that));
var zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap9(self2, (a) => map11(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = /* @__PURE__ */ __name((self2) => flatMap9(fiberId, (fiberId3) => pipe(self2, interruptAsFiber(fiberId3))), "interruptFiber");
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId3) => flatMap9(self2.interruptAsFork(fiberId3), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = /* @__PURE__ */ __name((self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2))), "fiberRefGet");
var fiberRefGetAndSet = /* @__PURE__ */ dual(2, (self2, value6) => fiberRefModify(self2, (v) => [v, value6]));
var fiberRefGetAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => [v, f(v)]));
var fiberRefGetAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => [v, getOrElse(pf(v), () => v)]));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value6) => fiberRefModify(self2, () => [void 0, value6]));
var fiberRefDelete = /* @__PURE__ */ __name((self2) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self2);
  return void_2;
}), "fiberRefDelete");
var fiberRefReset = /* @__PURE__ */ __name((self2) => fiberRefSet(self2, self2.initial), "fiberRefReset");
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self2));
  state.setFiberRef(self2, a);
  return succeed(b);
}));
var fiberRefModifySome = /* @__PURE__ */ __name((self2, def, f) => fiberRefModify(self2, (v) => getOrElse(f(v), () => [def, v])), "fiberRefModifySome");
var fiberRefUpdate = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => [void 0, f(v)]));
var fiberRefUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => [void 0, getOrElse(pf(v), () => v)]));
var fiberRefUpdateAndGet = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => {
  const result = f(v);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => {
  const result = getOrElse(pf(v), () => v);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var RequestResolverImpl = class {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target2) {
    this.runAll = runAll;
    this.target = target2;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new RequestResolverImpl(this.runAll, fromIterable3(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(RequestResolverImpl, "RequestResolverImpl");
var isRequestResolver = /* @__PURE__ */ __name((u) => hasProperty(u, RequestResolverTypeId), "isRequestResolver");
var fiberRefLocally = /* @__PURE__ */ dual(3, (use3, self2, value6) => acquireUseRelease(zipLeft2(fiberRefGet(self2), fiberRefSet(self2, value6)), () => use3, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use3, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use3, self2, f(a))));
var fiberRefUnsafeMake = /* @__PURE__ */ __name((initial, options4) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options4?.fork ?? identity,
  join: options4?.join
}), "fiberRefUnsafeMake");
var fiberRefUnsafeMakeHashSet = /* @__PURE__ */ __name((initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeHashSet");
var fiberRefUnsafeMakeReadonlyArray = /* @__PURE__ */ __name((initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeReadonlyArray");
var fiberRefUnsafeMakeContext = /* @__PURE__ */ __name((initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeContext");
var fiberRefUnsafeMakePatch = /* @__PURE__ */ __name((initial, options4) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options4.differ.diff(oldValue, newValue),
    combine: (first2, second) => options4.differ.combine(first2, second),
    patch: (patch12) => (oldValue) => options4.differ.patch(patch12, oldValue),
    fork: options4.fork,
    join: options4.join ?? ((_, n) => n)
  };
  return _fiberRef;
}, "fiberRefUnsafeMakePatch");
var fiberRefUnsafeMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
}), "fiberRefUnsafeMakeRuntimeFlags");
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty9()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelWarning)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty7, {
  fork: () => empty7,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty10()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty3()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(() => asVoid2(finalizer3)), "scopeAddFinalizer");
var scopeAddFinalizerExit = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(finalizer3), "scopeAddFinalizerExit");
var scopeClose = /* @__PURE__ */ __name((self2, exit4) => self2.close(exit4), "scopeClose");
var scopeFork = /* @__PURE__ */ __name((self2, strategy) => self2.fork(strategy), "scopeFork");
var causeSquash = /* @__PURE__ */ __name((self2) => {
  return causeSquashWith(identity)(self2);
}, "causeSquash");
var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const option7 = pipe(self2, failureOption, map2(f));
  switch (option7._tag) {
    case "None": {
      return pipe(defects(self2), head2, match2({
        onNone: () => {
          const interrupts = fromIterable2(interruptors(self2)).flatMap((fiberId3) => fromIterable2(ids2(fiberId3)).map((id3) => `#${id3}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option7.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError3 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  __name(YieldableError3, "YieldableError");
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype);
  return YieldableError3;
}();
var makeException = /* @__PURE__ */ __name((proto14, tag8) => {
  class Base3 extends YieldableError {
    _tag = tag8;
  }
  __name(Base3, "Base");
  Object.assign(Base3.prototype, proto14);
  Base3.prototype.name = tag8;
  return Base3;
}, "makeException");
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = /* @__PURE__ */ __name((u) => hasProperty(u, RuntimeExceptionTypeId), "isRuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = /* @__PURE__ */ __name((u) => hasProperty(u, InterruptedExceptionTypeId), "isInterruptedException");
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var isIllegalArgumentException = /* @__PURE__ */ __name((u) => hasProperty(u, IllegalArgumentExceptionTypeId), "isIllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = /* @__PURE__ */ __name((u) => hasProperty(u, NoSuchElementExceptionTypeId), "isNoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var isExceededCapacityException = /* @__PURE__ */ __name((u) => hasProperty(u, ExceededCapacityExceptionTypeId), "isExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = /* @__PURE__ */ __name((duration3) => new TimeoutException(`Operation timed out after '${format2(duration3)}'`), "timeoutExceptionFromDuration");
var isTimeoutException = /* @__PURE__ */ __name((u) => hasProperty(u, TimeoutExceptionTypeId), "isTimeoutException");
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {
  class UnknownException3 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      this.error = cause3;
    }
  }
  __name(UnknownException3, "UnknownException");
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
}();
var isUnknownException = /* @__PURE__ */ __name((u) => hasProperty(u, UnknownExceptionTypeId), "isUnknownException");
var exitIsExit = /* @__PURE__ */ __name((u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure"), "exitIsExit");
var exitIsFailure = /* @__PURE__ */ __name((self2) => self2._tag === "Failure", "exitIsFailure");
var exitIsSuccess = /* @__PURE__ */ __name((self2) => self2._tag === "Success", "exitIsSuccess");
var exitIsInterrupted = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return isInterrupted(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
}, "exitIsInterrupted");
var exitAs = /* @__PURE__ */ dual(2, (self2, value6) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value6);
    }
  }
});
var exitAsVoid = /* @__PURE__ */ __name((self2) => exitAs(self2, void 0), "exitAsVoid");
var exitCauseOption = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return some3(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return none2();
  }
}, "exitCauseOption");
var exitCollectAll = /* @__PURE__ */ __name((exits, options4) => exitCollectAllInternal(exits, options4?.parallel ? parallel : sequential), "exitCollectAll");
var exitDie = /* @__PURE__ */ __name((defect) => exitFailCause(die(defect)), "exitDie");
var exitExists = /* @__PURE__ */ dual(2, (self2, refinement) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self2.effect_instruction_i0);
  }
});
var exitFail = /* @__PURE__ */ __name((error3) => exitFailCause(fail(error3)), "exitFail");
var exitFailCause = /* @__PURE__ */ __name((cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
}, "exitFailCause");
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self2.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = /* @__PURE__ */ __name((self2) => pipe(self2, exitFlatMap(identity)), "exitFlatten");
var exitForEachEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self2.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f(self2.effect_instruction_i0));
    }
  }
});
var exitFromEither = /* @__PURE__ */ __name((either9) => {
  switch (either9._tag) {
    case "Left":
      return exitFail(either9.left);
    case "Right":
      return exitSucceed(either9.right);
  }
}, "exitFromEither");
var exitFromOption = /* @__PURE__ */ __name((option7) => {
  switch (option7._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option7.value);
  }
}, "exitFromOption");
var exitGetOrElse = /* @__PURE__ */ dual(2, (self2, orElse16) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return orElse16(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return self2.effect_instruction_i0;
  }
});
var exitInterrupt = /* @__PURE__ */ __name((fiberId3) => exitFailCause(interrupt(fiberId3)), "exitInterrupt");
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map9(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self2.effect_instruction_i0));
  }
});
var exitMapError = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map9(f)));
    case OP_SUCCESS:
      return exitSucceed(self2.effect_instruction_i0);
  }
});
var exitMapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(f(self2.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self2.effect_instruction_i0);
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = /* @__PURE__ */ __name((value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
}, "exitSucceed");
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipLeft = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, _) => a,
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipPar = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
var exitZipParLeft = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, _) => a,
  onFailure: parallel
}));
var exitZipParRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (_, a2) => a2,
  onFailure: parallel
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = /* @__PURE__ */ __name((exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value6) => pipe(list2, prepend2(value6)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some3);
}, "exitCollectAllInternal");
var deferredUnsafeMake = /* @__PURE__ */ __name((fiberId3) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make12(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId3
  };
  return _deferred;
}, "deferredUnsafeMake");
var deferredMake = /* @__PURE__ */ __name(() => flatMap9(fiberId, (id3) => deferredMakeAs(id3)), "deferredMake");
var deferredMakeAs = /* @__PURE__ */ __name((fiberId3) => sync(() => deferredUnsafeMake(fiberId3)), "deferredMakeAs");
var deferredAwait = /* @__PURE__ */ __name((self2) => asyncInterrupt((resume2) => {
  const state = get7(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self2, resume2);
    }
  }
}, self2.blockingOn), "deferredAwait");
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect4) => intoDeferred(effect4, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect4) => sync(() => {
  const state = get7(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self2.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit4) => deferredCompleteWith(self2, exit4));
var deferredFail = /* @__PURE__ */ dual(2, (self2, error3) => deferredCompleteWith(self2, fail2(error3)));
var deferredFailSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, failSync(evaluate3)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause3) => deferredCompleteWith(self2, failCause(cause3)));
var deferredFailCauseSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, failCauseSync(evaluate3)));
var deferredDie = /* @__PURE__ */ dual(2, (self2, defect) => deferredCompleteWith(self2, die2(defect)));
var deferredDieSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, dieSync(evaluate3)));
var deferredInterrupt = /* @__PURE__ */ __name((self2) => flatMap9(fiberId, (fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3))), "deferredInterrupt");
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3)));
var deferredIsDone = /* @__PURE__ */ __name((self2) => sync(() => get7(self2.state)._tag === OP_STATE_DONE), "deferredIsDone");
var deferredPoll = /* @__PURE__ */ __name((self2) => sync(() => {
  const state = get7(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some3(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
}), "deferredPoll");
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value6) => deferredCompleteWith(self2, succeed(value6)));
var deferredSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, sync(evaluate3)));
var deferredUnsafeDone = /* @__PURE__ */ __name((self2, effect4) => {
  const state = get7(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self2.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
}, "deferredUnsafeDone");
var deferredInterruptJoiner = /* @__PURE__ */ __name((self2, joiner) => sync(() => {
  const state = get7(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index2 = state.joiners.indexOf(joiner);
    if (index2 >= 0) {
      state.joiners.splice(index2, 1);
    }
  }
}), "deferredInterruptJoiner");
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = /* @__PURE__ */ __name(() => constContext, "context");
var contextWithEffect = /* @__PURE__ */ __name((f) => flatMap9(context(), f), "contextWithEffect");
var provideContext = /* @__PURE__ */ dual(2, (self2, context11) => fiberRefLocally(currentContext, context11)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context11) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context11))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context11) => provideContext(self2, f(context11))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options4) => flatMap9(self2, (a) => flatMap9(options4.predicate(a), (pass) => pass ? succeed(a) : options4.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options4) => filterEffectOrElse(self2, {
  predicate: options4.predicate,
  orElse: (a) => fail2(options4.orFailWith(a))
}));
var currentSpanFromFiber = /* @__PURE__ */ __name((fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some3(span4) : none2();
}, "currentSpanFromFiber");
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = /* @__PURE__ */ __name((options4) => Object.assign(Object.create(NoopSpanProto), options4), "noopSpan");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/defaultServices.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/clock.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration3) {
    const millis2 = toMillis(duration3);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration3) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_2), duration3);
      return asVoid2(sync(canceler));
    });
  }
};
__name(ClockImpl, "ClockImpl");
var make19 = /* @__PURE__ */ __name(() => new ClockImpl(), "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configProvider.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Number.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Order2 = number3;
var clamp4 = /* @__PURE__ */ clamp(Order2);
var remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = /* @__PURE__ */ __name((n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
}, "nextPow2");
var parse = /* @__PURE__ */ __name((s) => {
  if (s === "NaN") {
    return some2(NaN);
  }
  if (s === "Infinity") {
    return some2(Infinity);
  }
  if (s === "-Infinity") {
    return some2(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some2(n);
}, "parse");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RegExp.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var escape = /* @__PURE__ */ __name((string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&"), "escape");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/configError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = /* @__PURE__ */ __name((self2, that) => {
  const error3 = Object.create(proto2);
  error3._op = OP_AND;
  error3.left = self2;
  error3.right = that;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error3, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error3;
}, "And");
var Or = /* @__PURE__ */ __name((self2, that) => {
  const error3 = Object.create(proto2);
  error3._op = OP_OR;
  error3.left = self2;
  error3.right = that;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error3, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error3;
}, "Or");
var InvalidData = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error3 = Object.create(proto2);
  error3._op = OP_INVALID_DATA;
  error3.path = path;
  error3.message = message;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error3;
}, "InvalidData");
var MissingData = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error3 = Object.create(proto2);
  error3._op = OP_MISSING_DATA;
  error3.path = path;
  error3.message = message;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error3;
}, "MissingData");
var SourceUnavailable = /* @__PURE__ */ __name((path, message, cause3, options4 = {
  pathDelim: "."
}) => {
  const error3 = Object.create(proto2);
  error3._op = OP_SOURCE_UNAVAILABLE;
  error3.path = path;
  error3.message = message;
  error3.cause = cause3;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error3;
}, "SourceUnavailable");
var Unsupported = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error3 = Object.create(proto2);
  error3._op = OP_UNSUPPORTED;
  error3.path = path;
  error3.message = message;
  Object.defineProperty(error3, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error3;
}, "Unsupported");
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix3) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix3), prefixed(self2.right, prefix3));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix3), prefixed(self2.right, prefix3));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix3, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix3, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix3, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix3, ...self2.path], self2.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self2, context11, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const error3 = input.pop();
    switch (error3._op) {
      case OP_AND: {
        input.push(error3.right);
        input.push(error3.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error3.right);
        input.push(error3.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context11, error3.path, error3.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context11, error3.path, error3.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context11, error3.path, error3.message, error3.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context11, error3.path, error3.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either9 = output.pop();
    switch (either9._op) {
      case "Left": {
        switch (either9.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.andCase(context11, left3, right3);
            accumulator.push(value6);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.orCase(context11, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either9.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = /* @__PURE__ */ __name((self2) => reduceWithContext2(self2, void 0, IsMissingDataOnlyReducer), "isMissingDataOnly");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var empty18 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path, patch12) => {
  let input = of3(patch12);
  let output = path;
  while (isCons(input)) {
    const patch13 = input.head;
    switch (patch13._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch13.first, cons(patch13.second, input.tail));
        break;
      }
      case "MapName": {
        output = map4(output, patch13.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch13.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch13.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch13.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/config.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configProvider.js
var concat = /* @__PURE__ */ __name((l, r) => [...l, ...r], "concat");
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = /* @__PURE__ */ __name((options4) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options4
}), "make");
var makeFlat = /* @__PURE__ */ __name((options4) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options4.patch,
  load: (path, config2, split5 = true) => options4.load(path, config2, split5),
  enumerateChildren: options4.enumerateChildren
}), "makeFlat");
var fromFlat = /* @__PURE__ */ __name((flat) => make21({
  load: (config2) => flatMap9(fromFlatLoop(flat, empty2(), config2, false), (chunk4) => match2(head(chunk4), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
}), "fromFlat");
var fromEnv = /* @__PURE__ */ __name((options4) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options4);
  const makePathString = /* @__PURE__ */ __name((path) => pipe(path, join(pathDelim)), "makePathString");
  const unmakePathString = /* @__PURE__ */ __name((pathString) => pathString.split(pathDelim), "unmakePathString");
  const getEnv = /* @__PURE__ */ __name(() => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {}, "getEnv");
  const load = /* @__PURE__ */ __name((path, primitive2, split5 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some3(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap9((value6) => parsePrimitive(value6, path, primitive2, seqDelim, split5)));
  }, "load");
  const enumerateChildren = /* @__PURE__ */ __name((path) => sync(() => {
    const current2 = getEnv();
    const keys6 = Object.keys(current2);
    const keyPaths = keys6.map((value6) => unmakePathString(value6.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  }), "enumerateChildren");
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty18
  }));
}, "fromEnv");
var extend = /* @__PURE__ */ __name((leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index2) => index2 >= right3.length ? none2() : some3([leftDef(index2), index2 + 1]));
  const rightPad = unfold(right3.length, (index2) => index2 >= left3.length ? none2() : some3([rightDef(index2), index2 + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
}, "extend");
var appendConfigPath = /* @__PURE__ */ __name((path, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
}, "appendConfigPath");
var fromFlatLoop = /* @__PURE__ */ __name((flat, prefix3, config2, split5) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix3, op.config, split5));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix3, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix3, op.first, split5)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix3, op.second, split5), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix3, op.config(), split5));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix3, op.original, split5), flatMap9(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix3, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix3, of(op.name)), op.config, split5));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix3, flat.patch), flatMap9((prefix4) => pipe(flat.load(prefix4, op, split5), flatMap9((values6) => {
        if (values6.length === 0) {
          const name = pipe(last(prefix4), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values6);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix3, flat.patch), flatMap9((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap9(indicesFrom), flatMap9((indices) => {
        if (indices.length === 0) {
          return suspend(() => map11(fromFlatLoop(flat, prefix3, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index2) => fromFlatLoop(flat, append(prefix3, `[${index2}]`), op.config, true)), map11((chunkChunk) => {
          const flattened = flatten2(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix3, flat.patch), flatMap9((prefix4) => pipe(flat.enumerateChildren(prefix4), flatMap9((keys6) => {
        return pipe(keys6, forEachSequential((key) => fromFlatLoop(flat, concat(prefix4, of(key)), op.valueConfig, split5)), map11((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map4((values6) => fromIterable7(zip(fromIterable2(keys6), values6))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix3, op.left, split5), either2, flatMap9((left3) => pipe(fromFlatLoop(flat, prefix3, op.right, split5), either2, flatMap9((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix3, join("."));
          const fail21 = fromFlatLoopFail(prefix3, path);
          const [lefts, rights] = extend(fail21, fail21, pipe(left3.right, map4(right2)), pipe(right3.right, map4(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip3(left4, right4), map11(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
}, "fromFlatLoop");
var fromFlatLoopFail = /* @__PURE__ */ __name((prefix3, path) => (index2) => left2(MissingData(prefix3, `The element at index ${index2} in a sequence at path "${path}" was missing`)), "fromFlatLoopFail");
var splitPathString = /* @__PURE__ */ __name((text6, delim) => {
  const split5 = text6.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split5;
}, "splitPathString");
var parsePrimitive = /* @__PURE__ */ __name((text6, path, primitive2, delimiter, split5) => {
  if (!split5) {
    return pipe(primitive2.parse(text6), mapBoth2({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text6, delimiter), forEachSequential((char2) => primitive2.parse(char2.trim())), mapError(prefixed(path)));
}, "parsePrimitive");
var transpose = /* @__PURE__ */ __name((array6) => {
  return Object.keys(array6[0]).map((column4) => array6.map((row) => row[column4]));
}, "transpose");
var indicesFrom = /* @__PURE__ */ __name((quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty2(),
  onSuccess: sort(Order2)
}), either2, map11(merge)), "indicesFrom");
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = /* @__PURE__ */ __name((str) => {
  const match21 = str.match(QUOTED_INDEX_REGEX);
  if (match21 !== null) {
    const matchedIndex = match21[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
}, "parseQuotedIndex");
var parseInteger = /* @__PURE__ */ __name((str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some3(parsedIndex);
}, "parseInteger");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/defaultServices/console.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId9]: TypeId9,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options4) {
    return sync(() => {
      console.dir(item, options4);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options4) {
    return options4?.collapsed ? sync(() => console.groupCollapsed(options4?.label)) : sync(() => console.group(options4?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/random.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map11(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min5, max8) {
    return map11(this.next, (n) => (max8 - min5) * n + min5);
  }
  nextIntBetween(min5, max8) {
    return sync(() => this.PRNG.integer(max8 - min5) + min5);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
__name(RandomImpl, "RandomImpl");
var shuffleWith = /* @__PURE__ */ __name((elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap9((buffer4) => {
    const numbers = [];
    for (let i = buffer4.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map11((k) => swap(buffer4, n - 1, k)))), as3(fromIterable3(buffer4)));
  })));
}, "shuffleWith");
var swap = /* @__PURE__ */ __name((buffer4, index1, index2) => {
  const tmp = buffer4[index1];
  buffer4[index1] = buffer4[index2];
  buffer4[index2] = tmp;
  return buffer4;
}, "swap");
var make22 = /* @__PURE__ */ __name((seed) => new RandomImpl(hash(seed)), "make");
var FixedRandomImpl = class {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values6) {
    this.values = values6;
    if (values6.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value6 = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value6;
  }
  get next() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number") {
        return Math.max(0, Math.min(1, value6));
      }
      return hash(value6) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "boolean") {
        return value6;
      }
      return hash(value6) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.round(value6);
      }
      return Math.abs(hash(value6));
    });
  }
  nextRange(min5, max8) {
    return map11(this.next, (n) => (max8 - min5) * n + min5);
  }
  nextIntBetween(min5, max8) {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.max(min5, Math.min(max8 - 1, Math.round(value6)));
      }
      const hash5 = Math.abs(hash(value6));
      return min5 + hash5 % (max8 - min5);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
__name(FixedRandomImpl, "FixedRandomImpl");
var fixed = /* @__PURE__ */ __name((values6) => new FixedRandomImpl(values6), "fixed");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/tracer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = /* @__PURE__ */ __name((options4) => ({
  [TracerTypeId]: TracerTypeId,
  ...options4
}), "make");
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length4) {
    let result = "";
    for (let i = 0; i < length4; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context11, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context11;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value6) {
    this.attributes.set(key, value6);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
__name(NativeSpan, "NativeSpan");
var nativeTracer = /* @__PURE__ */ make23({
  span: (name, parent, context11, links, startTime, kind) => new NativeSpan(name, parent, context11, links, startTime, kind),
  context: (f) => f()
});
var externalSpan = /* @__PURE__ */ __name((options4) => ({
  _tag: "ExternalSpan",
  spanId: options4.spanId,
  traceId: options4.traceId,
  sampled: options4.sampled ?? true,
  context: options4.context ?? empty9()
}), "externalSpan");
var addSpanStackTrace = /* @__PURE__ */ __name((options4) => {
  if (options4?.captureStackTrace === false) {
    return options4;
  } else if (options4?.captureStackTrace !== void 0 && typeof options4.captureStackTrace !== "boolean") {
    return options4;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options4,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
}, "addSpanStackTrace");
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty9(), /* @__PURE__ */ add4(clockTag, /* @__PURE__ */ make19()), /* @__PURE__ */ add4(consoleTag, defaultConsole), /* @__PURE__ */ add4(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add4(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add4(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = /* @__PURE__ */ __name((duration3) => {
  const decodedDuration = decode(duration3);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
}, "sleep");
var defaultServicesWith = /* @__PURE__ */ __name((f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices)), "defaultServicesWith");
var clockWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key))), "clockWith");
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add4(clockTag, c))(effect4));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add4(configProviderTag, provider))(self2));
var configProviderWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key))), "configProviderWith");
var config = /* @__PURE__ */ __name((config2) => configProviderWith((_) => _.load(config2)), "config");
var randomWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key))), "randomWith");
var withRandom = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add4(randomTag, value6))(effect4));
var tracerWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key))), "tracerWith");
var withTracer = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add4(tracerTag, value6))(effect4));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRuntime.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Boolean.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var not2 = /* @__PURE__ */ __name((self2) => !self2, "not");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Effectable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var StructuralBase2 = StructuralBase;
var Class2 = class extends Base2 {
};
__name(Class2, "Class");
var StructuralClass = class extends StructuralBase2 {
};
__name(StructuralClass, "StructuralClass");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ExecutionStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/executionStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = /* @__PURE__ */ __name((parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
}), "parallelN");
var isSequential = /* @__PURE__ */ __name((self2) => self2._tag === OP_SEQUENTIAL2, "isSequential");
var isParallel = /* @__PURE__ */ __name((self2) => self2._tag === OP_PARALLEL2, "isParallel");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefs.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRefs.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function unsafeMake4(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
__name(unsafeMake4, "unsafeMake");
function empty19() {
  return unsafeMake4(/* @__PURE__ */ new Map());
}
__name(empty19, "empty");
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(FiberRefsImpl, "FiberRefsImpl");
var findAncestor = /* @__PURE__ */ __name((_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
}, "findAncestor");
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId3, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId3)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId3, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch12 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch12)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId3)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId3, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map33 = /* @__PURE__ */ new Map();
  unsafeForkAs(self2, map33, childId);
  return new FiberRefsImpl(map33);
});
var unsafeForkAs = /* @__PURE__ */ __name((self2, map33, fiberId3) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map33.set(fiberRef, stack);
    } else {
      map33.set(fiberRef, [[fiberId3, newValue], ...stack]);
    }
  });
}, "unsafeForkAs");
var fiberRefs = /* @__PURE__ */ __name((self2) => fromIterable6(self2.locals.keys()), "fiberRefs");
var setAll = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef))), "setAll");
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some3(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId3,
  fiberRef,
  value: value6
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId3, value6]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId3, fiberRef, value6);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = /* @__PURE__ */ __name((locals, fiberId3, fiberRef, value6) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId3)) {
      if (equals(currentValue, value6)) {
        return;
      } else {
        newStack = [[fiberId3, value6], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId3, value6], ...oldStack];
    }
  } else {
    newStack = [[fiberId3, value6]];
  }
  locals.set(fiberRef, newStack);
}, "unsafeUpdateAs");
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries3,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries3.forEach(([fiberRef, values6]) => {
    if (values6.length === 1) {
      unsafeUpdateAs(locals, values6[0][0], fiberRef, values6[0][1]);
    } else {
      values6.forEach(([fiberId3, value6]) => {
        unsafeUpdateAs(locals, fiberId3, fiberRef, value6);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefs.js
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateManyAs2 = updateManyAs;
var empty20 = empty19;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefsPatch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty21 = {
  _tag: OP_EMPTY2
};
var diff5 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch12 = empty21;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch12 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch12);
      }
    } else {
      patch12 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch12);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch12 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch12);
  }
  return patch12;
}, "diff");
var combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self2, fiberId3, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head10 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head10._tag) {
      case OP_EMPTY2: {
        patches = tail2;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head10.fiberRef,
          value: head10.value
        });
        patches = tail2;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head10.fiberRef);
        patches = tail2;
        break;
      }
      case OP_UPDATE: {
        const value6 = getOrDefault(fiberRefs3, head10.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head10.fiberRef,
          value: head10.fiberRef.patch(head10.patch)(value6)
        });
        patches = tail2;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head10.first)(prepend(head10.second)(tail2));
        break;
      }
    }
  }
  return fiberRefs3;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberStatus.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberStatus.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string2(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
__name(Done, "Done");
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
__name(Running, "Running");
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
__name(Suspended, "Suspended");
var done2 = /* @__PURE__ */ new Done();
var running = /* @__PURE__ */ __name((runtimeFlags2) => new Running(runtimeFlags2), "running");
var suspended = /* @__PURE__ */ __name((runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn), "suspended");
var isFiberStatus = /* @__PURE__ */ __name((u) => hasProperty(u, FiberStatusTypeId), "isFiberStatus");
var isDone = /* @__PURE__ */ __name((self2) => self2._tag === OP_DONE, "isDone");
var isRunning = /* @__PURE__ */ __name((self2) => self2._tag === OP_RUNNING, "isRunning");
var isSuspended = /* @__PURE__ */ __name((self2) => self2._tag === OP_SUSPENDED, "isSuspended");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberStatus.js
var done3 = done2;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/LogLevel.js
var LogLevel_exports = {};
__export(LogLevel_exports, {
  All: () => All,
  Debug: () => Debug,
  Error: () => Error2,
  Fatal: () => Fatal,
  Info: () => Info,
  None: () => None3,
  Order: () => Order3,
  Trace: () => Trace,
  Warning: () => Warning,
  allLevels: () => allLevels,
  fromLiteral: () => fromLiteral,
  greaterThan: () => greaterThan3,
  greaterThanEqual: () => greaterThanEqual,
  lessThan: () => lessThan3,
  lessThanEqual: () => lessThanEqual,
  locally: () => locally
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var locally = /* @__PURE__ */ dual(2, (use3, self2) => fiberRefLocally(use3, currentLogLevel, self2));
var Order3 = /* @__PURE__ */ pipe(Order2, /* @__PURE__ */ mapInput3((level) => level.ordinal));
var lessThan3 = /* @__PURE__ */ lessThan(Order3);
var lessThanEqual = /* @__PURE__ */ lessThanOrEqualTo(Order3);
var greaterThan3 = /* @__PURE__ */ greaterThan(Order3);
var greaterThanEqual = /* @__PURE__ */ greaterThanOrEqualTo(Order3);
var fromLiteral = /* @__PURE__ */ __name((literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
}, "fromLiteral");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Micro.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError2, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError2 instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError2.name}`;
      message = originalError2.message;
      const messageLines = message.split("\n").length;
      stack = originalError2.stack ? `(${causeName}) ${originalError2.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError2, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
__name(MicroCauseImpl, "MicroCauseImpl");
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
__name(Die, "Die");
var causeDie = /* @__PURE__ */ __name((defect, traces = []) => new Die(defect, traces), "causeDie");
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
__name(Interrupt, "Interrupt");
var causeInterrupt = /* @__PURE__ */ __name((traces = []) => new Interrupt(traces), "causeInterrupt");
var causeIsInterrupt = /* @__PURE__ */ __name((self2) => self2._tag === "Interrupt", "causeIsInterrupt");
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context11, interruptible5 = true) {
    this.context = context11;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index2 = this._observers.indexOf(cb);
      if (index2 >= 0) {
        this._observers.splice(index2, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap10(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap10(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error3) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error3);
    }
  }
  getCont(symbol6) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol6]: cont
        };
      if (op[symbol6])
        return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value6) {
    this._yielded = value6;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
__name(MicroFiberImpl, "MicroFiberImpl");
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll = /* @__PURE__ */ __name((fibers) => suspend2(() => {
  for (const fiber of fibers)
    fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
}), "fiberInterruptAll");
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId10]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
__name(defaultEvaluate, "defaultEvaluate");
var makePrimitiveProto = /* @__PURE__ */ __name((options4) => ({
  ...MicroProto,
  [identifier]: options4.op,
  [evaluate]: options4.eval ?? defaultEvaluate,
  [successCont]: options4.contA,
  [failureCont]: options4.contE,
  [ensureCont]: options4.ensure
}), "makePrimitiveProto");
var makePrimitive = /* @__PURE__ */ __name((options4) => {
  const Proto8 = makePrimitiveProto(options4);
  return function() {
    const self2 = Object.create(Proto8);
    self2[args] = options4.single === false ? arguments : arguments[0];
    return self2;
  };
}, "makePrimitive");
var makeExit = /* @__PURE__ */ __name((options4) => {
  const Proto8 = {
    ...makePrimitiveProto(options4),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options4.op,
    get [options4.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options4.op,
        [options4.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options4.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string2(options4.op))(hash(this[args])));
    }
  };
  return function(value6) {
    const self2 = Object.create(Proto8);
    self2[args] = value6;
    self2[successCont] = void 0;
    self2[failureCont] = void 0;
    self2[ensureCont] = void 0;
    return self2;
  };
}, "makeExit");
var succeed2 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause2 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var sync2 = /* @__PURE__ */ makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value6 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value6, fiber) : fiber.yieldWith(exitSucceed2(value6));
  }
});
var suspend2 = /* @__PURE__ */ makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_3 = /* @__PURE__ */ succeed2(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var asyncOptions = /* @__PURE__ */ makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed)
        return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller?.signal);
    if (yielded !== false)
      return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = /* @__PURE__ */ makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause3, _fiber) {
    return causeIsInterrupt(cause3) ? flatMap10(this[args](), () => failCause2(cause3)) : failCause2(cause3);
  }
});
var async = /* @__PURE__ */ __name((register) => asyncOptions(register, register.length >= 2), "async");
var as4 = /* @__PURE__ */ dual(2, (self2, value6) => map12(self2, (_) => value6));
var exit2 = /* @__PURE__ */ __name((self2) => matchCause2(self2, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
}), "exit");
var flatMap10 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map12 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (a) => succeed2(f(a))));
var isMicroExit = /* @__PURE__ */ __name((u) => hasProperty(u, MicroExitTypeId), "isMicroExit");
var exitSucceed2 = succeed2;
var exitFailCause2 = failCause2;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = /* @__PURE__ */ __name((defect) => exitFailCause2(causeDie(defect)), "exitDie");
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var exitVoidAll = /* @__PURE__ */ __name((exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
}, "exitVoidAll");
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
__name(MicroSchedulerDefault, "MicroSchedulerDefault");
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_3;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
};
__name(MaxOpsBeforeYield, "MaxOpsBeforeYield");
var CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
})) {
};
__name(CurrentConcurrency, "CurrentConcurrency");
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
})) {
};
__name(CurrentScheduler, "CurrentScheduler");
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options4) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self2;
  primitive2[successCont] = options4.onSuccess;
  primitive2[failureCont] = options4.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect2(self2, {
  onFailure: (cause3) => sync2(() => options4.onFailure(cause3)),
  onSuccess: (value6) => sync2(() => options4.onSuccess(value6))
}));
var MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer3);
    }
  }
  addFinalizer(finalizer3) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer3);
        return void_3;
      }
      return finalizer3(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer3);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap10(forEach6(finalizers, (finalizer3) => exit2(finalizer3(microExit))), exitVoidAll);
      }
      return void_3;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      __name(fin, "fin");
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
__name(MicroScopeImpl, "MicroScopeImpl");
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause3) => flatMap10(f(exitFailCause2(cause3)), () => failCause2(cause3)),
  onSuccess: (a) => flatMap10(f(exitSucceed2(a)), () => succeed2(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = /* @__PURE__ */ __name((self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self2;
}), "interruptible");
var uninterruptibleMask2 = /* @__PURE__ */ __name((f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
}), "uninterruptibleMask");
var whileLoop2 = /* @__PURE__ */ makePrimitive({
  op: "While",
  contA(value6, fiber) {
    this[args].step(value6);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach6 = /* @__PURE__ */ __name((iterable, f, options4) => withMicroFiber((parent) => {
  const concurrencyOption = options4?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options4?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable2(iterable);
  let length4 = items.length;
  if (length4 === 0) {
    return options4?.discard ? void_3 : succeed2([]);
  }
  const out = options4?.discard ? void 0 : new Array(length4);
  let index2 = 0;
  if (concurrency === 1) {
    return as4(whileLoop2({
      while: () => index2 < items.length,
      body: () => f(items[index2], index2),
      step: out ? (b) => out[index2++] = b : (_) => index2++
    }), out);
  }
  return async((resume2) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted4 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index2 < length4) {
        const currentIndex = index2;
        const item = items[currentIndex];
        index2++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit4) => {
            fibers.delete(child);
            if (interrupted4) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length4 = index2;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length4) {
              resume2(result ?? succeed2(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length4 = index2;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    __name(pump, "pump");
    pump();
    return suspend2(() => {
      interrupted4 = true;
      index2 = length4;
      return fiberInterruptAll(fibers);
    });
  });
}), "forEach");
var unsafeFork = /* @__PURE__ */ __name((parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
}, "unsafeFork");
var runFork = /* @__PURE__ */ __name((effect4, options4) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options4?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options4?.signal) {
    if (options4.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = /* @__PURE__ */ __name(() => fiber.unsafeInterrupt(), "abort");
      options4.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options4.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
}, "runFork");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get12,
  getAndSet: () => getAndSet2,
  getAndUpdate: () => getAndUpdate2,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make25,
  modify: () => modify6,
  modifySome: () => modifySome2,
  set: () => set5,
  setAndGet: () => setAndGet2,
  unsafeMake: () => unsafeMake6,
  update: () => update3,
  updateAndGet: () => updateAndGet2,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/ref.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Readable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId11]: TypeId11,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var RefImpl = class extends Class2 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId11] = TypeId11;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get7(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current2 = get7(this.ref);
      const [b, a] = f(current2);
      if (current2 !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
__name(RefImpl, "RefImpl");
var unsafeMake5 = /* @__PURE__ */ __name((value6) => new RefImpl(make12(value6)), "unsafeMake");
var make24 = /* @__PURE__ */ __name((value6) => sync(() => unsafeMake5(value6)), "make");
var get11 = /* @__PURE__ */ __name((self2) => self2.get, "get");
var set4 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [void 0, value6]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify((a) => [a, value6]));
var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
var getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value6) => {
  const option7 = pf(value6);
  switch (option7._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [value6, option7.value];
    }
  }
}));
var setAndGet = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [value6, value6]));
var modify5 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value6) => {
  const option7 = pf(value6);
  switch (option7._tag) {
    case "None": {
      return [fallback, value6];
    }
    case "Some": {
      return option7.value;
    }
  }
}));
var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value6) => {
  const option7 = pf(value6);
  switch (option7._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [option7.value, option7.value];
    }
  }
}));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make25 = make24;
var get12 = get11;
var getAndSet2 = getAndSet;
var getAndUpdate2 = getAndUpdate;
var getAndUpdateSome2 = getAndUpdateSome;
var modify6 = modify5;
var modifySome2 = modifySome;
var set5 = set4;
var setAndGet2 = setAndGet;
var update3 = update2;
var updateAndGet2 = updateAndGet;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake6 = unsafeMake5;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Scheduler.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length4 = this.buckets.length;
    let bucket = void 0;
    let index2 = 0;
    for (; index2 < length4; index2++) {
      if (this.buckets[index2][0] <= priority) {
        bucket = this.buckets[index2];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index2 === length4) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index2, 0, [priority, [task]]);
    }
  }
};
__name(PriorityBuckets, "PriorityBuckets");
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
__name(MixedScheduler, "MixedScheduler");
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
__name(SyncScheduler, "SyncScheduler");
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentScheduler, scheduler2));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/completedRequestMap.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/concurrency.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var match7 = /* @__PURE__ */ __name((concurrency, sequential5, unbounded8, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded8();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded8() : concurrency2 > 1 ? bounded8(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
}, "match");
var matchSimple = /* @__PURE__ */ __name((concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
}, "matchSimple");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core-effect.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Clock.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/LogSpan.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/logSpan.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make26 = /* @__PURE__ */ __name((label, startTime) => ({
  label,
  startTime
}), "make");
var formatLabel = /* @__PURE__ */ __name((key) => key.replace(/[\s="]/g, "_"), "formatLabel");
var render = /* @__PURE__ */ __name((now2) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now2 - self2.startTime}ms`;
}, "render");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/LogSpan.js
var make27 = make26;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Tracer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ParentSpan = spanTag;
var make28 = make23;
var externalSpan2 = externalSpan;
var tracerWith2 = tracerWith;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/label.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value6) {
    this.key = key;
    this.value = value6;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(MetricLabelImpl, "MetricLabelImpl");
var make29 = /* @__PURE__ */ __name((key, value6) => {
  return new MetricLabelImpl(key, value6);
}, "make");
var isMetricLabel = /* @__PURE__ */ __name((u) => hasProperty(u, MetricLabelTypeId), "isMetricLabel");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var asSome = /* @__PURE__ */ __name((self2) => map11(self2, some3), "asSome");
var asSomeError = /* @__PURE__ */ __name((self2) => mapError(self2, some3), "asSomeError");
var try_2 = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error3) {
      return fail2(onFailure ? internalCall(() => onFailure(error3)) : new UnknownException(error3, "An unknown error occurred in Effect.try"));
    }
  });
}, "try_");
var _catch = /* @__PURE__ */ dual(3, (self2, tag8, options4) => catchAll(self2, (e) => {
  if (hasProperty(e, tag8) && e[tag8] === options4.failure) {
    return options4.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => {
  const option7 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option7._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f(option7.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const option7 = f(cause3);
    switch (option7._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option7.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const option7 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option7._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option7.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = /* @__PURE__ */ __name((e) => {
      const tag8 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag8)
        return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag8)
          return true;
      }
      return false;
    }, "predicate");
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys6;
  return catchIf(self2, (e) => {
    keys6 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys6.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = /* @__PURE__ */ __name((self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty7
}), "cause");
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration3) => zipRight2(sleep2(duration3), self2));
var descriptorWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state, status3) => f({
  id: state.id(),
  status: status3,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
})), "descriptorWith");
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor3) => size4(descriptor3.interruptors) > 0 ? interrupt2 : void_2);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = /* @__PURE__ */ __name((self2) => summarized(self2, fiberRefs2, diff5), "diffFiberRefs");
var diffFiberRefsAndRuntimeFlags = /* @__PURE__ */ __name((self2) => summarized(self2, zip3(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]), "diffFiberRefsAndRuntimeFlags");
var Do2 = /* @__PURE__ */ succeed({});
var bind3 = /* @__PURE__ */ bind(map11, flatMap9);
var bindTo3 = /* @__PURE__ */ bindTo(map11);
var let_3 = /* @__PURE__ */ let_(map11);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping7 = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i++;
    dropping7 = flatMap9(dropping7, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index2);
    });
  }
  return map11(dropping7, () => builder);
}));
var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping7 = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i++;
    dropping7 = flatMap9(dropping7, (d) => map11(d ? predicate(a, index2) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map11(dropping7, () => builder);
}));
var contextWith = /* @__PURE__ */ __name((f) => map11(context(), f), "contextWith");
var eventually = /* @__PURE__ */ __name((self2) => orElse2(self2, () => flatMap9(yieldNow(), () => eventually(self2))), "eventually");
var filterMap6 = /* @__PURE__ */ dual(2, (elements, pf) => map11(forEachSequential(elements, identity), filterMap2(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith6) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith6(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse16) => flatMap9(self2, (a) => predicate(a) ? succeed(a) : orElse16(a)));
var liftPredicate2 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst6 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = /* @__PURE__ */ __name((iterator, index2, f, value6) => flatMap9(f(value6, index2), (result) => {
  if (result) {
    return succeed(some3(value6));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index2 + 1, f, next.value);
  }
  return succeed(none2());
}), "findLoop");
var firstSuccessOf = /* @__PURE__ */ __name((effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
}), "firstSuccessOf");
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
var match8 = /* @__PURE__ */ dual(2, (self2, options4) => matchEffect(self2, {
  onFailure: (e) => succeed(options4.onFailure(e)),
  onSuccess: (a) => succeed(options4.onSuccess(a))
}));
var every8 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = /* @__PURE__ */ __name((iterator, index2, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap9(f(next.value, index2), (b) => b ? forAllLoop(iterator, index2 + 1, f) : succeed(b));
}, "forAllLoop");
var forever = /* @__PURE__ */ __name((self2) => {
  const loop3 = flatMap9(flatMap9(self2, () => yieldNow()), () => loop3);
  return loop3;
}, "forever");
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = /* @__PURE__ */ __name((self2) => flatMap9(self2, (as14) => {
  const iterator = as14[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next.value);
}), "head");
var ignore = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
}), "ignore");
var ignoreLogged = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_2
}), "ignoreLogged");
var inheritFiberRefs = /* @__PURE__ */ __name((childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs)), "inheritFiberRefs");
var isFailure2 = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
}), "isFailure");
var isSuccess = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
}), "isSuccess");
var iterate = /* @__PURE__ */ __name((initial, options4) => suspend(() => {
  if (options4.while(initial)) {
    return flatMap9(options4.body(initial), (z2) => iterate(z2, options4));
  }
  return succeed(initial);
}), "iterate");
var logWithLevel = /* @__PURE__ */ __name((level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty7;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_2;
  });
}, "logWithLevel");
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect4, label) => flatMap9(currentTimeMillis2, (now2) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make27(label, now2)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = /* @__PURE__ */ __name((initial, options4) => options4.discard ? loopDiscard(initial, options4.while, options4.step, options4.body) : map11(loopInternal(initial, options4.while, options4.step, options4.body), fromIterable2), "loop");
var loopInternal = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), (a) => map11(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty11())), "loopInternal");
var loopDiscard = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_2), "loopDiscard");
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index2 = i++;
    const value6 = next.value;
    result = flatMap9(result, (state) => map11(f(state, value6, index2), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map11(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = /* @__PURE__ */ __name((self2) => pipe(deferredMake(), flatMap9((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map11((complete4) => zipRight2(complete4, pipe(deferredAwait(deferred), flatMap9(([patch12, a]) => as3(zip3(patchFiberRefs(patch12[0]), updateRuntimeFlags(patch12[1])), a)))))))), "memoize");
var merge5 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
}), "merge");
var negate = /* @__PURE__ */ __name((self2) => map11(self2, (b) => !b), "negate");
var none6 = /* @__PURE__ */ __name((self2) => flatMap9(self2, (option7) => {
  switch (option7._tag) {
    case "None":
      return void_2;
    case "Some":
      return fail2(new NoSuchElementException());
  }
}), "none");
var once = /* @__PURE__ */ __name((self2) => map11(make25(true), (ref) => asVoid2(whenEffect(self2, getAndSet2(ref, false)))), "once");
var option = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some3(a))
}), "option");
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => failSync(evaluate3)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => sync(evaluate3)));
var parallelErrors = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const errors3 = fromIterable2(failures(cause3));
    return errors3.length === 0 ? failCause(cause3) : fail2(errors3);
  },
  onSuccess: succeed
}), "parallelErrors");
var patchFiberRefs = /* @__PURE__ */ __name((patch12) => updateFiberRefs((fiberId3, fiberRefs3) => pipe(patch12, patch6(fiberId3, fiberRefs3))), "patchFiberRefs");
var promise = /* @__PURE__ */ __name((evaluate3) => evaluate3.length >= 1 ? async_((resolve3, signal) => {
  try {
    evaluate3(signal).then((a) => resolve3(succeed(a)), (e) => resolve3(die2(e)));
  } catch (e) {
    resolve3(die2(e));
  }
}) : async_((resolve3) => {
  try {
    ;
    evaluate3().then((a) => resolve3(succeed(a)), (e) => resolve3(die2(e)));
  } catch (e) {
    resolve3(die2(e));
  }
}), "promise");
var provideService = /* @__PURE__ */ dual(3, (self2, tag8, service3) => contextWithEffect((env) => provideContext(self2, add4(env, tag8, service3))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag8, effect4) => contextWithEffect((env) => flatMap9(effect4, (service3) => provideContext(self2, pipe(env, add4(tag8, service3))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce9 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap9(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap9(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options4) => flatMap9(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options4.while, options4.body)));
var reduceWhileLoop = /* @__PURE__ */ __name((iterator, index2, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap9(f(state, next.value, index2), (nextState) => reduceWhileLoop(iterator, index2 + 1, nextState, predicate, f));
  }
  return succeed(state);
}, "reduceWhileLoop");
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = /* @__PURE__ */ __name((self2, n) => flatMap9(self2, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self2, n - 1))), "repeatNLoop");
var sandbox = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
}), "sandbox");
var setFiberRefs = /* @__PURE__ */ __name((fiberRefs3) => suspend(() => setAll2(fiberRefs3)), "setFiberRefs");
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = /* @__PURE__ */ __name((value6) => succeed(some3(value6)), "succeedSome");
var summarized = /* @__PURE__ */ dual(3, (self2, summary6, f) => flatMap9(summary6, (start3) => flatMap9(self2, (value6) => map11(summary6, (end6) => [f(start3, end6), value6]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make29(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect4 = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i++;
    effect4 = flatMap9(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index2);
    });
  }
  return map11(effect4, () => builder);
}));
var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i++;
    taking = flatMap9(taking, (taking2) => pipe(taking2 ? predicate(a, index2) : succeed(false), map11((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map11(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either9 = failureOrCause(cause3);
    switch (either9._tag) {
      case "Left": {
        return zipRight2(onFailure(either9.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a) => as3(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a) => zipRight2(f(a), failCause(cause3))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either9 = failureOrCause(cause3);
    switch (either9._tag) {
      case "Left":
        return zipRight2(f(either9.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_2;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause3) => zipRight2(f(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = /* @__PURE__ */ __name((self2) => timedWith(self2, currentTimeNanos2), "timed");
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start3, end6) => nanos(end6 - start3)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail21 = /* @__PURE__ */ __name((e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise")), "fail");
  if (evaluate3.length >= 1) {
    return async_((resolve3, signal) => {
      try {
        evaluate3(signal).then((a) => resolve3(succeed(a)), (e) => resolve3(fail21(e)));
      } catch (e) {
        resolve3(fail21(e));
      }
    });
  }
  return async_((resolve3) => {
    try {
      evaluate3().then((a) => resolve3(succeed(a)), (e) => resolve3(fail21(e)));
    } catch (e) {
      resolve3(fail21(e));
    }
  });
}, "tryPromise");
var tryMap = /* @__PURE__ */ dual(2, (self2, options4) => flatMap9(self2, (a) => try_2({
  try: () => options4.try(a),
  catch: options4.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options4) => flatMap9(self2, (a) => tryPromise({
  try: options4.try.length >= 1 ? (signal) => options4.try(a, signal) : () => options4.try(a),
  catch: options4.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap9(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = /* @__PURE__ */ __name((self2) => mapErrorCause(self2, flatten4), "unsandbox");
var updateFiberRefs = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_2;
}), "updateFiberRefs");
var updateService = /* @__PURE__ */ dual(3, (self2, tag8, f) => mapInputContext(self2, (context11) => add4(context11, tag8, f(unsafeGet5(context11, tag8)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map11(self2, some3) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap9(fiberRefGet(fiberRef), (s) => predicate(s) ? map11(self2, (a) => [s, some3(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap9(get12(ref), (s) => predicate(s) ? map11(self2, (a) => [s, some3(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = /* @__PURE__ */ __name((getService, f) => (...args2) => flatMap9(getService, (a) => f(a)(...args2)), "serviceFunctionEffect");
var serviceFunction = /* @__PURE__ */ __name((getService, f) => (...args2) => map11(getService, (a) => f(a)(...args2)), "serviceFunction");
var serviceFunctions = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap9(getService, (s) => s[prop](...args2));
  }
}), "serviceFunctions");
var serviceConstants = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap9(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
}), "serviceConstants");
var serviceMembers = /* @__PURE__ */ __name((getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
}), "serviceMembers");
var serviceOption = /* @__PURE__ */ __name((tag8) => map11(context(), getOption2(tag8)), "serviceOption");
var serviceOptional = /* @__PURE__ */ __name((tag8) => flatMap9(context(), getOption2(tag8)), "serviceOptional");
var annotateCurrentSpan = /* @__PURE__ */ __name(function() {
  const args2 = arguments;
  return ignore(flatMap9(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
}, "annotateCurrentSpan");
var linkSpanCurrent = /* @__PURE__ */ __name(function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap9(currentSpan, (span4) => sync(() => span4.addLinks(links))));
}, "linkSpanCurrent");
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap9(/* @__PURE__ */ context(), (context11) => {
  const span4 = context11.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span4, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span4) => get6(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some3(span4));
var unsafeMakeSpan = /* @__PURE__ */ __name((fiber, name, options4) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options4.context && get6(options4.context, DisablePropagation);
  const context11 = fiber.getFiberRef(currentContext);
  const parent = options4.parent ? some3(options4.parent) : options4.root ? none2() : filterDisablePropagation(getOption2(context11, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add4(options4.context ?? empty9(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer4 = get6(services, tracerTag);
    const clock3 = get6(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options4.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options4.links ?? []] : toReadonlyArray(linksFromEnv.value) : options4.links ?? empty2();
    span4 = tracer4.span(name, parent, options4.context ?? empty9(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options4.kind ?? "internal", options4);
    if (annotationsFromEnv._tag === "Some") {
      forEach5(annotationsFromEnv.value, (value6, key) => span4.attribute(key, value6));
    }
    if (options4.attributes !== void 0) {
      Object.entries(options4.attributes).forEach(([k, v]) => span4.attribute(k, v));
    }
  }
  if (typeof options4.captureStackTrace === "function") {
    spanToTrace.set(span4, options4.captureStackTrace);
  }
  return span4;
}, "unsafeMakeSpan");
var makeSpan = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options4)));
}, "makeSpan");
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = /* @__PURE__ */ __name((span4, exit4, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit4);
}), "endSpan");
var useSpan = /* @__PURE__ */ __name((name, ...args2) => {
  const options4 = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate3 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options4);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get6(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span4), (exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  });
}, "useSpan");
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span4) => provideService(self2, spanTag, span4));
var withSpan = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options4, (span4) => withParentSpan(self2, span4));
  }
  return (self2) => useSpan(name, options4, (span4) => withParentSpan(self2, span4));
}, "withSpan");
var functionWithSpan = /* @__PURE__ */ __name((options4) => function() {
  let captureStackTrace = options4.captureStackTrace ?? false;
  if (options4.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error3 = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (error3.stack) {
        const stack = error3.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    }, "captureStackTrace");
  }
  return suspend(() => {
    const opts = typeof options4.options === "function" ? options4.options.apply(null, arguments) : options4.options;
    return withSpan(suspend(() => internalCall(() => options4.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
}, "functionWithSpan");
var fromNullable2 = /* @__PURE__ */ __name((value6) => value6 == null ? fail2(new NoSuchElementException()) : succeed(value6), "fromNullable");
var optionFromOptional = /* @__PURE__ */ __name((self2) => catchAll(map11(self2, some3), (error3) => isNoSuchElementException(error3) ? succeedNone : fail2(error3)), "optionFromOptional");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiber.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Exit.js
var Exit_exports = {};
__export(Exit_exports, {
  all: () => all4,
  as: () => as5,
  asVoid: () => asVoid3,
  causeOption: () => causeOption,
  die: () => die3,
  exists: () => exists2,
  fail: () => fail3,
  failCause: () => failCause3,
  flatMap: () => flatMap11,
  flatMapEffect: () => flatMapEffect,
  flatten: () => flatten7,
  forEachEffect: () => forEachEffect,
  fromEither: () => fromEither,
  fromOption: () => fromOption3,
  getOrElse: () => getOrElse5,
  interrupt: () => interrupt3,
  isExit: () => isExit,
  isFailure: () => isFailure3,
  isInterrupted: () => isInterrupted2,
  isSuccess: () => isSuccess2,
  map: () => map13,
  mapBoth: () => mapBoth3,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause2,
  match: () => match9,
  matchEffect: () => matchEffect2,
  succeed: () => succeed3,
  void: () => void_4,
  zip: () => zip4,
  zipLeft: () => zipLeft3,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParRight: () => zipParRight,
  zipRight: () => zipRight3,
  zipWith: () => zipWith5
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isExit = exitIsExit;
var isFailure3 = exitIsFailure;
var isSuccess2 = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var as5 = exitAs;
var asVoid3 = exitAsVoid;
var causeOption = exitCauseOption;
var all4 = exitCollectAll;
var die3 = exitDie;
var exists2 = exitExists;
var fail3 = exitFail;
var failCause3 = exitFailCause;
var flatMap11 = exitFlatMap;
var flatMapEffect = exitFlatMapEffect;
var flatten7 = exitFlatten;
var forEachEffect = exitForEachEffect;
var fromEither = exitFromEither;
var fromOption3 = exitFromOption;
var getOrElse5 = exitGetOrElse;
var interrupt3 = exitInterrupt;
var map13 = exitMap;
var mapBoth3 = exitMapBoth;
var mapError2 = exitMapError;
var mapErrorCause2 = exitMapErrorCause;
var match9 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_4 = exitVoid;
var zip4 = exitZip;
var zipLeft3 = exitZipLeft;
var zipRight3 = exitZipRight;
var zipPar = exitZipPar;
var zipParLeft = exitZipParLeft;
var zipParRight = exitZipParRight;
var zipWith5 = exitZipWith;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberScope.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberMessage.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
}), "interruptSignal");
var stateful = /* @__PURE__ */ __name((onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
}), "stateful");
var resume = /* @__PURE__ */ __name((effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
}), "resume");
var yieldNow3 = /* @__PURE__ */ __name(() => ({
  _tag: OP_YIELD_NOW
}), "yieldNow");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
__name(Global, "Global");
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId3, parent) {
    this.fiberId = fiberId3;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
__name(Local, "Local");
var unsafeMake7 = /* @__PURE__ */ __name((fiber) => {
  return new Local(fiber.id(), fiber);
}, "unsafeMake");
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var Order4 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple2(Order2, Order2), /* @__PURE__ */ mapInput3((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = /* @__PURE__ */ __name((u) => hasProperty(u, FiberTypeId), "isFiber");
var isRuntimeFiber = /* @__PURE__ */ __name((self2) => RuntimeFiberTypeId in self2, "isRuntimeFiber");
var _await = /* @__PURE__ */ __name((self2) => self2.await, "_await");
var children = /* @__PURE__ */ __name((self2) => self2.children, "children");
var done4 = /* @__PURE__ */ __name((exit4) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit4),
    children: succeed([]),
    inheritAll: void_2,
    poll: succeed(some3(exit4)),
    interruptAsFork: () => void_2
  };
  return _fiber;
}, "done");
var dump = /* @__PURE__ */ __name((self2) => map11(self2.status, (status3) => ({
  id: self2.id(),
  status: status3
})), "dump");
var dumpAll = /* @__PURE__ */ __name((fibers) => forEachSequential(fibers, dump), "dumpAll");
var fail4 = /* @__PURE__ */ __name((error3) => done4(fail3(error3)), "fail");
var failCause4 = /* @__PURE__ */ __name((cause3) => done4(failCause3(cause3)), "failCause");
var fromEffect = /* @__PURE__ */ __name((effect4) => map11(exit(effect4), done4), "fromEffect");
var id = /* @__PURE__ */ __name((self2) => self2.id(), "id");
var inheritAll = /* @__PURE__ */ __name((self2) => self2.inheritAll, "inheritAll");
var interrupted = /* @__PURE__ */ __name((fiberId3) => done4(interrupt3(fiberId3)), "interrupted");
var interruptAll = /* @__PURE__ */ __name((fibers) => flatMap9(fiberId, (fiberId3) => pipe(fibers, interruptAllAs(fiberId3))), "interruptAll");
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId3) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId3);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId3);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId3) => self2.interruptAsFork(fiberId3));
var join3 = /* @__PURE__ */ __name((self2) => zipLeft2(flatten6(self2.await), self2.inheritAll), "join");
var map14 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect(self2, (a) => sync(() => f(a))));
var mapEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => self2.id(),
    await: flatMap9(self2.await, forEachEffect(f)),
    children: self2.children,
    inheritAll: self2.inheritAll,
    poll: flatMap9(self2.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f), map11(some3));
      }
    }),
    interruptAsFork: (id3) => self2.interruptAsFork(id3)
  };
  return _fiber;
});
var mapFiber = /* @__PURE__ */ dual(2, (self2, f) => map11(self2.await, match9({
  onFailure: (cause3) => failCause4(cause3),
  onSuccess: (a) => f(a)
})));
var match10 = /* @__PURE__ */ dual(2, (self2, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self2)) {
    return onRuntimeFiber(self2);
  }
  return onFiber(self2);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var never2 = _never;
var orElse3 = /* @__PURE__ */ dual(2, (self2, that) => ({
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => getOrElse4(self2.id(), that.id()),
  await: zipWith4(self2.await, that.await, (exit1, exit22) => isSuccess2(exit1) ? exit1 : exit22),
  children: self2.children,
  inheritAll: zipRight2(that.inheritAll, self2.inheritAll),
  poll: zipWith4(self2.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess2(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id3) => pipe(interruptAsFiber(self2, id3), zipRight2(pipe(that, interruptAsFiber(id3))), asVoid2)
}));
var orElseEither2 = /* @__PURE__ */ dual(2, (self2, that) => orElse3(map14(self2, left2), map14(that, right2)));
var poll = /* @__PURE__ */ __name((self2) => self2.poll, "poll");
var parseMs = /* @__PURE__ */ __name((milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
}, "parseMs");
var renderStatus = /* @__PURE__ */ __name((status3) => {
  if (isDone2(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
}, "renderStatus");
var pretty2 = /* @__PURE__ */ __name((self2) => flatMap9(currentTimeMillis2, (now2) => map11(dump(self2), (dump3) => {
  const time2 = now2 - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time2);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size4(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id3) => `${id3}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
})), "pretty");
var unsafeRoots = /* @__PURE__ */ __name(() => Array.from(globalScope.roots), "unsafeRoots");
var roots = /* @__PURE__ */ sync(unsafeRoots);
var status = /* @__PURE__ */ __name((self2) => self2.status, "status");
var succeed4 = /* @__PURE__ */ __name((value6) => done4(succeed3(value6)), "succeed");
var void_5 = /* @__PURE__ */ succeed4(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = /* @__PURE__ */ __name(() => fromNullable(globalThis[currentFiberURI]), "getCurrentFiber");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/logger.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = /* @__PURE__ */ __name((log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
}), "makeLogger");
var mapInput4 = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => self2.log({
  ...options4,
  message: f(options4.message)
})));
var mapInputOptions = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => self2.log(f(options4))));
var filterLogLevel = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => f(options4.logLevel) ? some3(self2.log(options4)) : none2()));
var map15 = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => f(self2.log(options4))));
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var simple = /* @__PURE__ */ __name((log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log5(message),
  pipe() {
    return pipeArguments(this, arguments);
  }
}), "simple");
var succeed5 = /* @__PURE__ */ __name((value6) => {
  return simple(() => value6);
}, "succeed");
var sync3 = /* @__PURE__ */ __name((evaluate3) => {
  return simple(evaluate3);
}, "sync");
var zip5 = /* @__PURE__ */ dual(2, (self2, that) => makeLogger((options4) => [self2.log(options4), that.log(options4)]));
var zipLeft4 = /* @__PURE__ */ dual(2, (self2, that) => map15(zip5(self2, that), (tuple4) => tuple4[0]));
var zipRight4 = /* @__PURE__ */ dual(2, (self2, that) => map15(zip5(self2, that), (tuple4) => tuple4[1]));
var textOnly = /^[^\s"=]*$/;
var format3 = /* @__PURE__ */ __name((quoteValue, whitespace) => ({
  annotations: annotations3,
  cause: cause3,
  date: date4,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const formatValue = /* @__PURE__ */ __name((value6) => value6.match(textOnly) ? value6 : quoteValue(value6), "formatValue");
  const format8 = /* @__PURE__ */ __name((label, value6) => `${formatLabel(label)}=${formatValue(value6)}`, "format");
  const append6 = /* @__PURE__ */ __name((label, value6) => " " + format8(label, value6), "append");
  let out = format8("timestamp", date4.toISOString());
  out += append6("level", logLevel2.label);
  out += append6("fiber", threadName(fiberId3));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append6("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render(date4.getTime())(span4);
  }
  for (const [label, value6] of annotations3) {
    out += append6(label, toStringUnknown(value6, whitespace));
  }
  return out;
}, "format");
var escapeDoubleQuotes = /* @__PURE__ */ __name((s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, "escapeDoubleQuotes");
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var logfmtLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(JSON.stringify, 0));
var structuredLogger = /* @__PURE__ */ makeLogger(({
  annotations: annotations3,
  cause: cause3,
  date: date4,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const now2 = date4.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size6(annotations3) > 0) {
    for (const [k, v] of annotations3) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span4 of spans) {
      spansObj[span4.label] = now2 - span4.startTime;
    }
  }
  const messageArr = ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel2.label,
    timestamp: date4.toISOString(),
    cause: isEmpty3(cause3) ? void 0 : pretty(cause3, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId3)
  };
});
var structuredMessage = /* @__PURE__ */ __name((u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
}, "structuredMessage");
var jsonLogger = /* @__PURE__ */ map15(structuredLogger, stringifyCircular);
var isLogger = /* @__PURE__ */ __name((u) => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
}, "isLogger");
var withColor = /* @__PURE__ */ __name((text6, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text6 + "\x1B[0m";
}, "withColor");
var withColorNoop = /* @__PURE__ */ __name((text6, ..._colors) => text6, "withColorNoop");
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = /* @__PURE__ */ __name((date4) => `${date4.getHours().toString().padStart(2, "0")}:${date4.getMinutes().toString().padStart(2, "0")}:${date4.getSeconds().toString().padStart(2, "0")}.${date4.getMilliseconds().toString().padStart(3, "0")}`, "defaultDateFormat");
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = /* @__PURE__ */ __name((options4) => {
  const mode_ = options4?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options4?.colors === "boolean" ? options4.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = options4?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options4?.stderr === true
  });
}, "prettyLogger");
var prettyLoggerTty = /* @__PURE__ */ __name((options4) => {
  const color = options4.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations3,
    cause: cause3,
    context: context11,
    date: date4,
    fiberId: fiberId3,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context11, currentServices);
    const console4 = get6(services, consoleTag).unsafe;
    const log5 = options4.stderr === true ? console4.error : console4.log;
    const message = ensure(message_);
    let firstLine = color(`[${options4.formatDate(date4)}]`, colors.white) + ` ${color(logLevel2.label, ...logLevelColors[logLevel2._tag])} (${threadName(fiberId3)})`;
    if (isCons(spans)) {
      const now2 = date4.getTime();
      const render3 = render(now2);
      for (const span4 of spans) {
        firstLine += " " + render3(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log5(firstLine);
    console4.group();
    if (!isEmpty3(cause3)) {
      log5(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log5(redact(message[messageIndex]));
      }
    }
    if (size6(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        log5(color(`${key}:`, colors.bold, colors.white), redact(value6));
      }
    }
    console4.groupEnd();
  });
}, "prettyLoggerTty");
var prettyLoggerBrowser = /* @__PURE__ */ __name((options4) => {
  const color = options4.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations3,
    cause: cause3,
    context: context11,
    date: date4,
    fiberId: fiberId3,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context11, currentServices);
    const console4 = get6(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options4.formatDate(date4)}]`;
    const firstParams = [];
    if (options4.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel2.label}${color} (${threadName(fiberId3)})`;
    if (options4.colors) {
      firstParams.push(logLevelStyle[logLevel2._tag], "");
    }
    if (isCons(spans)) {
      const now2 = date4.getTime();
      const render3 = render(now2);
      for (const span4 of spans) {
        firstLine += " " + render3(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options4.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console4.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty3(cause3)) {
      console4.error(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console4.log(redact(message[messageIndex]));
      }
    }
    if (size6(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        const redacted2 = redact(value6);
        if (options4.colors) {
          console4.log(`%c${key}:`, "color:gray", redacted2);
        } else {
          console4.log(`${key}:`, redacted2);
        }
      }
    }
    console4.groupEnd();
  });
}, "prettyLoggerBrowser");
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/boundaries.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values6) {
    this.values = values6;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(MetricBoundariesImpl, "MetricBoundariesImpl");
var isMetricBoundaries = /* @__PURE__ */ __name((u) => hasProperty(u, MetricBoundariesTypeId), "isMetricBoundaries");
var fromIterable9 = /* @__PURE__ */ __name((iterable) => {
  const values6 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values6);
}, "fromIterable");
var exponential = /* @__PURE__ */ __name((options4) => pipe(makeBy(options4.count - 1, (i) => options4.start * Math.pow(options4.factor, i)), unsafeFromArray, fromIterable9), "exponential");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/key.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/keyType.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint3) {
    this.incremental = incremental;
    this.bigint = bigint3;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(CounterKeyType, "CounterKeyType");
var FrequencyKeyTypeHash = /* @__PURE__ */ string2(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol]() {
    return FrequencyKeyTypeHash;
  }
  [symbol2](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(FrequencyKeyType, "FrequencyKeyType");
var GaugeKeyTypeHash = /* @__PURE__ */ string2(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint3) {
    this.bigint = bigint3;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(GaugeKeyType, "GaugeKeyType");
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(HistogramKeyType, "HistogramKeyType");
var SummaryKeyType = class {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error3, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error3;
    this.quantiles = quantiles;
    this._hash = pipe(string2(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(SummaryKeyType, "SummaryKeyType");
var counter = /* @__PURE__ */ __name((options4) => new CounterKeyType(options4?.incremental ?? false, options4?.bigint ?? false), "counter");
var histogram = /* @__PURE__ */ __name((boundaries) => {
  return new HistogramKeyType(boundaries);
}, "histogram");
var isCounterKey = /* @__PURE__ */ __name((u) => hasProperty(u, CounterKeyTypeTypeId), "isCounterKey");
var isFrequencyKey = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyKeyTypeTypeId), "isFrequencyKey");
var isGaugeKey = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeKeyTypeTypeId), "isGaugeKey");
var isHistogramKey = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramKeyTypeTypeId), "isHistogramKey");
var isSummaryKey = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryKeyTypeTypeId), "isSummaryKey");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence4(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags3 = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags3;
    this._hash = pipe(string2(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(MetricKeyImpl, "MetricKeyImpl");
var isMetricKey = /* @__PURE__ */ __name((u) => hasProperty(u, MetricKeyTypeId), "isMetricKey");
var counter2 = /* @__PURE__ */ __name((name, options4) => new MetricKeyImpl(name, counter(options4), fromNullable(options4?.description)), "counter");
var histogram2 = /* @__PURE__ */ __name((name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description)), "histogram");
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/registry.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableHashMap.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
};
__name(MutableHashMapIterator, "MutableHashMapIterator");
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
__name(BucketIterator, "BucketIterator");
var empty22 = /* @__PURE__ */ __name(() => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = /* @__PURE__ */ new Map();
  self2.buckets = /* @__PURE__ */ new Map();
  self2.bucketsSize = 0;
  return self2;
}, "empty");
var get13 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some3(self2.referential.get(key)) : none2();
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = /* @__PURE__ */ __name((self2, bucket, key, remove15 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value6 = bucket[i][1];
      if (remove15) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some3(value6);
    }
  }
  return none2();
}, "getFromBucket");
var has6 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get13(self2, key)));
var set6 = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value6);
    return self2;
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    self2.buckets.set(hash5, [[key, value6]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value6]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = /* @__PURE__ */ __name((self2, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
}, "removeFromBucket");
var remove7 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash5);
  }
  return self2;
});
var size7 = /* @__PURE__ */ __name((self2) => {
  return self2.referential.size + self2.bucketsSize;
}, "size");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/hook.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/state.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count4) {
    this.count = count4;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(CounterState, "CounterState");
var arrayEquals = /* @__PURE__ */ getEquivalence4(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string2(FrequencyStateSymbolKey), combine(array2(fromIterable2(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(FrequencyState, "FrequencyState");
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value6) {
    this.value = value6;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(GaugeState, "GaugeState");
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count4, min5, max8, sum3) {
    this.buckets = buckets;
    this.count = count4;
    this.min = min5;
    this.max = max8;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(HistogramState, "HistogramState");
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error3, quantiles, count4, min5, max8, sum3) {
    this.error = error3;
    this.quantiles = quantiles;
    this.count = count4;
    this.min = min5;
    this.max = max8;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(SummaryState, "SummaryState");
var counter3 = /* @__PURE__ */ __name((count4) => new CounterState(count4), "counter");
var frequency2 = /* @__PURE__ */ __name((occurrences) => {
  return new FrequencyState(occurrences);
}, "frequency");
var gauge2 = /* @__PURE__ */ __name((count4) => new GaugeState(count4), "gauge");
var histogram3 = /* @__PURE__ */ __name((options4) => new HistogramState(options4.buckets, options4.count, options4.min, options4.max, options4.sum), "histogram");
var summary2 = /* @__PURE__ */ __name((options4) => new SummaryState(options4.error, options4.quantiles, options4.count, options4.min, options4.max, options4.sum), "summary");
var isCounterState = /* @__PURE__ */ __name((u) => hasProperty(u, CounterStateTypeId), "isCounterState");
var isFrequencyState = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyStateTypeId), "isFrequencyState");
var isGaugeState = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeStateTypeId), "isGaugeState");
var isHistogramState = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramStateTypeId), "isHistogramState");
var isSummaryState = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryStateTypeId), "isSummaryState");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make30 = /* @__PURE__ */ __name((options4) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options4
}), "make");
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = /* @__PURE__ */ __name((key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value6) => value6 >= bigint03 : (value6) => value6 >= 0 : (_value) => true;
  const update6 = /* @__PURE__ */ __name((value6) => {
    if (canUpdate(value6)) {
      sum3 = sum3 + value6;
    }
  }, "update");
  return make30({
    get: () => counter3(sum3),
    update: update6,
    modify: update6
  });
}, "counter");
var frequency3 = /* @__PURE__ */ __name((key) => {
  const values6 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values6.set(word, 0);
  }
  const update6 = /* @__PURE__ */ __name((word) => {
    const slotCount = values6.get(word) ?? 0;
    values6.set(word, slotCount + 1);
  }, "update");
  return make30({
    get: () => frequency2(values6),
    update: update6,
    modify: update6
  });
}, "frequency");
var gauge3 = /* @__PURE__ */ __name((_key, startAt) => {
  let value6 = startAt;
  return make30({
    get: () => gauge2(value6),
    update: (v) => {
      value6 = v;
    },
    modify: (v) => {
      value6 = value6 + v;
    }
  });
}, "gauge");
var histogram4 = /* @__PURE__ */ __name((key) => {
  const bounds = key.keyType.boundaries.values;
  const size18 = bounds.length;
  const values6 = new Uint32Array(size18 + 1);
  const boundaries = new Float64Array(size18);
  let count4 = 0;
  let sum3 = 0;
  let min5 = Number.MAX_VALUE;
  let max8 = Number.MIN_VALUE;
  pipe(bounds, sort(Order2), map4((n, i) => {
    boundaries[i] = n;
  }));
  const update6 = /* @__PURE__ */ __name((value6) => {
    let from = 0;
    let to = size18;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value6 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value6 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values6[from] = values6[from] + 1;
    count4 = count4 + 1;
    sum3 = sum3 + value6;
    if (value6 < min5) {
      min5 = value6;
    }
    if (value6 > max8) {
      max8 = value6;
    }
  }, "update");
  const getBuckets = /* @__PURE__ */ __name(() => {
    const builder = allocate(size18);
    let cumulated = 0;
    for (let i = 0; i < size18; i++) {
      const boundary = boundaries[i];
      const value6 = values6[i];
      cumulated = cumulated + value6;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  }, "getBuckets");
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count4,
      min: min5,
      max: max8,
      sum: sum3
    }),
    update: update6,
    modify: update6
  });
}, "histogram");
var summary3 = /* @__PURE__ */ __name((key) => {
  const {
    error: error3,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order2));
  const values6 = allocate(maxSize);
  let head10 = 0;
  let count4 = 0;
  let sum3 = 0;
  let min5 = 0;
  let max8 = 0;
  const snapshot2 = /* @__PURE__ */ __name((now2) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values6[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now2 - t);
        if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error3, sortedQuantiles, sort(builder, Order2));
  }, "snapshot");
  const observe = /* @__PURE__ */ __name((value6, timestamp) => {
    if (maxSize > 0) {
      head10 = head10 + 1;
      const target2 = head10 % maxSize;
      values6[target2] = [timestamp, value6];
    }
    min5 = count4 === 0 ? value6 : Math.min(min5, value6);
    max8 = count4 === 0 ? value6 : Math.max(max8, value6);
    count4 = count4 + 1;
    sum3 = sum3 + value6;
  }, "observe");
  return make30({
    get: () => summary2({
      error: error3,
      quantiles: snapshot2(Date.now()),
      count: count4,
      min: min5,
      max: max8,
      sum: sum3
    }),
    update: ([value6, timestamp]) => observe(value6, timestamp),
    modify: ([value6, timestamp]) => observe(value6, timestamp)
  });
}, "summary");
var calculateQuantiles = /* @__PURE__ */ __name((error3, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head10 = sortedQuantiles[0];
  const tail2 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error3, sampleCount, none2(), 0, head10, sortedSamples);
  const resolved = of(resolvedHead);
  tail2.forEach((quantile) => {
    resolved.push(resolveQuantile(error3, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map4(resolved, (rq) => [rq.quantile, rq.value]);
}, "calculateQuantiles");
var resolveQuantile = /* @__PURE__ */ __name((error3, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error3;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error3;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some3(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some3(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some3(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "resolveQuantile");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/pair.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var unsafeMake8 = /* @__PURE__ */ __name((metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
}, "unsafeMake");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty22();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake8(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get13(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined);
    if (value6 == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value6 = counter6;
    }
    return value6;
  }
  getFrequency(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined);
    if (value6 == null) {
      const frequency6 = frequency3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, frequency6));
      }
      value6 = frequency6;
    }
    return value6;
  }
  getGauge(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined);
    if (value6 == null) {
      const gauge6 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, gauge6));
      }
      value6 = gauge6;
    }
    return value6;
  }
  getHistogram(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined);
    if (value6 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value6 = histogram6;
    }
    return value6;
  }
  getSummary(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined);
    if (value6 == null) {
      const summary6 = summary3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, summary6));
      }
      value6 = summary6;
    }
    return value6;
  }
};
__name(MetricRegistryImpl, "MetricRegistryImpl");
var make31 = /* @__PURE__ */ __name(() => {
  return new MetricRegistryImpl();
}, "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = /* @__PURE__ */ __name(function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
}, "make");
var counter5 = /* @__PURE__ */ __name((name, options4) => fromMetricKey(counter2(name, options4)), "counter");
var fromMetricKey = /* @__PURE__ */ __name((key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = /* @__PURE__ */ __name((extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  }, "hook");
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
}, "fromMetricKey");
var histogram5 = /* @__PURE__ */ __name((name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description)), "histogram");
var tagged = /* @__PURE__ */ dual(3, (self2, key, value6) => taggedWithLabels2(self2, [make29(key, value6)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make32(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self2.unsafeUpdate(input, tags3))));
var unsafeSnapshot = /* @__PURE__ */ __name(() => globalMetricRegistry.snapshot(), "unsafeSnapshot");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/request.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = /* @__PURE__ */ __name((u) => hasProperty(u, RequestTypeId), "isRequest");
var Class3 = /* @__PURE__ */ function() {
  function Class7(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  __name(Class7, "Class");
  Class7.prototype = RequestPrototype;
  return Class7;
}();
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map33) => sync(() => {
  if (map33.has(self2)) {
    const entry = map33.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var Listeners = class {
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};
__name(Listeners, "Listeners");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/SortedSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RedBlackTree.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class {
  self;
  stack;
  direction;
  count = 0;
  constructor(self2, stack, direction) {
    this.self = self2;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};
__name(RedBlackTreeIterator, "RedBlackTreeIterator");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree/node.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = /* @__PURE__ */ __name(({
  color,
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value6
}) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count4
}), "clone");
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
__name(swap2, "swap");
var repaint = /* @__PURE__ */ __name(({
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value6
}, color) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count4
}), "repaint");
var recount = /* @__PURE__ */ __name((node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
}, "recount");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash5 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash5 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash5);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = /* @__PURE__ */ __name((ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
}, "makeImpl");
var isRedBlackTree = /* @__PURE__ */ __name((u) => hasProperty(u, RedBlackTreeTypeId), "isRedBlackTree");
var empty23 = /* @__PURE__ */ __name((ord) => makeImpl3(ord, void 0), "empty");
var fromIterable10 = /* @__PURE__ */ dual(2, (entries3, ord) => {
  let tree = empty23(ord);
  for (const [key, value6] of entries3) {
    tree = insert(tree, key, value6);
  }
  return tree;
});
var findFirst7 = /* @__PURE__ */ dual(2, (self2, key) => {
  const cmp = self2._ord;
  let node = self2._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some3(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has7 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(findFirst7(self2, key)));
var insert = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  const cmp = self2._ord;
  let n = self2._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value6,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self2._ord, n_stack[0]);
});
var keysForward = /* @__PURE__ */ __name((self2) => keys4(self2, Direction.Forward), "keysForward");
var keys4 = /* @__PURE__ */ __name((self2, direction) => {
  const begin = self2[Symbol.iterator]();
  let count4 = 0;
  return {
    [Symbol.iterator]: () => keys4(self2, direction),
    next: () => {
      count4++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count4
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
}, "keys");
var removeFirst = /* @__PURE__ */ dual(2, (self2, key) => {
  if (!has7(self2, key)) {
    return self2;
  }
  const ord = self2._ord;
  const cmp = ord;
  let node = self2._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self2;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split5 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split5 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split5 - 1].key = n.key;
    cstack[split5 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split5; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split5 - 1].left = cstack[split5];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var fixDoubleBlack = /* @__PURE__ */ __name((stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone(s);
        z = s.right = clone(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone(s);
        z = s.left = clone(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone(s);
        z = s.left = clone(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone(s);
        z = s.right = clone(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}, "fixDoubleBlack");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RedBlackTree.js
var fromIterable11 = fromIterable10;
var has8 = has7;
var insert2 = insert;
var keys5 = keysForward;
var removeFirst2 = removeFirst;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/SortedSet.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId13]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId13)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = /* @__PURE__ */ __name((keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
}, "fromTree");
var isSortedSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId13), "isSortedSet");
var fromIterable12 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable11(Array.from(iterable).map((k) => [k, true]), ord)));
var add5 = /* @__PURE__ */ dual(2, (self2, value6) => has8(self2.keyTree, value6) ? self2 : fromTree(insert2(self2.keyTree, value6, true)));
var every9 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const value6 of self2) {
    if (!predicate(value6)) {
      return false;
    }
  }
  return true;
});
var has9 = /* @__PURE__ */ dual(2, (self2, value6) => has8(self2.keyTree, value6));
var isSubset3 = /* @__PURE__ */ dual(2, (self2, that) => every9(self2, (a) => has9(that, a)));
var remove8 = /* @__PURE__ */ dual(2, (self2, value6) => fromTree(removeFirst2(self2.keyTree, value6)));
var values5 = /* @__PURE__ */ __name((self2) => keys5(self2.keyTree), "values");
var getEquivalence7 = /* @__PURE__ */ __name(() => (a, b) => isSubset3(a, b) && isSubset3(b, a), "getEquivalence");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var ProxySupervisor = class {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context11, effect4, parent, fiber) {
    this.underlying.onStart(context11, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.underlying.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
__name(ProxySupervisor, "ProxySupervisor");
var Zip = class {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip3(this.left.value, this.right.value);
  }
  onStart(context11, effect4, parent, fiber) {
    this.left.onStart(context11, effect4, parent, fiber);
    this.right.onStart(context11, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.left.onEnd(value6, fiber);
    this.right.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
__name(Zip, "Zip");
var isZip = /* @__PURE__ */ __name((self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip"), "isZip");
var Track = class {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
__name(Track, "Track");
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect4) {
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
__name(Const, "Const");
var FibersIn = class {
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync(() => get7(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get7(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set2(pipe(get7(this.ref), remove8(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
__name(FibersIn, "FibersIn");
var unsafeTrack = /* @__PURE__ */ __name(() => {
  return new Track();
}, "unsafeTrack");
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect2 = /* @__PURE__ */ __name((effect4) => {
  return new Const(effect4);
}, "fromEffect");
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect2(void_2));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor/patch.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Differ.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make34 = make16;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty25 = {
  _tag: OP_EMPTY3
};
var combine8 = /* @__PURE__ */ __name((self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
}, "combine");
var patch8 = /* @__PURE__ */ __name((self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
}, "patch");
var patchLoop = /* @__PURE__ */ __name((_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head10 = headNonEmpty2(patches);
    switch (head10._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head10.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head10.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head10.first)(prepend2(head10.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
}, "patchLoop");
var removeSupervisor = /* @__PURE__ */ __name((self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
}, "removeSupervisor");
var toSet2 = /* @__PURE__ */ __name((self2) => {
  if (equals(self2, none8)) {
    return empty6();
  } else {
    if (isZip(self2)) {
      return pipe(toSet2(self2.left), union5(toSet2(self2.right)));
    } else {
      return make8(self2);
    }
  }
}, "toSet");
var diff7 = /* @__PURE__ */ __name((oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty25;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference4(oldSupervisors), reduce5(empty25, (patch12, supervisor) => combine8(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference4(newSupervisors), reduce5(empty25, (patch12, supervisor) => combine8(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
}, "diff");
var differ2 = /* @__PURE__ */ make34({
  empty: empty25,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd = /* @__PURE__ */ __name((_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
}, "absurd");
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i1(value6));
  },
  ["OnStep"]: (_, _cont, value6) => {
    return exitSucceed(exitSucceed(value6));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i2(value6));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value6) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value6);
    }
  },
  [OP_WHILE]: (self2, cont, value6) => {
    internalCall(() => cont.effect_instruction_i2(value6));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_2;
    }
  },
  [OP_ITERATOR]: (self2, cont, value6) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value6));
    if (state.done)
      return exitSucceed(state.value);
    self2.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap9(yieldNow(), () => cur);
  }
};
var runBlockedRequests = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(flatten5(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map33 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map33.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map33);
}, false, false)), "runBlockedRequests");
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId3, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId3;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags3);
      fiberActive.unsafeUpdate(1, tags3);
    }
    this.refreshRefCache();
  }
  commit() {
    return join3(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status3) => {
      if (isDone2(status3)) {
        return state.currentRuntimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake7(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = /* @__PURE__ */ __name((exit4) => resume2(succeed(exit4)), "cb");
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch12);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId3) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId3))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId3) {
    this.tell(interruptSignal(interrupt(fiberId3)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value6) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value6
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children3 = this._children;
    this._children = null;
    if (children3 !== null && children3.size > 0) {
      for (const child of children3) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone7 = false;
      const body = /* @__PURE__ */ __name(() => {
        const next = it.next();
        if (!next.done) {
          return asVoid2(next.value.await);
        } else {
          return sync(() => {
            isDone7 = true;
          });
        }
      }, "body");
      return whileLoop({
        while: () => !isDone7,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags3);
      fiberActive.unsafeUpdate(-1, tags3);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags3);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags3);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel3 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel3, logLevel2)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations3 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size4(loggers) > 0) {
      const clockService = get6(this.getFiberRef(currentServices), clockTag);
      const date4 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger3 of loggers) {
          logger3.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations: annotations3,
            date: date4
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done3 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect4 = flatMap9(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = /* @__PURE__ */ __name((effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    }, "callback");
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet5(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = /* @__PURE__ */ __name((_) => {
          abortResume(void_2);
        }, "resume");
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value6 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value6);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value6);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap9(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check3 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check3()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap9(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty7, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
__name(FiberRuntime, "FiberRuntime");
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get6(services, consoleTag).unsafe.log(self2.log(opts));
}), "loggerWithConsoleLog");
var loggerWithLeveledLog = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  const unsafeLogger = get6(services, consoleTag).unsafe;
  switch (opts.logLevel._tag) {
    case "Debug":
      return unsafeLogger.debug(self2.log(opts));
    case "Info":
      return unsafeLogger.info(self2.log(opts));
    case "Trace":
      return unsafeLogger.trace(self2.log(opts));
    case "Warning":
      return unsafeLogger.warn(self2.log(opts));
    case "Error":
    case "Fatal":
      return unsafeLogger.error(self2.log(opts));
    default:
      return unsafeLogger.log(self2.log(opts));
  }
}), "loggerWithLeveledLog");
var loggerWithConsoleError = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get6(services, consoleTag).unsafe.error(self2.log(opts));
}), "loggerWithConsoleError");
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var prettyLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/prettyLogger"), () => prettyLoggerDefault);
var structuredLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations3,
  cause: cause3,
  context: context11,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message
}) => {
  const span4 = getOption2(getOrDefault(context11, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet5(getOrDefault(context11, currentServices), clockTag);
  const attributes = {};
  for (const [key, value6] of annotations3) {
    attributes[key] = value6;
  }
  attributes["effect.fiberId"] = threadName2(fiberId3);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var loggerWithSpanAnnotations = /* @__PURE__ */ __name((self2) => mapInputOptions(self2, (options4) => {
  const span4 = flatMap(get9(options4.context, currentContext), getOption2(spanTag));
  if (span4._tag === "None") {
    return options4;
  }
  return {
    ...options4,
    annotations: pipe(options4.annotations, set3("effect.traceId", span4.value.traceId), set3("effect.spanId", span4.value.spanId), span4.value._tag === "Span" ? set3("effect.spanName", span4.value.name) : identity)
  };
}), "loggerWithSpanAnnotations");
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make8(defaultLogger, tracerLogger)));
var batchedLogger = /* @__PURE__ */ dual(3, (self2, window2, f) => flatMap9(scope, (scope5) => {
  let buffer4 = [];
  const flush = suspend(() => {
    if (buffer4.length === 0) {
      return void_2;
    }
    const arr = buffer4;
    buffer4 = [];
    return f(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window2), zipRight2(flush), forever, restore, forkDaemon, flatMap9((fiber) => scopeAddFinalizer(scope5, interruptFiber(fiber))), zipRight2(addFinalizer(() => flush)), as3(makeLogger((options4) => {
    buffer4.push(self2.log(options4));
  }))));
}));
var annotateLogsScoped = /* @__PURE__ */ __name(function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate4((annotations3) => {
    for (let i = 0; i < entries3.length; i++) {
      const [key, value6] = entries3[i];
      set3(annotations3, key, value6);
    }
    return annotations3;
  }));
}, "annotateLogsScoped");
var whenLogLevel = /* @__PURE__ */ dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel3 = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel3, requiredLogLevel)) {
      return succeed(none2());
    }
    return map11(effect4, some3);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap2(acquire, (a) => addFinalizer((exit4) => release(a, exit4)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit4) => release(exit4))));
var addFinalizer = /* @__PURE__ */ __name((finalizer3) => withFiberRuntime((runtime6) => {
  const acquireRefs = runtime6.getFiberRefs();
  const acquireFlags = disable2(runtime6.currentRuntimeFlags, Interruption);
  return flatMap9(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer3(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
}), "addFinalizer");
var daemonChildren = /* @__PURE__ */ __name((self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some3(globalScope));
  return forkScope(self2);
}, "daemonChildren");
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options4) => matchSimple(options4?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach9(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_2
}), options4), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = /* @__PURE__ */ __name((iterator, index2, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return flatMap9(f(next.value, index2), (b) => b ? succeed(b) : existsLoop(iterator, index2 + 1, f));
}, "existsLoop");
var filter9 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options4) => {
  const predicate_ = options4?.negate ? (a, i) => map11(predicate(a, i), not2) : predicate;
  return matchSimple(options4?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith4(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map11(forEach9(elements, (a, i) => map11(predicate_(a, i), (b) => b ? some3(a) : none2()), options4), getSomes));
});
var allResolveInput = /* @__PURE__ */ __name((input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys6 = Object.keys(input);
  const size18 = keys6.length;
  return [keys6.map((k) => input[k]), some3((values6) => {
    const res = {};
    for (let i = 0; i < size18; i++) {
      ;
      res[keys6[i]] = values6[i];
    }
    return res;
  })];
}, "allResolveInput");
var allValidate = /* @__PURE__ */ __name((effects, reconcile, options4) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  return flatMap9(forEach9(eitherEffects, identity, {
    concurrency: options4?.concurrency,
    batching: options4?.batching,
    concurrentFinalizers: options4?.concurrentFinalizers
  }), (eithers) => {
    const none11 = none2();
    const size18 = eithers.length;
    const errors3 = new Array(size18);
    const successes = new Array(size18);
    let errored = false;
    for (let i = 0; i < size18; i++) {
      const either9 = eithers[i];
      if (either9._tag === "Left") {
        errors3[i] = some3(either9.left);
        errored = true;
      } else {
        successes[i] = either9.right;
        errors3[i] = none11;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors3)) : fail2(errors3);
    } else if (options4?.discard) {
      return void_2;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
}, "allValidate");
var allEither = /* @__PURE__ */ __name((effects, reconcile, options4) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  if (options4?.discard) {
    return forEach9(eitherEffects, identity, {
      concurrency: options4?.concurrency,
      batching: options4?.batching,
      discard: true,
      concurrentFinalizers: options4?.concurrentFinalizers
    });
  }
  return map11(forEach9(eitherEffects, identity, {
    concurrency: options4?.concurrency,
    batching: options4?.batching,
    concurrentFinalizers: options4?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
}, "allEither");
var all5 = /* @__PURE__ */ __name((arg, options4) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options4?.mode === "validate") {
    return allValidate(effects, reconcile, options4);
  } else if (options4?.mode === "either") {
    return allEither(effects, reconcile, options4);
  }
  return options4?.discard !== true && reconcile._tag === "Some" ? map11(forEach9(effects, identity, options4), reconcile.value) : forEach9(effects, identity, options4);
}, "all");
var allWith = /* @__PURE__ */ __name((options4) => (arg) => all5(arg, options4), "allWith");
var allSuccesses = /* @__PURE__ */ __name((elements, options4) => map11(all5(fromIterable2(elements).map(exit), options4), filterMap2((exit4) => exitIsSuccess(exit4) ? some3(exit4.effect_instruction_i0) : none2())), "allSuccesses");
var replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options4) => all5(replicate(self2, n), options4));
var forEach9 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options4) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options4?.batching === true || options4?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options4?.discard) {
    return match7(options4.concurrency, () => finalizersMaskInternal(sequential3, options4?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options4?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options4?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options4?.concurrency, () => finalizersMaskInternal(sequential3, options4?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options4?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options4?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = /* @__PURE__ */ __name((self2, f, batching) => suspend(() => {
  const as14 = fromIterable2(self2);
  const array6 = new Array(as14.length);
  const fn2 = /* @__PURE__ */ __name((a, i) => flatMap9(f(a, i), (b) => sync(() => array6[i] = b)), "fn");
  return zipRight2(forEachConcurrentDiscard(as14, fn2, batching, false), succeed(array6));
}), "forEachParUnbounded");
var forEachConcurrentDiscard = /* @__PURE__ */ __name((self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target2 = todos.length;
  if (target2 === 0) {
    return void_2;
  }
  let counter6 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = /* @__PURE__ */ __name(() => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  }), "interruptAll");
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = /* @__PURE__ */ __name(() => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  }, "collectExits");
  const runFiber = /* @__PURE__ */ __name((eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  }, "runFiber");
  const onInterruptSignal = /* @__PURE__ */ __name(() => {
    if (!processAll) {
      target2 -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  }, "onInterruptSignal");
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = /* @__PURE__ */ __name((res, index2) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index: index2,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    }, "pushResult");
    const next = /* @__PURE__ */ __name(() => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index2 = counter6++;
        const returnNextElement = /* @__PURE__ */ __name(() => {
          const a2 = todos.pop();
          index2 = counter6++;
          return flatMap9(yieldNow(), () => flatMap9(stepOrExit(restore(f(a2, index2))), onRes));
        }, "returnNextElement");
        const onRes = /* @__PURE__ */ __name((res) => {
          if (todos.length > 0) {
            pushResult(res, index2);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        }, "onRes");
        const todo = flatMap9(stepOrExit(restore(f(a, index2))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted4) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit4, index2);
          if (results.length === target2) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target2) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    }, "next");
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid2(onExit(flatten6(restore(join3(processingFiber))), exitMatch({
    onFailure: (cause3) => {
      onInterruptSignal();
      const target3 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count4 = 0;
        let index2 = 0;
        const check3 = /* @__PURE__ */ __name((index3, hitNext) => (exit4) => {
          exits[index3] = exit4;
          count4++;
          if (count4 === target3) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        }, "check");
        const next = /* @__PURE__ */ __name(() => {
          runFiber(toPop.pop(), true).addObserver(check3(index2, true));
          index2++;
        }, "next");
        processingFiber.addObserver(check3(index2, false));
        index2++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
}))), "forEachConcurrentDiscard");
var forEachParN = /* @__PURE__ */ __name((self2, n, f, batching) => suspend(() => {
  const as14 = fromIterable2(self2);
  const array6 = new Array(as14.length);
  const fn2 = /* @__PURE__ */ __name((a, i) => map11(f(a, i), (b) => array6[i] = b), "fn");
  return zipRight2(forEachConcurrentDiscard(as14, fn2, batching, false, n), succeed(array6));
}), "forEachParN");
var fork = /* @__PURE__ */ __name((self2) => withFiberRuntime((state, status3) => succeed(unsafeFork2(self2, state, status3.runtimeFlags))), "fork");
var forkDaemon = /* @__PURE__ */ __name((self2) => forkWithScopeOverride(self2, globalScope), "forkDaemon");
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause3) => {
  const either9 = failureOrCause(cause3);
  switch (either9._tag) {
    case "Left":
      return handler(either9.left);
    case "Right":
      return failCause(either9.right);
  }
})));
var unsafeFork2 = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
}, "unsafeFork");
var unsafeForkUnstarted = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
}, "unsafeForkUnstarted");
var unsafeMakeChildFiber = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some3(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
}, "unsafeMakeChildFiber");
var forkWithScopeOverride = /* @__PURE__ */ __name((self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride))), "forkWithScopeOverride");
var mergeAll2 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options4) => matchSimple(options4?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap9(make25(zero3), (acc) => flatMap9(forEach9(elements, (effect4, i) => flatMap9(effect4, (a) => update3(acc, (b) => f(b, a, i))), options4), () => get12(acc)))));
var partition5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => pipe(forEach9(elements, (a, i) => either2(f(a, i)), options4), map11((chunk4) => partitionMap4(chunk4, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => flatMap9(partition5(elements, f, {
  concurrency: options4?.concurrency,
  batching: options4?.batching,
  concurrentFinalizers: options4?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options4?.discard ? void_2 : succeed(bs)));
var raceAll = /* @__PURE__ */ __name((all12) => withFiberRuntime((state, status3) => async_((resume2) => {
  const fibers = /* @__PURE__ */ new Set();
  let winner;
  let failures3 = empty7;
  const interruptAll3 = /* @__PURE__ */ __name(() => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state.id());
    }
  }, "interruptAll");
  let latch = false;
  let empty44 = true;
  for (const self2 of all12) {
    empty44 = false;
    const fiber = unsafeFork2(interruptible2(self2), state, status3.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit4) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit4._tag === "Success") {
          latch = true;
          winner = fiber;
          failures3 = empty7;
          interruptAll3();
        } else {
          failures3 = parallel(exit4.cause, failures3);
        }
      }
      if (latch && fibers.size === 0) {
        resume2(winner ? zipRight2(inheritAll(winner), winner.unsafePoll()) : failCause(failures3));
      }
    });
    if (winner)
      break;
  }
  if (empty44) {
    return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs(fibers, state.id());
})), "raceAll");
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options4) => matchSimple(options4?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll2([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some3(elem);
    }
    case "Some": {
      return some3(f(acc.value, elem, i));
    }
  }
}, options4), map11((option7) => {
  switch (option7._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option7.value;
    }
  }
})))));
var parallelFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context11) => match2(getOption2(context11, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap9(scopeFork(scope5, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
})), "parallelFinalizers");
var parallelNFinalizers = /* @__PURE__ */ __name((parallelism) => (self2) => contextWithEffect((context11) => match2(getOption2(context11, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap9(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
})), "parallelNFinalizers");
var finalizersMask = /* @__PURE__ */ __name((strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2), "finalizersMask");
var finalizersMaskInternal = /* @__PURE__ */ __name((strategy, concurrentFinalizers) => (self2) => contextWithEffect((context11) => match2(getOption2(context11, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope5) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch12(self2(parallelFinalizers));
        case "Sequential":
          return patch12(self2(sequentialFinalizers));
        case "ParallelN":
          return patch12(self2(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
})), "finalizersMaskInternal");
var scopeWith = /* @__PURE__ */ __name((f) => flatMap9(scopeTag, f), "scopeWith");
var scopedWith = /* @__PURE__ */ __name((f) => flatMap9(scopeMake(), (scope5) => onExit(f(scope5), (exit4) => scope5.close(exit4))), "scopedWith");
var scopedEffect = /* @__PURE__ */ __name((effect4) => flatMap9(scopeMake(), (scope5) => scopeUse(effect4, scope5)), "scopedEffect");
var sequentialFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context11) => match2(getOption2(context11, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap9(scopeFork(scope5, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
})), "sequentialFinalizers");
var tagMetricsScoped = /* @__PURE__ */ __name((key, value6) => labelMetricsScoped([make29(key, value6)]), "tagMetricsScoped");
var labelMetricsScoped = /* @__PURE__ */ __name((labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels)), "labelMetricsScoped");
var using = /* @__PURE__ */ dual(2, (self2, use3) => scopedWith((scope5) => flatMap9(scopeExtend(self2, scope5), use3)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => validateWith(self2, that, (a, b) => [a, b], options4));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options4) => flatten6(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options4?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options4)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => flip(forEach9(elements, (a, i) => flip(f(a, i)), options4)));
var withClockScoped = /* @__PURE__ */ __name((c) => fiberRefLocallyScopedWith(currentServices, add4(clockTag, c)), "withClockScoped");
var withRandomScoped = /* @__PURE__ */ __name((value6) => fiberRefLocallyScopedWith(currentServices, add4(randomTag, value6)), "withRandomScoped");
var withConfigProviderScoped = /* @__PURE__ */ __name((provider) => fiberRefLocallyScopedWith(currentServices, add4(configProviderTag, provider)), "withConfigProviderScoped");
var withEarlyRelease = /* @__PURE__ */ __name((self2) => scopeWith((parent) => flatMap9(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map11((value6) => [fiberIdWith((fiberId3) => scopeClose(child, exitInterrupt(fiberId3))), value6])))), "withEarlyRelease");
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => zipWithOptions(self2, that, (a, b) => [a, b], options4));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => {
  if (options4?.concurrent !== true && (options4?.batching === void 0 || options4.batching === false)) {
    return zipLeft2(self2, that);
  }
  return zipWithOptions(self2, that, (a, _) => a, options4);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => {
  if (options4?.concurrent !== true && (options4?.batching === void 0 || options4.batching === false)) {
    return zipRight2(self2, that);
  }
  return zipWithOptions(self2, that, (_, b) => b, options4);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options4) => map11(all5([self2, that], {
  concurrency: options4?.concurrent ? 2 : 1,
  batching: options4?.batching,
  concurrentFinalizers: options4?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = /* @__PURE__ */ __name((update6) => {
  if (update6 === empty16) {
    return void_2;
  }
  return pipe(runtimeFlags, flatMap9((runtimeFlags2) => {
    const updatedRuntimeFlags = patch4(runtimeFlags2, update6);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update6), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
}, "withRuntimeFlagsScoped");
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = /* @__PURE__ */ __name((scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
}, "scopeUnsafeAddFinalizer");
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = /* @__PURE__ */ __name((exit4) => newScope.close(exit4), "fin");
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_2;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_2;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap9((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap9((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap9((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_2;
    });
  }
};
var scopeUnsafeMake = /* @__PURE__ */ __name((strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
}, "scopeUnsafeMake");
var scopeMake = /* @__PURE__ */ __name((strategy = sequential2) => sync(() => scopeUnsafeMake(strategy)), "scopeMake");
var scopeExtend = /* @__PURE__ */ dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make10(scopeTag, scope5))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit4) => scope5.close(exit4))));
var fiberRefUnsafeMakeSupervisor = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty25
}), "fiberRefUnsafeMakeSupervisor");
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value6) => asVoid2(acquireRelease(flatMap9(fiberRefGet(self2), (oldValue) => as3(fiberRefSet(self2, value6), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var fiberRefMake = /* @__PURE__ */ __name((initial, options4) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options4)), "fiberRefMake");
var fiberRefMakeWith = /* @__PURE__ */ __name((ref) => acquireRelease(tap2(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef)), "fiberRefMakeWith");
var fiberRefMakeContext = /* @__PURE__ */ __name((initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial)), "fiberRefMakeContext");
var fiberRefMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial)), "fiberRefMakeRuntimeFlags");
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = /* @__PURE__ */ __name((fibers) => forEach9(fibers, _await), "fiberAwaitAll");
var fiberAll = /* @__PURE__ */ __name((fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable2(fibers).reduce((id3, fiber) => combine3(id3, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
    children: map11(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten2),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map11(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some3(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some3(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk4) => [a, ...chunk4],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId3) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId3))
  };
  return _fiberAll;
}, "fiberAll");
var fiberInterruptFork = /* @__PURE__ */ __name((self2) => asVoid2(forkDaemon(interruptFiber(self2))), "fiberInterruptFork");
var fiberJoinAll = /* @__PURE__ */ __name((fibers) => join3(fiberAll(fibers)), "fiberJoinAll");
var fiberScoped = /* @__PURE__ */ __name((self2) => acquireRelease(succeed(self2), interruptFiber), "fiberScoped");
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options4) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap9(winner.inheritAll, () => options4.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options4.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap9(winner.inheritAll, () => options4.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options4.onOtherDone(exit4, loser);
      }
    }
  })
}));
var disconnect = /* @__PURE__ */ __name((self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId3) => flatMap9(forkDaemon(restore(self2)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId3))))))), "disconnect");
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(right3), mapErrorCause((cause22) => parallel(cause3, cause22))),
    onSuccess: (value6) => pipe(right3, interruptAsFiber(parentFiberId), as3(value6))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(left3), mapErrorCause((cause22) => parallel(cause22, cause3))),
    onSuccess: (value6) => pipe(left3, interruptAsFiber(parentFiberId), as3(value6))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options4) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make12(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options4.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options4.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options4.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options4.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = /* @__PURE__ */ __name((winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
}, "completeRace");
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as3(finalizer3, a)
})));
var invokeWithInterrupt = /* @__PURE__ */ __name((self2, entries3, onInterrupt3) => fiberIdWith((id3) => flatMap9(flatMap9(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = /* @__PURE__ */ __name(() => {
    if (counts.every((count4) => count4 === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt3?.();
        cb(interruptFiber(processing));
      }
    }
  }, "checkDone");
  processing.addObserver((exit4) => {
    cleanup.forEach((f) => f());
    cb(exit4);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = /* @__PURE__ */ __name((count4) => {
      counts[i] = count4;
      checkDone();
    }, "observer");
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id3)));
}))), "invokeWithInterrupt");
var makeSpanScoped = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope5 = unsafeGet5(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options4);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get6(fiber.getFiberRef(currentServices), clockTag);
    return as3(scopeAddFinalizerExit(scope5, (exit4) => endSpan(span4, exit4, clock_, timingEnabled)), span4);
  }));
}, "makeSpanScoped");
var withTracerScoped = /* @__PURE__ */ __name((value6) => fiberRefLocallyScopedWith(currentServices, add4(tracerTag, value6)), "withTracerScoped");
var withSpanScoped = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap9(makeSpanScoped(name, addSpanStackTrace(options4)), (span4) => provideService(self2, spanTag, span4));
  }
  return (self2) => flatMap9(makeSpanScoped(name, addSpanStackTrace(options4)), (span4) => provideService(self2, spanTag, span4));
}, "withSpanScoped");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/layer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Cause.js
var Cause_exports = {};
__export(Cause_exports, {
  CauseTypeId: () => CauseTypeId2,
  ExceededCapacityException: () => ExceededCapacityException2,
  ExceededCapacityExceptionTypeId: () => ExceededCapacityExceptionTypeId2,
  IllegalArgumentException: () => IllegalArgumentException2,
  IllegalArgumentExceptionTypeId: () => IllegalArgumentExceptionTypeId2,
  InterruptedException: () => InterruptedException2,
  InterruptedExceptionTypeId: () => InterruptedExceptionTypeId2,
  InvalidPubSubCapacityExceptionTypeId: () => InvalidPubSubCapacityExceptionTypeId2,
  NoSuchElementException: () => NoSuchElementException2,
  NoSuchElementExceptionTypeId: () => NoSuchElementExceptionTypeId2,
  RuntimeException: () => RuntimeException2,
  RuntimeExceptionTypeId: () => RuntimeExceptionTypeId2,
  TimeoutException: () => TimeoutException2,
  TimeoutExceptionTypeId: () => TimeoutExceptionTypeId2,
  UnknownException: () => UnknownException2,
  UnknownExceptionTypeId: () => UnknownExceptionTypeId2,
  YieldableError: () => YieldableError2,
  andThen: () => andThen5,
  as: () => as6,
  contains: () => contains5,
  defects: () => defects2,
  die: () => die4,
  dieOption: () => dieOption2,
  empty: () => empty26,
  fail: () => fail5,
  failureOption: () => failureOption2,
  failureOrCause: () => failureOrCause2,
  failures: () => failures2,
  filter: () => filter10,
  find: () => find2,
  flatMap: () => flatMap12,
  flatten: () => flatten8,
  flipCauseOption: () => flipCauseOption2,
  interrupt: () => interrupt4,
  interruptOption: () => interruptOption2,
  interruptors: () => interruptors2,
  isCause: () => isCause2,
  isDie: () => isDie2,
  isDieType: () => isDieType2,
  isEmpty: () => isEmpty6,
  isEmptyType: () => isEmptyType2,
  isExceededCapacityException: () => isExceededCapacityException2,
  isFailType: () => isFailType2,
  isFailure: () => isFailure4,
  isIllegalArgumentException: () => isIllegalArgumentException2,
  isInterruptType: () => isInterruptType2,
  isInterrupted: () => isInterrupted3,
  isInterruptedException: () => isInterruptedException2,
  isInterruptedOnly: () => isInterruptedOnly2,
  isNoSuchElementException: () => isNoSuchElementException2,
  isParallelType: () => isParallelType2,
  isRuntimeException: () => isRuntimeException2,
  isSequentialType: () => isSequentialType2,
  isTimeoutException: () => isTimeoutException2,
  isUnknownException: () => isUnknownException2,
  keepDefects: () => keepDefects2,
  linearize: () => linearize2,
  map: () => map16,
  match: () => match11,
  originalError: () => originalError,
  parallel: () => parallel4,
  pretty: () => pretty3,
  prettyErrors: () => prettyErrors2,
  reduce: () => reduce11,
  reduceWithContext: () => reduceWithContext3,
  sequential: () => sequential4,
  size: () => size10,
  squash: () => squash,
  squashWith: () => squashWith,
  stripFailures: () => stripFailures2,
  stripSomeDefects: () => stripSomeDefects2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var CauseTypeId2 = CauseTypeId;
var RuntimeExceptionTypeId2 = RuntimeExceptionTypeId;
var InterruptedExceptionTypeId2 = InterruptedExceptionTypeId;
var IllegalArgumentExceptionTypeId2 = IllegalArgumentExceptionTypeId;
var NoSuchElementExceptionTypeId2 = NoSuchElementExceptionTypeId;
var InvalidPubSubCapacityExceptionTypeId2 = InvalidPubSubCapacityExceptionTypeId;
var ExceededCapacityExceptionTypeId2 = ExceededCapacityExceptionTypeId;
var TimeoutExceptionTypeId2 = TimeoutExceptionTypeId;
var UnknownExceptionTypeId2 = UnknownExceptionTypeId;
var YieldableError2 = YieldableError;
var empty26 = empty7;
var fail5 = fail;
var die4 = die;
var interrupt4 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isEmptyType2 = isEmptyType;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterruptType2 = isInterruptType;
var isSequentialType2 = isSequentialType;
var isParallelType2 = isParallelType;
var size10 = size5;
var isEmpty6 = isEmpty3;
var isFailure4 = isFailure;
var isDie2 = isDie;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var failures2 = failures;
var defects2 = defects;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var dieOption2 = dieOption;
var interruptOption2 = interruptOption;
var keepDefects2 = keepDefects;
var linearize2 = linearize;
var stripFailures2 = stripFailures;
var stripSomeDefects2 = stripSomeDefects;
var as6 = as2;
var map16 = map9;
var flatMap12 = flatMap7;
var andThen5 = andThen2;
var flatten8 = flatten4;
var contains5 = contains4;
var squash = causeSquash;
var squashWith = causeSquashWith;
var find2 = find;
var filter10 = filter7;
var match11 = match4;
var reduce11 = reduce6;
var reduceWithContext3 = reduceWithContext;
var InterruptedException2 = InterruptedException;
var isInterruptedException2 = isInterruptedException;
var IllegalArgumentException2 = IllegalArgumentException;
var isIllegalArgumentException2 = isIllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var isNoSuchElementException2 = isNoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var TimeoutException2 = TimeoutException;
var isTimeoutException2 = isTimeoutException;
var UnknownException2 = UnknownException;
var isUnknownException2 = isUnknownException;
var ExceededCapacityException2 = ExceededCapacityException;
var isExceededCapacityException2 = isExceededCapacityException;
var pretty3 = pretty;
var prettyErrors2 = prettyErrors;
var originalError = originalInstance;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/decision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleIntervals.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/intervals.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleInterval.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/interval.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty27 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make35 = /* @__PURE__ */ __name((startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty27;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
}, "make");
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => min3(self2, that) === self2);
var min3 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis)
    return self2;
  if (that.endMillis <= self2.startMillis)
    return that;
  if (self2.startMillis < that.startMillis)
    return self2;
  if (that.startMillis < self2.startMillis)
    return that;
  if (self2.endMillis <= that.endMillis)
    return self2;
  return that;
});
var isEmpty7 = /* @__PURE__ */ __name((self2) => {
  return self2.startMillis >= self2.endMillis;
}, "isEmpty");
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start3 = Math.max(self2.startMillis, that.startMillis);
  const end6 = Math.min(self2.endMillis, that.endMillis);
  return make35(start3, end6);
});
var size11 = /* @__PURE__ */ __name((self2) => {
  return millis(self2.endMillis - self2.startMillis);
}, "size");
var after = /* @__PURE__ */ __name((startMilliseconds) => {
  return make35(startMilliseconds, Number.POSITIVE_INFINITY);
}, "after");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleInterval.js
var make36 = make35;
var empty28 = empty27;
var lessThan5 = lessThan4;
var isEmpty8 = isEmpty7;
var intersect2 = intersect;
var size12 = size11;
var after2 = after;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make37 = /* @__PURE__ */ __name((intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
}, "make");
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty3()));
var intersectLoop = /* @__PURE__ */ __name((_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty8(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan5(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make37(reverse2(acc));
}, "intersectLoop");
var start = /* @__PURE__ */ __name((self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty28)).startMillis;
}, "start");
var end = /* @__PURE__ */ __name((self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty28)).endMillis;
}, "end");
var lessThan6 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty3 = /* @__PURE__ */ __name((self2) => {
  return isNonEmpty(self2.intervals);
}, "isNonEmpty");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleIntervals.js
var make38 = make37;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan7 = lessThan6;
var isNonEmpty4 = isNonEmpty3;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = /* @__PURE__ */ __name((intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
}, "_continue");
var continueWith = /* @__PURE__ */ __name((interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make38(of2(interval))
  };
}, "continueWith");
var done5 = {
  _tag: OP_DONE2
};
var isContinue = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_CONTINUE;
}, "isContinue");
var isDone3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_DONE2;
}, "isDone");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  CloseableScopeTypeId: () => CloseableScopeTypeId2,
  Scope: () => Scope,
  ScopeTypeId: () => ScopeTypeId2,
  addFinalizer: () => addFinalizer2,
  addFinalizerExit: () => addFinalizerExit,
  close: () => close,
  extend: () => extend2,
  fork: () => fork2,
  make: () => make39,
  use: () => use
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ScopeTypeId2 = ScopeTypeId;
var CloseableScopeTypeId2 = CloseableScopeTypeId;
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;
var use = scopeUse;
var make39 = scopeMake;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/effect/circular.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = /* @__PURE__ */ __name(() => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      }, "observer");
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = (permits) => asVoid2(withFiberRuntime((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_2;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  }));
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap9(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  }));
};
__name(Semaphore, "Semaphore");
var unsafeMakeSemaphore = /* @__PURE__ */ __name((permits) => new Semaphore(permits), "unsafeMakeSemaphore");
var makeSemaphore = /* @__PURE__ */ __name((permits) => sync(() => unsafeMakeSemaphore(permits)), "makeSemaphore");
var Latch = class extends Class2 {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_2;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_2;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_2;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_2;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_2);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index2 = this.waiters.indexOf(resume2);
      if (index2 !== -1) {
        this.waiters.splice(index2, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight2(this.await, self2);
  };
};
__name(Latch, "Latch");
var unsafeMakeLatch = /* @__PURE__ */ __name((open) => new Latch(open ?? false), "unsafeMakeLatch");
var makeLatch = /* @__PURE__ */ __name((open) => sync(() => unsafeMakeLatch(open)), "makeLatch");
var awaitAllChildren = /* @__PURE__ */ __name((self2) => ensuringChildren(self2, fiberAwaitAll), "awaitAllChildren");
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map11(cachedInvalidateWithTTL(self2, timeToLive), (tuple4) => tuple4[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration3 = decode(timeToLive);
  return flatMap9(context(), (env) => map11(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration3, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = /* @__PURE__ */ __name((self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self2, deferred)), map11((deferred) => some3([start3 + timeToLiveMillis, deferred])));
}, "computeCachedValue");
var getCachedValue = /* @__PURE__ */ __name((self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap9((time2) => updateSomeAndGetEffectSynchronized(cache, (option7) => {
  switch (option7._tag) {
    case "None": {
      return some3(computeCachedValue(self2, timeToLive, time2));
    }
    case "Some": {
      const [end6] = option7.value;
      return end6 - time2 <= 0 ? some3(computeCachedValue(self2, timeToLive, time2)) : none2();
    }
  }
})), flatMap9((option7) => isNone2(option7) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option7.value[1]))))), "getCachedValue");
var invalidateCache = /* @__PURE__ */ __name((cache) => set4(cache, none2()), "invalidateCache");
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children3) => f(fiberAll(children3))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children3) => flatMap9(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap9(supervisor.value, children3)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options4) => options4?.discard ? forEachSequentialDiscard(effects, fork) : map11(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = /* @__PURE__ */ __name(() => fiberIdWith((fiberId3) => equals(fiberId3, fiber.id()) ? void_2 : asVoid2(interruptFiber(fiber))), "finalizer");
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => forkIn(self2, scope5)), "forkScoped");
var fromFiber = /* @__PURE__ */ __name((fiber) => join3(fiber), "fromFiber");
var fromFiberEffect = /* @__PURE__ */ __name((fiber) => suspend(() => flatMap9(fiber, join3)), "fromFiberEffect");
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
__name(Key, "Key");
var cachedFunction = /* @__PURE__ */ __name((f, eq) => {
  return pipe(sync(() => empty22()), flatMap9(makeSynchronized), map11((ref) => (a) => pipe(ref.modifyEffect((map33) => {
    const result = pipe(map33, get13(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map11((deferred) => [deferred, pipe(map33, set6(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map33]);
  }), flatMap9(deferredAwait), flatMap9(([patch12, b]) => pipe(patchFiberRefs(patch12), as3(b))))));
}, "cachedFunction");
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect4) => flatten6(effect4)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration3) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration3),
  duration: duration3
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration: duration3,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration: duration3,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration3) => timeoutTo(self2, {
  duration: duration3,
  onSuccess: some3,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration: duration3,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration3)), {
  onSelfWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap9(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap9(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SynchronizedImpl = class extends Class2 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId11] = TypeId11;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap9(get11(this.ref), f), flatMap9(([b, a]) => as3(set4(this.ref, a), b))));
  }
};
__name(SynchronizedImpl, "SynchronizedImpl");
var makeSynchronized = /* @__PURE__ */ __name((value6) => sync(() => unsafeMakeSynchronized(value6)), "makeSynchronized");
var unsafeMakeSynchronized = /* @__PURE__ */ __name((value6) => {
  const ref = unsafeMake5(value6);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
}, "unsafeMakeSynchronized");
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([value6, value6]);
    }
    case "Some": {
      return map11(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (a, b) => [a, b]));
var zipLeftFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (a, _) => a));
var zipRightFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (_, b) => b));
var zipWithFiber = /* @__PURE__ */ dual(3, (self2, that, f) => ({
  ...CommitPrototype2,
  commit() {
    return join3(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: () => pipe(self2.id(), getOrElse4(that.id())),
  await: pipe(self2.await, flatten6, zipWithOptions(flatten6(that.await), f, {
    concurrent: true
  }), exit),
  children: self2.children,
  inheritAll: zipRight2(that.inheritAll, self2.inheritAll),
  poll: zipWith4(self2.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap((exitA) => pipe(optionB, map2((exitB) => zipWith5(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: (id3) => zipRight2(self2.interruptAsFork(id3), that.interruptAsFork(id3)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options4) => flatMap9(self2, (a) => all5(f(a), options4).pipe(map11((record4) => Object.assign({}, a, record4)))));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/layer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtime.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order5,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all6,
  await: () => _await2,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done7,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail6,
  failCause: () => failCause5,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt5,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map17,
  mapEffect: () => mapEffect2,
  mapFiber: () => mapFiber2,
  match: () => match12,
  never: () => never3,
  orElse: () => orElse4,
  orElseEither: () => orElseEither4,
  poll: () => poll2,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped,
  status: () => status2,
  succeed: () => succeed6,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_6,
  zip: () => zip7,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight5,
  zipWith: () => zipWith6
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order5 = Order4;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await2 = _await;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all6 = fiberAll;
var done7 = done4;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail6 = fail4;
var failCause5 = failCause4;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt5 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map17 = map14;
var mapEffect2 = mapEffect;
var mapFiber2 = mapFiber;
var match12 = match10;
var never3 = never2;
var orElse4 = orElse3;
var orElseEither4 = orElseEither2;
var poll2 = poll;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped = fiberScoped;
var status2 = status;
var succeed6 = succeed4;
var void_6 = void_5;
var zip7 = zipFiber;
var zipLeft5 = zipLeftFiber;
var zipRight5 = zipRightFiber;
var zipWith6 = zipWithFiber;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = /* @__PURE__ */ __name((f) => function() {
  if (arguments.length === 1) {
    const runtime6 = arguments[0];
    return (effect4, ...args2) => f(runtime6, effect4, ...args2);
  }
  return f.apply(this, arguments);
}, "makeDual");
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime6, self2, options4) => {
  const fiberId3 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId3, runtime6.context]]]];
  if (options4?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId3, options4.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime6.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId3
  });
  if (options4?.updateRefs) {
    fiberRefs3 = options4.updateRefs(fiberRefs3, fiberId3);
  }
  const fiberRuntime = new FiberRuntime(fiberId3, fiberRefs3, runtime6.runtimeFlags);
  let effect4 = self2;
  if (options4?.scope) {
    effect4 = flatMap9(fork2(options4.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_2 : interruptAsFiber(fiberRuntime, id3))), onExit(self2, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime6.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime6.runtimeFlags, fiberRuntime);
  if (options4?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime6, effect4, options4 = {}) => {
  const fiberRuntime = unsafeFork3(runtime6, effect4, options4);
  if (options4.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options4.onExit(exit4);
    });
  }
  return (id3, cancelOptions) => unsafeRunCallback(runtime6)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit4) => cancelOptions.onExit(flatten7(exit4)) : void 0
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime6, effect4) => {
  const result = unsafeRunSyncExit(runtime6)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
__name(AsyncFiberExceptionImpl, "AsyncFiberExceptionImpl");
var asyncFiberException = /* @__PURE__ */ __name((fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error3 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error3;
}, "asyncFiberException");
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause3) {
    const head10 = prettyErrors(cause3)[0];
    super(head10?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head10 ? `(FiberFailure) ${head10.name}` : "FiberFailure";
    if (head10?.stack) {
      this.stack = head10.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
__name(FiberFailureImpl, "FiberFailureImpl");
var fiberFailure = /* @__PURE__ */ __name((cause3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error3 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit;
  return error3;
}, "fiberFailure");
var fastPath = /* @__PURE__ */ __name((effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
}, "fastPath");
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime6, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime6)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime6, effect4, options4) => unsafeRunPromiseExit(runtime6, effect4, options4).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime6, effect4, options4) => new Promise((resolve3) => {
  const op = fastPath(effect4);
  if (op) {
    resolve3(op);
  }
  const fiber = unsafeFork3(runtime6)(effect4);
  fiber.addObserver((exit4) => {
    resolve3(exit4);
  });
  if (options4?.signal !== void 0) {
    if (options4.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options4.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context11, runtimeFlags2, fiberRefs3) {
    this.context = context11;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(RuntimeImpl, "RuntimeImpl");
var make40 = /* @__PURE__ */ __name((options4) => new RuntimeImpl(options4.context, options4.runtimeFlags, options4.fiberRefs), "make");
var runtime3 = /* @__PURE__ */ __name(() => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs()))), "runtime");
var defaultRuntimeFlags = /* @__PURE__ */ make18(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty9(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty20()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = /* @__PURE__ */ __name((register) => suspend(() => {
  let cleanup = void 0;
  return flatMap9(deferredMake(), (deferred) => flatMap9(runtime3(), (runtime6) => uninterruptibleMask((restore) => zipRight2(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime6)(intoDeferred(cb, deferred))), {
    onFailure: (cause3) => deferredFailCause(deferred, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_2;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_2))))));
}), "asyncEffect");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/synchronizedRef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = /* @__PURE__ */ __name((u) => hasProperty(u, LayerTypeId), "isLayer");
var isFresh = /* @__PURE__ */ __name((self2) => {
  return self2._op_layer === OP_FRESH;
}, "isFresh");
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer13, scope5) {
    return pipe(modifyEffect(this.ref, (map33) => {
      const inMap = map33.get(layer13);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached4 = pipe(acquire, flatMap9(([patch12, b]) => pipe(patchFiberRefs(patch12), as3(b))), onExit(exitMatch({
          onFailure: () => void_2,
          onSuccess: () => scopeAddFinalizerExit(scope5, release)
        })));
        return succeed([cached4, map33]);
      }
      return pipe(make24(0), flatMap9((observers) => pipe(deferredMake(), flatMap9((deferred) => pipe(make24(() => void_2), map11((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap9((innerScope) => pipe(restore(flatMap9(makeBuilder(layer13, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap9((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit4)), zipRight2(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify5(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update2(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope5, (exit5) => pipe(sync(() => map33.delete(layer13)), zipRight2(get11(finalizerRef)), flatMap9((finalizer3) => finalizer3(exit5))))), zipRight2(deferredSucceed(deferred, exit4.effect_instruction_i0)), as3(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_2,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit4) => pipe(get11(finalizerRef), flatMap9((finalizer3) => finalizer3(exit4)))];
        return [resource, isFresh(layer13) ? map33 : map33.set(layer13, memoized)];
      }))))));
    }), flatten6);
  }
};
__name(MemoMapImpl, "MemoMapImpl");
var makeMemoMap = /* @__PURE__ */ suspend(() => map11(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = /* @__PURE__ */ __name(() => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map())), "unsafeMakeMemoMap");
var build = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => buildWithScope(self2, scope5)), "build");
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope5) => flatMap9(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope5)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope5) => flatMap9(makeBuilder(self2, scope5), (run6) => provideService(run6(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = /* @__PURE__ */ __name((self2, scope5, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5),
        onSuccess: (value6) => memoMap.getOrElseMemoize(op.successK(value6), scope5)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap9((env) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith4(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope5), op.zipK, {
        concurrent: true
      })));
    }
  }
}, "makeBuilder");
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match13(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause3(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = /* @__PURE__ */ __name((defect) => failCause6(die4(defect)), "die");
var dieSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => die4(evaluate3())), "dieSync");
var discard = /* @__PURE__ */ __name((self2) => map18(self2, () => empty9()), "discard");
var context2 = /* @__PURE__ */ __name(() => fromEffectContext(context()), "context");
var extendScope = /* @__PURE__ */ __name((self2) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self2;
  return extendScope3;
}, "extendScope");
var fail7 = /* @__PURE__ */ __name((error3) => failCause6(fail5(error3)), "fail");
var failSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => fail5(evaluate3())), "failSync");
var failCause6 = /* @__PURE__ */ __name((cause3) => fromEffectContext(failCause(cause3)), "failCause");
var failCauseSync2 = /* @__PURE__ */ __name((evaluate3) => fromEffectContext(failCauseSync(evaluate3)), "failCauseSync");
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => match13(self2, {
  onFailure: fail7,
  onSuccess: f
}));
var flatten9 = /* @__PURE__ */ dual(2, (self2, tag8) => flatMap13(self2, get6(tag8)));
var fresh = /* @__PURE__ */ __name((self2) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self2;
  return fresh3;
}, "fresh");
var fromEffect4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map11(effect4, (service3) => make10(tag8, service3)));
});
var fromEffectDiscard = /* @__PURE__ */ __name((effect4) => fromEffectContext(map11(effect4, () => empty9())), "fromEffectDiscard");
function fromEffectContext(effect4) {
  const fromEffect10 = Object.create(proto3);
  fromEffect10._op_layer = OP_FROM_EFFECT;
  fromEffect10.effect = effect4;
  return fromEffect10;
}
__name(fromEffectContext, "fromEffectContext");
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value6) => locallyEffect(self2, fiberRefLocally(ref, value6)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const locally4 = Object.create(proto3);
  locally4._op_layer = "Locally";
  locally4.self = self2;
  locally4.f = f;
  return locally4;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value6) => locallyEffect(self2, fiberRefLocallyWith(ref, value6)));
var fiberRefLocallyScoped2 = /* @__PURE__ */ __name((self2, value6) => scopedDiscard(fiberRefLocallyScoped(self2, value6)), "fiberRefLocallyScoped");
var fiberRefLocallyScopedWith2 = /* @__PURE__ */ __name((self2, value6) => scopedDiscard(fiberRefLocallyScopedWith(self2, value6)), "fiberRefLocallyScopedWith");
var fromFunction = /* @__PURE__ */ __name((tagA, tagB, f) => fromEffectContext(map11(tagA, (a) => make10(tagB, f(a)))), "fromFunction");
var launch = /* @__PURE__ */ __name((self2) => scopedEffect(zipRight2(scopeWith((scope5) => pipe(self2, buildWithScope(scope5))), never)), "launch");
var mock = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    return (service3) => mockImpl(arguments[0], service3);
  }
  return mockImpl(arguments[0], arguments[1]);
}, "mock");
var mockImpl = /* @__PURE__ */ __name((tag8, service3) => succeed7(tag8, new Proxy({
  ...service3
}, {
  get(target2, prop, _receiver) {
    if (prop in target2) {
      return target2[prop];
    }
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error3 = new Error(`${tag8.key}: Unimplemented method "${prop.toString()}"`);
    Error.stackTraceLimit = prevLimit;
    error3.name = "UnimplementedError";
    return makeUnimplemented(error3);
  },
  has: constTrue
})), "mockImpl");
var makeUnimplemented = /* @__PURE__ */ __name((error3) => {
  const dead = die2(error3);
  function unimplemented() {
    return dead;
  }
  __name(unimplemented, "unimplemented");
  Object.assign(unimplemented, dead);
  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
  return unimplemented;
}, "makeUnimplemented");
var map18 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (context11) => succeedContext(f(context11))));
var mapError3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error3) => failSync2(() => f(error3))));
var matchCause3 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold2 = Object.create(proto3);
  fold2._op_layer = OP_FOLD;
  fold2.layer = self2;
  fold2.failureK = onFailure;
  fold2.successK = onSuccess;
  return fold2;
});
var match13 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause3(self2, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause6(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => map11(memoize(buildWithScope(self2, scope5)), fromEffectContext)), "memoize");
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith7(self2, that, (a, b) => merge3(a, b)));
var mergeAll3 = /* @__PURE__ */ __name((...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
}, "mergeAll");
var orDie2 = /* @__PURE__ */ __name((self2) => catchAll2(self2, (defect) => die5(defect)), "orDie");
var orElse5 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough = /* @__PURE__ */ __name((self2) => merge6(context2(), self2), "passthrough");
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map18(self2, (context11) => make10(tagB, f(unsafeGet5(context11, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed7(stateTag, {
    state: schedule4.initial
  }), flatMap13((env) => retryLoop(self2, schedule4, stateTag, pipe(env, get6(stateTag)).state)));
}));
var retryLoop = /* @__PURE__ */ __name((self2, schedule4, stateTag, state) => {
  return pipe(self2, catchAll2((error3) => pipe(retryUpdate(schedule4, stateTag, error3, state), flatMap13((env) => fresh(retryLoop(self2, schedule4, stateTag, pipe(env, get6(stateTag)).state))))));
}, "retryLoop");
var retryUpdate = /* @__PURE__ */ __name((schedule4, stateTag, error3, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap9((now2) => pipe(schedule4.step(now2, error3, state), flatMap9(([state2, _, decision]) => isDone4(decision) ? fail2(error3) : pipe(sleep2(millis(start2(decision.intervals) - now2)), as3({
    state: state2
  })))))));
}, "retryUpdate");
var scoped2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map11(effect4, (service3) => make10(tag8, service3)));
});
var scopedDiscard = /* @__PURE__ */ __name((effect4) => scopedContext(pipe(effect4, as3(empty9()))), "scopedDiscard");
var scopedContext = /* @__PURE__ */ __name((effect4) => {
  const scoped9 = Object.create(proto3);
  scoped9._op_layer = OP_SCOPED;
  scoped9.effect = effect4;
  return scoped9;
}, "scopedContext");
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map11(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope5, exit4) => scope5.close(exit4)), (scope5) => make10(Scope, scope5)));
var service = /* @__PURE__ */ __name((tag8) => fromEffect4(tag8, tag8), "service");
var succeed7 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make10(tag8, resource)));
});
var succeedContext = /* @__PURE__ */ __name((context11) => {
  return fromEffectContext(succeed(context11));
}, "succeedContext");
var empty30 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty9());
var suspend3 = /* @__PURE__ */ __name((evaluate3) => {
  const suspend15 = Object.create(proto3);
  suspend15._op_layer = OP_SUSPEND;
  suspend15.evaluate = evaluate3;
  return suspend15;
}, "suspend");
var sync4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make10(tag8, evaluate3())));
});
var syncContext = /* @__PURE__ */ __name((evaluate3) => {
  return fromEffectContext(sync(evaluate3));
}, "syncContext");
var tap3 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (context11) => fromEffectContext(as3(f(context11), context11))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap9(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause3) => fromEffectContext(flatMap9(f(cause3), () => failCause(cause3)))));
var toRuntime = /* @__PURE__ */ __name((self2) => pipe(scopeWith((scope5) => buildWithScope(self2, scope5)), flatMap9((context11) => pipe(runtime3(), provideContext(context11)))), "toRuntime");
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap9(scopeWith((scope5) => buildWithMemoMap(self2, memoMap, scope5)), (context11) => pipe(runtime3(), provideContext(context11))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll3(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith16 = Object.create(proto3);
  zipWith16._op_layer = OP_PROVIDE_MERGE;
  zipWith16.first = self2;
  zipWith16.second = provide(that, self2);
  zipWith16.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith16;
});
var zipWith7 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend3(() => {
  const zipWith16 = Object.create(proto3);
  zipWith16._op_layer = OP_ZIP_WITH2;
  zipWith16.first = self2;
  zipWith16.second = that;
  zipWith16.zipK = f;
  return zipWith16;
}));
var unwrapEffect = /* @__PURE__ */ __name((self2) => {
  const tag8 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap13(fromEffect4(tag8, self2), (context11) => get6(context11, tag8));
}, "unwrapEffect");
var unwrapScoped = /* @__PURE__ */ __name((self2) => {
  const tag8 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap13(scoped2(tag8, self2), (context11) => get6(context11, tag8));
}, "unwrapScoped");
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var withSpan2 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map11(options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit4) => options4.onEnd(span4, exit4))) : makeSpanScoped(name, options4), (span4) => withParentSpan2(self2, span4)));
  }
  return (self2) => unwrapScoped(map11(options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit4) => options4.onEnd(span4, exit4))) : makeSpanScoped(name, options4), (span4) => withParentSpan2(self2, span4)));
}, "withSpan");
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span4) => provide(self2, succeedContext(make10(spanTag, span4))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer13) => scopedWith((scope5) => flatMap9(buildWithScope(layer13, scope5), (context11) => provideSomeContext(self2, context11))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_2;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll3(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId14 in source) {
    return flatMap9(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map11(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get6(consoleTag));
var consoleWith = /* @__PURE__ */ __name((f) => fiberRefGetWith(currentServices, (services) => f(get6(services, consoleTag))), "consoleWith");
var withConsole = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(effect4, currentServices, add4(consoleTag, value6)));
var withConsoleScoped = /* @__PURE__ */ __name((console4) => fiberRefLocallyScopedWith(currentServices, add4(consoleTag, console4)), "withConsoleScoped");
var log2 = /* @__PURE__ */ __name((...args2) => consoleWith((_) => _.log(...args2)), "log");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/executionPlan.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Data.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var struct3 = struct2;
var array3 = /* @__PURE__ */ __name((as14) => unsafeArray(as14.slice(0)), "array");
var unsafeArray = /* @__PURE__ */ __name((as14) => Object.setPrototypeOf(as14, ArrayProto), "unsafeArray");
var Class4 = Structural;
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = /* @__PURE__ */ __name((tag8) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag8;
    }
  };
  O.BaseEffectError.prototype.name = tag8;
  return O.BaseEffectError;
}, "TaggedError");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/dateTime.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId15]: TypeId15,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = /* @__PURE__ */ __name((epochMillis, zone, partsUtc) => {
  const self2 = Object.create(ProtoZoned);
  self2.epochMillis = epochMillis;
  self2.zone = zone;
  Object.defineProperty(self2, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self2;
}, "makeZonedProto");
var isDateTime = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId15), "isDateTime");
var isTimeZone = /* @__PURE__ */ __name((u) => hasProperty(u, TimeZoneTypeId), "isTimeZone");
var isTimeZoneOffset = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Offset", "isTimeZoneOffset");
var isTimeZoneNamed = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Named", "isTimeZoneNamed");
var isUtc = /* @__PURE__ */ __name((self2) => self2._tag === "Utc", "isUtc");
var isZoned = /* @__PURE__ */ __name((self2) => self2._tag === "Zoned", "isZoned");
var Equivalence2 = /* @__PURE__ */ make((a, b) => a.epochMillis === b.epochMillis);
var makeUtc = /* @__PURE__ */ __name((epochMillis) => {
  const self2 = Object.create(ProtoUtc);
  self2.epochMillis = epochMillis;
  Object.defineProperty(self2, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self2;
}, "makeUtc");
var unsafeFromDate = /* @__PURE__ */ __name((date4) => {
  const epochMillis = date4.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
}, "unsafeFromDate");
var unsafeMake9 = /* @__PURE__ */ __name((input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date4 = /* @__PURE__ */ new Date(0);
    setPartsDate(date4, input);
    return unsafeFromDate(date4);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
}, "unsafeMake");
var hasZone = /* @__PURE__ */ __name((input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input), "hasZone");
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = /* @__PURE__ */ __name((input, options4) => {
  if (options4?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self2 = unsafeMake9(input);
  if (self2.epochMillis < minEpochMillis || self2.epochMillis > maxEpochMillis) {
    throw new RangeError(`Epoch millis out of range: ${self2.epochMillis}`);
  }
  let zone;
  if (options4?.timeZone === void 0) {
    const offset = new Date(self2.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options4?.timeZone)) {
    zone = options4.timeZone;
  } else if (typeof options4?.timeZone === "number") {
    zone = zoneMakeOffset(options4.timeZone);
  } else {
    const parsedZone = zoneFromString(options4.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options4.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options4?.adjustForTimeZone !== true) {
    return makeZonedProto(self2.epochMillis, zone, self2.partsUtc);
  }
  return makeZonedFromAdjusted(self2.epochMillis, zone, options4?.disambiguation ?? "compatible");
}, "unsafeMakeZoned");
var makeZoned = /* @__PURE__ */ liftThrowable(unsafeMakeZoned);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = /* @__PURE__ */ __name((input) => {
  const match21 = zonedStringRegex.exec(input);
  if (match21 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match21;
  return makeZoned(isoString, {
    timeZone
  });
}, "makeZonedFromString");
var validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = /* @__PURE__ */ __name((format8) => {
  const zoneId = format8.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format8;
  validZoneCache.set(zoneId, zone);
  return zone;
}, "zoneMakeIntl");
var zoneUnsafeMakeNamed = /* @__PURE__ */ __name((zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
}, "zoneUnsafeMakeNamed");
var zoneMakeOffset = /* @__PURE__ */ __name((offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
}, "zoneMakeOffset");
var zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = /* @__PURE__ */ __name((zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some3(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
}, "zoneFromString");
var zoneToString = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "Offset") {
    return offsetToString(self2.offset);
  }
  return self2.id;
}, "zoneToString");
var toDateUtc = /* @__PURE__ */ __name((self2) => new Date(self2.epochMillis), "toDateUtc");
var toDate = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "Utc") {
    return new Date(self2.epochMillis);
  } else if (self2.zone._tag === "Offset") {
    return new Date(self2.epochMillis + self2.zone.offset);
  } else if (self2.adjustedEpochMillis !== void 0) {
    return new Date(self2.adjustedEpochMillis);
  }
  const parts2 = self2.zone.format.formatToParts(self2.epochMillis).filter((_) => _.type !== "literal");
  const date4 = /* @__PURE__ */ new Date(0);
  date4.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date4.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self2.adjustedEpochMillis = date4.getTime();
  return date4;
}, "toDate");
var zonedOffset = /* @__PURE__ */ __name((self2) => {
  const date4 = toDate(self2);
  return date4.getTime() - toEpochMillis(self2);
}, "zonedOffset");
var offsetToString = /* @__PURE__ */ __name((offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
}, "offsetToString");
var zonedOffsetIso = /* @__PURE__ */ __name((self2) => offsetToString(zonedOffset(self2)), "zonedOffsetIso");
var toEpochMillis = /* @__PURE__ */ __name((self2) => self2.epochMillis, "toEpochMillis");
var setPartsDate = /* @__PURE__ */ __name((date4, parts2) => {
  if (parts2.year !== void 0) {
    date4.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date4.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date4.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff9 = parts2.weekDay - date4.getUTCDay();
    date4.setUTCDate(date4.getUTCDate() + diff9);
  }
  if (parts2.hours !== void 0) {
    date4.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date4.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date4.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date4.setUTCMilliseconds(parts2.millis);
  }
}, "setPartsDate");
var constDayMillis = 24 * 60 * 60 * 1e3;
var makeZonedFromAdjusted = /* @__PURE__ */ __name((adjustedMillis, zone, disambiguation) => {
  if (zone._tag === "Offset") {
    return makeZonedProto(adjustedMillis - zone.offset, zone);
  }
  const beforeOffset = calculateNamedOffset(adjustedMillis - constDayMillis, adjustedMillis, zone);
  const afterOffset = calculateNamedOffset(adjustedMillis + constDayMillis, adjustedMillis, zone);
  if (beforeOffset === afterOffset) {
    return makeZonedProto(adjustedMillis - beforeOffset, zone);
  }
  const isForwards = beforeOffset < afterOffset;
  const transitionMillis = beforeOffset - afterOffset;
  if (isForwards) {
    const currentAfterOffset = calculateNamedOffset(adjustedMillis - afterOffset, adjustedMillis, zone);
    if (currentAfterOffset === afterOffset) {
      return makeZonedProto(adjustedMillis - afterOffset, zone);
    }
    const before2 = makeZonedProto(adjustedMillis - beforeOffset, zone);
    const beforeAdjustedMillis = toDate(before2).getTime();
    if (adjustedMillis !== beforeAdjustedMillis) {
      switch (disambiguation) {
        case "reject": {
          const formatted = new Date(adjustedMillis).toISOString();
          throw new RangeError(`Gap time: ${formatted} does not exist in time zone ${zone.id}`);
        }
        case "earlier":
          return makeZonedProto(adjustedMillis - afterOffset, zone);
        case "compatible":
        case "later":
          return before2;
      }
    }
    return before2;
  }
  const currentBeforeOffset = calculateNamedOffset(adjustedMillis - beforeOffset, adjustedMillis, zone);
  if (currentBeforeOffset === beforeOffset) {
    if (disambiguation === "earlier" || disambiguation === "compatible") {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    const laterOffset = calculateNamedOffset(adjustedMillis - beforeOffset + transitionMillis, adjustedMillis + transitionMillis, zone);
    if (laterOffset === beforeOffset) {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    if (disambiguation === "reject") {
      const formatted = new Date(adjustedMillis).toISOString();
      throw new RangeError(`Ambiguous time: ${formatted} occurs twice in time zone ${zone.id}`);
    }
  }
  return makeZonedProto(adjustedMillis - afterOffset, zone);
}, "makeZonedFromAdjusted");
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = /* @__PURE__ */ __name((offset) => {
  const match21 = offsetRegex.exec(offset);
  if (match21 === null) {
    return null;
  }
  const [, sign2, hours2, minutes2] = match21;
  return (sign2 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
}, "parseOffset");
var calculateNamedOffset = /* @__PURE__ */ __name((utcMillis, adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(utcMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
}, "calculateNamedOffset");
var formatIso2 = /* @__PURE__ */ __name((self2) => toDateUtc(self2).toISOString(), "formatIso");
var formatIsoOffset = /* @__PURE__ */ __name((self2) => {
  const date4 = toDate(self2);
  return self2._tag === "Utc" ? date4.toISOString() : `${date4.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
}, "formatIsoOffset");
var formatIsoZoned = /* @__PURE__ */ __name((self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`, "formatIsoZoned");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/String.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Equivalence3 = string;
var toUpperCase = /* @__PURE__ */ __name((self2) => self2.toUpperCase(), "toUpperCase");
var toLowerCase = /* @__PURE__ */ __name((self2) => self2.toLowerCase(), "toLowerCase");
var capitalize = /* @__PURE__ */ __name((self2) => {
  if (self2.length === 0)
    return self2;
  return toUpperCase(self2[0]) + self2.slice(1);
}, "capitalize");
var uncapitalize = /* @__PURE__ */ __name((self2) => {
  if (self2.length === 0)
    return self2;
  return toLowerCase(self2[0]) + self2.slice(1);
}, "uncapitalize");
var isNonEmpty5 = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");
var CR = 13;
var LF = 10;
var LinesIterator = class {
  s;
  stripped;
  index;
  length;
  constructor(s, stripped = false) {
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const start3 = this.index;
    while (!this.done && !isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end6 = this.index;
    if (!this.done) {
      const char2 = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done && isLineBreak2(char2, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end6 = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start3, end6)
    };
  }
  [Symbol.iterator]() {
    return new LinesIterator(this.s, this.stripped);
  }
  get done() {
    return this.index >= this.length;
  }
};
__name(LinesIterator, "LinesIterator");
var isLineBreak = /* @__PURE__ */ __name((char2) => {
  const code = char2.charCodeAt(0);
  return code === CR || code === LF;
}, "isLineBreak");
var isLineBreak2 = /* @__PURE__ */ __name((char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF, "isLineBreak2");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Random.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var fixed2 = fixed;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleTypeId), "isSchedule");
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step4) {
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(ScheduleImpl, "ScheduleImpl");
var updateInfo = /* @__PURE__ */ __name((iterationMetaRef, now2, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now2,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now2
} : {
  now: now2,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now2 - prev.start),
  elapsedSincePrevious: millis(now2 - prev.now),
  start: prev.start
}), "updateInfo");
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule4, ref) {
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map11(get11(this.ref), (tuple4) => tuple4[1]);
  }
  get last() {
    return flatMap9(get11(this.ref), ([element2, _]) => {
      switch (element2._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element2.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake5(defaultIterationMetadata);
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set4(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map11(get11(this.ref), (tuple4) => tuple4[1]), flatMap9((state) => pipe(currentTimeMillis2, flatMap9((now2) => pipe(suspend(() => this.schedule.step(now2, input, state)), flatMap9(([state2, out, decision]) => {
      const setState = set4(this.ref, [some3(out), state2]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now2;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now2, input, out)), as3(out));
      }
      const duration3 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now2, input, out)), zipRight2(sleep3(duration3)), as3(out));
    }))))));
  }
};
__name(ScheduleDriverImpl, "ScheduleDriverImpl");
var makeWithState = /* @__PURE__ */ __name((initial, step4) => new ScheduleImpl(initial, step4), "makeWithState");
var addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration3) => map11(f(out), (delay3) => sum(duration3, decode(delay3)))));
var asVoid4 = /* @__PURE__ */ __name((self2) => map19(self2, constVoid), "asVoid");
var check = /* @__PURE__ */ dual(2, (self2, test3) => checkEffect(self2, (input, out) => sync(() => test3(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test3) => makeWithState(self2.initial, (now2, input, state) => flatMap9(self2.step(now2, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, done6]);
  }
  return map11(test3(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var driver = /* @__PURE__ */ __name((self2) => pipe(make24([none2(), self2.initial]), map11((ref) => new ScheduleDriverImpl(self2, ref))), "driver");
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now2, input, state) => pipe(zipWith4(self2.step(now2, input, state[0]), that.step(now2, input, state[1]), (a, b) => [a, b]), flatMap9(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = /* @__PURE__ */ __name((self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan7(rInterval))) {
    return flatMap9(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap9(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
}, "intersectWithLoop");
var map19 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect3(self2, (out) => sync(() => f(out))));
var mapEffect3 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap9(self2.step(now2, input, state), ([state2, out, decision]) => map11(f(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap9(self2.step(now2, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay3 = size12(make36(now2, start2(intervals)));
  return map11(f(out, delay3), (durationInput) => {
    const duration3 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now2 + toMillis(duration3);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make36(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough2 = /* @__PURE__ */ __name((self2) => makeWithState(self2.initial, (now2, input, state) => pipe(self2.step(now2, input, state), map11(([state2, _, decision]) => [state2, input, decision]))), "passthrough");
var recurs = /* @__PURE__ */ __name((n) => whileOutput(forever2, (out) => out < n), "recurs");
var spaced = /* @__PURE__ */ __name((duration3) => addDelay(forever2, () => duration3), "spaced");
var unfold2 = /* @__PURE__ */ __name((initial, f) => makeWithState(initial, (now2, _, state) => sync(() => [f(state), state, continueWith2(after2(now2))])), "unfold");
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error3) {
    this.error = error3;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
__name(ScheduleDefect, "ScheduleDefect");
var isScheduleDefect = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleDefectTypeId), "isScheduleDefect");
var scheduleDefectWrap = /* @__PURE__ */ __name((self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e))), "scheduleDefectWrap");
var scheduleDefectRefailCause = /* @__PURE__ */ __name((cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some3(_.defect) : none2()), {
  onNone: () => cause3,
  onSome: (error3) => fail(error3.error)
}), "scheduleDefectRefailCause");
var scheduleDefectRefail = /* @__PURE__ */ __name((effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatOrElse_Effect(self2, schedule4, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (isSchedule(options4)) {
    return repeat_Effect(self2, options4);
  }
  const base = options4.schedule ?? passthrough2(forever2);
  const withWhile = options4.while ? whileInputEffect(base, (a) => {
    const applied = options4.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options4.until ? untilInputEffect(withWhile, (a) => {
    const applied = options4.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options4.times ? intersect5(withUntil, recurs(options4.times)).pipe(map19((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule4, orElse16) => flatMap9(driver(schedule4), (driver3) => matchEffect(self2, {
  onFailure: (error3) => orElse16(error3, none2()),
  onSuccess: (value6) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (error3, option7) => provideServiceEffect(orElse16(error3, option7), CurrentIterationMetadata, get11(driver3.iterationMeta)), value6)
})));
var repeatOrElseEffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse16, value6) => matchEffect(driver3.next(value6), {
  onFailure: () => orDie(driver3.last),
  onSuccess: (b) => matchEffect(self2, {
    onFailure: (error3) => orElse16(error3, some3(b)),
    onSuccess: (value7) => repeatOrElseEffectLoop(self2, driver3, orElse16, value7)
  })
}), "repeatOrElseEffectLoop");
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy2) => retryOrElse_Effect(self2, policy2, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (isSchedule(options4)) {
    return retry_Effect(self2, options4);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options4)));
});
var fromRetryOptions = /* @__PURE__ */ __name((options4) => {
  const base = options4.schedule ?? forever2;
  const withWhile = options4.while ? whileInputEffect(base, (e) => {
    const applied = options4.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options4.until ? untilInputEffect(withWhile, (e) => {
    const applied = options4.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options4.times ? intersect5(withUntil, recurs(options4.times)) : withUntil;
}, "fromRetryOptions");
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy2, orElse16) => flatMap9(driver(policy2), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse16(e, out), CurrentIterationMetadata, get11(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse16) => {
  return catchAll(self2, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap9((out) => orElse16(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver3, orElse16)
  }));
}, "retryOrElse_EffectLoop");
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => scheduleFrom_Effect(self2, void 0, schedule4));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule4) => flatMap9(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = /* @__PURE__ */ __name((self2, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap9(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver3))
}), "scheduleFrom_EffectLoop");
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid4(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule4) => forkScoped(schedule_Effect(self2, schedule4)));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap9(whileLoop({
    while: () => i < plan.steps.length && (result === void 0 || isLeft2(result)),
    body: () => {
      const step4 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step4.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
      } else {
        const schedule4 = scheduleFromStep(step4, true);
        nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either9) => {
      result = either9;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = /* @__PURE__ */ __name((step4, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once2,
      times: step4.attempts,
      while: step4.while
    });
  } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step4.schedule,
    while: step4.while,
    times: step4.attempts ? step4.attempts - 1 : void 0
  });
}, "scheduleFromStep");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/query.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cache.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Deferred.js
var Deferred_exports = {};
__export(Deferred_exports, {
  DeferredTypeId: () => DeferredTypeId2,
  await: () => _await3,
  complete: () => complete2,
  completeWith: () => completeWith,
  die: () => die6,
  dieSync: () => dieSync3,
  done: () => done8,
  fail: () => fail8,
  failCause: () => failCause7,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  interrupt: () => interrupt6,
  interruptWith: () => interruptWith2,
  isDone: () => isDone5,
  make: () => make41,
  makeAs: () => makeAs,
  poll: () => poll3,
  succeed: () => succeed8,
  sync: () => sync5,
  unsafeDone: () => unsafeDone,
  unsafeMake: () => unsafeMake10
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var DeferredTypeId2 = DeferredTypeId;
var make41 = deferredMake;
var makeAs = deferredMakeAs;
var _await3 = deferredAwait;
var complete2 = deferredComplete;
var completeWith = deferredCompleteWith;
var done8 = deferredDone;
var fail8 = deferredFail;
var failSync3 = deferredFailSync;
var failCause7 = deferredFailCause;
var failCauseSync3 = deferredFailCauseSync;
var die6 = deferredDie;
var dieSync3 = deferredDieSync;
var interrupt6 = deferredInterrupt;
var interruptWith2 = deferredInterruptWith;
var isDone5 = deferredIsDone;
var poll3 = deferredPoll;
var succeed8 = deferredSucceed;
var sync5 = deferredSync;
var unsafeMake10 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableQueue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableList.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId16]: TypeId16,
  [Symbol.iterator]() {
    let done12 = false;
    let head10 = this.head;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (head10 == null) {
          done12 = true;
          return this.return();
        }
        const value6 = head10.value;
        head10 = head10.next;
        return {
          done: done12,
          value: value6
        };
      },
      return(value6) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = /* @__PURE__ */ __name((value6) => ({
  value: value6,
  removed: false,
  prev: void 0,
  next: void 0
}), "makeNode");
var empty31 = /* @__PURE__ */ __name(() => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
}, "empty");
var isEmpty9 = /* @__PURE__ */ __name((self2) => length(self2) === 0, "isEmpty");
var length = /* @__PURE__ */ __name((self2) => self2._length, "length");
var append3 = /* @__PURE__ */ dual(2, (self2, value6) => {
  const node = makeNode(value6);
  if (self2.head === void 0) {
    self2.head = node;
  }
  if (self2.tail === void 0) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  ;
  self2._length += 1;
  return self2;
});
var shift = /* @__PURE__ */ __name((self2) => {
  const head10 = self2.head;
  if (head10 !== void 0) {
    remove9(self2, head10);
    return head10.value;
  }
  return void 0;
}, "shift");
var remove9 = /* @__PURE__ */ __name((self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self2.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self2.head = node.next;
    node.next.prev = void 0;
  } else {
    self2.tail = void 0;
    self2.head = void 0;
  }
  if (self2._length > 0) {
    ;
    self2._length -= 1;
  }
}, "remove");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableQueue.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId17]: TypeId17,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make42 = /* @__PURE__ */ __name((capacity7) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty31();
  queue.capacity = capacity7;
  return queue;
}, "make");
var bounded = /* @__PURE__ */ __name((capacity7) => make42(capacity7), "bounded");
var unbounded = /* @__PURE__ */ __name(() => make42(void 0), "unbounded");
var length2 = /* @__PURE__ */ __name((self2) => length(self2.queue), "length");
var isEmpty10 = /* @__PURE__ */ __name((self2) => isEmpty9(self2.queue), "isEmpty");
var capacity = /* @__PURE__ */ __name((self2) => self2.capacity === void 0 ? Infinity : self2.capacity, "capacity");
var offer = /* @__PURE__ */ dual(2, (self2, value6) => {
  const queueLength = length(self2.queue);
  if (self2.capacity !== void 0 && queueLength === self2.capacity) {
    return false;
  }
  append3(value6)(self2.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self2, values6) => {
  const iterator = values6[Symbol.iterator]();
  let next;
  let remainder2 = empty3();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self2);
  }
  while (next != null && !next.done) {
    remainder2 = prepend2(next.value)(remainder2);
    next = iterator.next();
  }
  return reverse2(remainder2);
});
var poll4 = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty9(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
  let result = empty3();
  let count4 = 0;
  while (count4 < n) {
    const element2 = poll4(EmptyMutableQueue)(self2);
    if (element2 === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element2)(result);
    count4 += 1;
  }
  return reverse2(result);
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cache.js
var complete3 = /* @__PURE__ */ __name((key, exit4, entryStats, timeToLiveMillis) => struct2({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
}), "complete");
var pending2 = /* @__PURE__ */ __name((key, deferred) => struct2({
  _tag: "Pending",
  key,
  deferred
}), "pending");
var refreshing = /* @__PURE__ */ __name((deferred, complete4) => struct2({
  _tag: "Refreshing",
  deferred,
  complete: complete4
}), "refreshing");
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current2) {
    this.current = current2;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
__name(MapKeyImpl, "MapKeyImpl");
var makeMapKey = /* @__PURE__ */ __name((current2) => new MapKeyImpl(current2), "makeMapKey");
var isMapKey = /* @__PURE__ */ __name((u) => hasProperty(u, MapKeyTypeId), "isMapKey");
var KeySetImpl = class {
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next = key.next;
        if (next !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next;
            next.previous = previous2;
          } else {
            this.head = next;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next = key.next;
      if (next !== void 0) {
        key.next = void 0;
        this.head = next;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
__name(KeySetImpl, "KeySetImpl");
var makeKeySet = /* @__PURE__ */ __name(() => new KeySetImpl(), "makeKeySet");
var makeCacheState = /* @__PURE__ */ __name((map33, keys6, accesses, updating, hits, misses) => ({
  map: map33,
  keys: keys6,
  accesses,
  updating,
  hits,
  misses
}), "makeCacheState");
var initialCacheState = /* @__PURE__ */ __name(() => makeCacheState(empty22(), makeKeySet(), unbounded(), make12(false), 0, 0), "initialCacheState");
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var makeCacheStats = /* @__PURE__ */ __name((options4) => options4, "makeCacheStats");
var makeEntryStats = /* @__PURE__ */ __name((loadedMillis) => ({
  loadedMillis
}), "makeEntryStats");
var CacheImpl = class {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity7, context11, fiberId3, lookup, timeToLive) {
    this.capacity = capacity7;
    this.context = context11;
    this.fiberId = fiberId3;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map11(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size7(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get13(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value6) => this.resolveMapValue(value6)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get13(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value6) => this.resolveMapValue(value6, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option7 = get13(this.cacheState.map, key);
      if (isSome2(option7)) {
        switch (option7.value._tag) {
          case "Complete": {
            const loaded = option7.value.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option7.value.complete.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value6 = getOrUndefined(get13(this.cacheState.map, k));
      if (value6 === void 0) {
        deferred = unsafeMake10(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value6 = getOrUndefined(get13(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value6 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map11(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap9(this.resolveMapValue(value6), match2({
          onNone: () => this.getEither(key),
          onSome: (value7) => succeed(left2(value7))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove7(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when7) {
    return sync(() => {
      const value6 = get13(this.cacheState.map, key);
      if (isSome2(value6) && value6.value._tag === "Complete") {
        if (value6.value.exit._tag === "Success") {
          if (when7(value6.value.exit.value)) {
            remove7(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty22();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake10(this.fiberId);
      let value6 = getOrUndefined(get13(this.cacheState.map, k));
      if (value6 === void 0) {
        if (has6(this.cacheState.map, k)) {
          value6 = getOrUndefined(get13(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value6 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value6._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
              const found = getOrUndefined(get13(this.cacheState.map, k));
              if (equals(found, value6)) {
                remove7(this.cacheState.map, k);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined(get13(this.cacheState.map, k));
              if (equals(current2, value6)) {
                const mapValue = refreshing(deferred, value6);
                set6(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await3(value6.deferred);
          }
          case "Refreshing": {
            return _await3(value6.deferred);
          }
        }
      }
    }));
  }
  set(key, value6) {
    return clockWith3((clock3) => sync(() => {
      const now2 = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value6);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now2), now2 + toMillis(decode(this.timeToLive(lookupResult))));
      set6(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size7(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values6.push(entry[1].exit.value);
        }
      }
      return values6;
    });
  }
  get entries() {
    return sync(() => {
      const values6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values6.push([entry[0], entry[1].exit.value]);
        }
      }
      return values6;
    });
  }
  get keys() {
    return sync(() => {
      const keys6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys6.push(entry[0]);
        }
      }
      return keys6;
    });
  }
  resolveMapValue(value6, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value6._tag) {
        case "Complete": {
          this.trackAccess(value6.key);
          if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
            remove7(this.cacheState.map, value6.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map11(value6.exit, some3);
        }
        case "Pending": {
          this.trackAccess(value6.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map11(_await3(value6.deferred), some3);
        }
        case "Refreshing": {
          this.trackAccess(value6.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value6.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map11(_await3(value6.deferred), some3);
          }
          return map11(value6.complete.exit, some3);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll4(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size18 = size7(this.cacheState.map);
      loop3 = size18 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove7(this.cacheState.map, key2.current);
            size18 = size18 - 1;
            loop3 = size18 > this.capacity;
          }
        } else {
          loop3 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap9((exit4) => {
        const now2 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now2);
        const value6 = complete3(makeMapKey(key), exit4, stats, now2 + toMillis(decode(this.timeToLive(exit4))));
        set6(this.cacheState.map, key, value6);
        return zipRight2(done8(deferred, exit4), exit4);
      }), onInterrupt(() => zipRight2(interrupt6(deferred), sync(() => {
        remove7(this.cacheState.map, key);
      }))));
    }));
  }
};
__name(CacheImpl, "CacheImpl");
var unsafeMakeWith = /* @__PURE__ */ __name((capacity7, lookup, timeToLive) => new CacheImpl(capacity7, empty9(), none3, lookup, (exit4) => decode(timeToLive(exit4))), "unsafeMakeWith");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map11(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = /* @__PURE__ */ __name((request2, dataSource) => flatMap9(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap9(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(empty17, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap9(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
})), "fromRequest");
var cacheRequest = /* @__PURE__ */ __name((request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_2;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_2;
  });
}, "cacheRequest");
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(
  2,
  // @ts-expect-error
  (self2, cache) => fiberRefLocally(self2, currentCache, cache)
);

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Request.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isRequest2 = isRequest;
var Class5 = Class3;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all7 = all5;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile3 = dropWhile2;
var takeUntil2 = takeUntil;
var takeWhile3 = takeWhile2;
var every10 = every8;
var exists4 = exists3;
var filter11 = filter9;
var filterMap7 = filterMap6;
var findFirst8 = findFirst6;
var forEach10 = forEach9;
var head4 = head3;
var mergeAll4 = mergeAll2;
var partition6 = partition5;
var reduce12 = reduce9;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail10 = fail2;
var failSync4 = failSync;
var failCause9 = failCause;
var failCauseSync4 = failCauseSync;
var die7 = die2;
var dieMessage2 = dieMessage;
var dieSync4 = dieSync;
var gen3 = gen2;
var never4 = never;
var none9 = none6;
var promise2 = promise;
var succeed10 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend4 = suspend;
var sync6 = sync;
var _void = void_2;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith3 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate3 = liftPredicate2;
var as7 = as3;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid5 = asVoid2;
var flip2 = flip;
var flipWith2 = flipWith;
var map20 = map11;
var mapAccum4 = mapAccum3;
var mapBoth4 = mapBoth2;
var mapError4 = mapError;
var mapErrorCause3 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped3 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do3 = Do2;
var bind4 = bind3;
var bindAll2 = bindAll;
var bindTo4 = bindTo3;
var let_4 = let_3;
var option2 = option;
var either3 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap14 = flatMap9;
var andThen6 = andThen4;
var flatten10 = flatten6;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap4 = tap2;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally2 = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure5 = isFailure2;
var isSuccess3 = isSuccess;
var match14 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect3 = matchEffect;
var log3 = log;
var logWithLevel2 = /* @__PURE__ */ __name((level, ...message) => logWithLevel(level)(...message), "logWithLevel");
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse6 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = /* @__PURE__ */ dual(2, (effect4, values6) => withRandom2(effect4, fixed2(values6)));
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip8 = zipOptions;
var zipLeft6 = zipLeftOptions;
var zipRight6 = zipRightOptions;
var zipWith8 = zipWithOptions;
var ap2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith8(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = /* @__PURE__ */ __name((self2) => {
  return isNone(self2) ? succeedNone2 : map20(self2.value, some2);
}, "transposeOption");
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map20(f(self2.value), some2));
var makeTagProxy = /* @__PURE__ */ __name((TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target2, prop, receiver) {
      if (prop in target2) {
        return Reflect.get(target2, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = /* @__PURE__ */ __name((...args2) => andThen4(target2, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen4(target2, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen4(target2, (s2) => s2[prop]));
        return s[prop];
      }), "fn");
      const cn = andThen4(target2, (s) => s[prop]);
      Object.assign(fn2, cn);
      const apply = fn2.apply;
      const bind7 = fn2.bind;
      const call = fn2.call;
      const proto14 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto14.apply = apply;
      proto14.bind = bind7;
      proto14.call = call;
      Object.setPrototypeOf(fn2, proto14);
      cache.set(prop, fn2);
      return fn2;
    }
  });
}, "makeTagProxy");
var Tag3 = /* @__PURE__ */ __name((id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen4(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
}, "Tag");
var Service = /* @__PURE__ */ __name(function() {
  return function() {
    const [id3, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = /* @__PURE__ */ __name(function(service3) {
      if (patchState === "unchecked") {
        const proto14 = Object.getPrototypeOf(service3);
        if (proto14 === Object.prototype || proto14 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto14);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service3);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service3, Object.getPrototypeOf(this));
        return service3;
      }
    }, "TagClass");
    TagClass.prototype._tag = id3;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service3) => new this(service3);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen4(this, body);
      }
    });
    TagClass.key = id3;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect4(TagClass, map20(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect4(TagClass, map20(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped2(TagClass, map20(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped2(TagClass, map20(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync4(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed7(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
}, "Service");
var fn = /* @__PURE__ */ __name(function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options4 = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options4,
        errorDef,
        errorCall
      });
    }
  }[name]);
}, "fn");
function defineLength(length4, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length4,
    configurable: true
  });
}
__name(defineLength, "defineLength");
function fnApply(options4) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options4.body)) {
    effect4 = fromIterator(() => options4.body.apply(options4.self, options4.args));
  } else {
    try {
      effect4 = options4.body.apply(options4.self, options4.args);
    } catch (error3) {
      fnError = error3;
      effect4 = die7(error3);
    }
  }
  if (options4.pipeables.length > 0) {
    try {
      for (const x of options4.pipeables) {
        effect4 = x(effect4, ...options4.args);
      }
    } catch (error3) {
      effect4 = fnError ? failCause9(sequential(die(fnError), die(error3))) : die7(error3);
    }
  }
  let cache = false;
  const captureStackTrace = /* @__PURE__ */ __name(() => {
    if (cache !== false) {
      return cache;
    }
    if (options4.errorCall.stack) {
      const stackDef = options4.errorDef.stack.trim().split("\n");
      const stackCall = options4.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  }, "captureStackTrace");
  const opts = options4.spanOptions && "captureStackTrace" in options4.spanOptions ? options4.spanOptions : {
    captureStackTrace,
    ...options4.spanOptions
  };
  return withSpan3(effect4, options4.spanName, opts);
}
__name(fnApply, "fnApply");
var fnUntraced2 = fnUntraced;
var ensureSuccessType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureSuccessType");
var ensureErrorType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureErrorType");
var ensureRequirementsType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureRequirementsType");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map25,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set7,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId19,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose3,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend3,
  failureSchema: () => failureSchema,
  filter: () => filter12,
  filterEffect: () => filterEffect,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head5,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length3,
  lessThan: () => lessThan10,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make47,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit4,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick4,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split2,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend7,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/BigDecimal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId18]: TypeId18,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals3(this, that);
  },
  toString() {
    return `BigDecimal(${format4(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId18), "isBigDecimal");
var make43 = /* @__PURE__ */ __name((value6, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value6;
  o.scale = scale2;
  return o;
}, "make");
var unsafeMakeNormalized = /* @__PURE__ */ __name((value6, scale2) => {
  if (value6 !== bigint04 && value6 % bigint10 === bigint04) {
    throw new RangeError("Value must be normalized");
  }
  const o = make43(value6, scale2);
  o.normalized = o;
  return o;
}, "unsafeMakeNormalized");
var bigint04 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero2 = /* @__PURE__ */ unsafeMakeNormalized(bigint04, 0);
var normalize = /* @__PURE__ */ __name((self2) => {
  if (self2.normalized === void 0) {
    if (self2.value === bigint04) {
      self2.normalized = zero2;
    } else {
      const digits = `${self2.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self2.normalized = self2;
      }
      const value6 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self2.scale - trail;
      self2.normalized = unsafeMakeNormalized(value6, scale2);
    }
  }
  return self2.normalized;
}, "normalize");
var scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
  if (scale2 > self2.scale) {
    return make43(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
  }
  if (scale2 < self2.scale) {
    return make43(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
  }
  return self2;
});
var Order6 = /* @__PURE__ */ make2((self2, that) => {
  const scmp = number3(sign(self2), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self2.scale > that.scale) {
    return bigint(self2.value, scale(that, self2.scale).value);
  }
  if (self2.scale < that.scale) {
    return bigint(scale(self2, that.scale).value, that.value);
  }
  return bigint(self2.value, that.value);
});
var lessThan8 = /* @__PURE__ */ lessThan(Order6);
var lessThanOrEqualTo3 = /* @__PURE__ */ lessThanOrEqualTo(Order6);
var greaterThan4 = /* @__PURE__ */ greaterThan(Order6);
var greaterThanOrEqualTo3 = /* @__PURE__ */ greaterThanOrEqualTo(Order6);
var between3 = /* @__PURE__ */ between(Order6);
var clamp5 = /* @__PURE__ */ clamp(Order6);
var sign = /* @__PURE__ */ __name((n) => n.value === bigint04 ? 0 : n.value < bigint04 ? -1 : 1, "sign");
var abs = /* @__PURE__ */ __name((n) => n.value < bigint04 ? make43(-n.value, n.scale) : n, "abs");
var Equivalence4 = /* @__PURE__ */ make((self2, that) => {
  if (self2.scale > that.scale) {
    return scale(that, self2.scale).value === self2.value;
  }
  if (self2.scale < that.scale) {
    return scale(self2, that.scale).value === that.value;
  }
  return self2.value === that.value;
});
var equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence4(self2, that));
var unsafeFromNumber = /* @__PURE__ */ __name((n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`)), "unsafeFromNumber");
var safeFromNumber = /* @__PURE__ */ __name((n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string7 = `${n}`;
  if (string7.includes("e")) {
    return fromString(string7);
  }
  const [lead, trail = ""] = string7.split(".");
  return some3(make43(BigInt(`${lead}${trail}`), trail.length));
}, "safeFromNumber");
var fromString = /* @__PURE__ */ __name((s) => {
  if (s === "") {
    return some3(zero2);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some3(make43(BigInt(digits), scale2));
}, "fromString");
var format4 = /* @__PURE__ */ __name((n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative2 = normalized.value < bigint04;
  const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location2 = absolute.length - normalized.scale;
    if (location2 > absolute.length) {
      const zeros = location2 - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location2);
      before2 = absolute.slice(0, location2);
    }
  }
  const complete4 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative2 ? `-${complete4}` : complete4;
}, "format");
var toExponential = /* @__PURE__ */ __name((n) => {
  if (isZero2(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head10 = digits.slice(0, 1);
  const tail2 = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head10}`;
  if (tail2 !== "") {
    output += `.${tail2}`;
  }
  const exp = tail2.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
}, "toExponential");
var unsafeToNumber = /* @__PURE__ */ __name((n) => Number(format4(n)), "unsafeToNumber");
var isZero2 = /* @__PURE__ */ __name((n) => n.value === bigint04, "isZero");
var isNegative = /* @__PURE__ */ __name((n) => n.value < bigint04, "isNegative");
var isPositive = /* @__PURE__ */ __name((n) => n.value > bigint04, "isPositive");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/BigInt.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Order7 = bigint;
var clamp6 = /* @__PURE__ */ clamp(Order7);
var toNumber = /* @__PURE__ */ __name((b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some3(Number(b));
}, "toNumber");
var fromString2 = /* @__PURE__ */ __name((s) => {
  try {
    return s.trim() === "" ? none2() : some3(BigInt(s));
  } catch {
    return none2();
  }
}, "fromString");
var fromNumber = /* @__PURE__ */ __name((n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some3(BigInt(n));
  } catch {
    return none2();
  }
}, "fromNumber");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Config.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/config.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ConfigError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var InvalidData2 = InvalidData;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redacted.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto4 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = /* @__PURE__ */ __name((u) => hasProperty(u, RedactedTypeId), "isRedacted");
var make44 = /* @__PURE__ */ __name((value6) => {
  const redacted2 = Object.create(proto4);
  redactedRegistry.set(redacted2, value6);
  return redacted2;
}, "make");
var value = /* @__PURE__ */ __name((self2) => {
  if (redactedRegistry.has(self2)) {
    return redactedRegistry.get(self2);
  } else {
    throw new Error("Unable to get redacted value");
  }
}, "value");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto5 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var map21 = /* @__PURE__ */ dual(2, (self2, f) => mapOrFail(self2, (a) => right2(f(a))));
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
  const mapOrFail3 = Object.create(proto5);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self2;
  mapOrFail3.mapOrFail = f;
  return mapOrFail3;
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name) => {
  const nested3 = Object.create(proto5);
  nested3._tag = OP_NESTED;
  nested3.name = name;
  nested3.config = self2;
  return nested3;
});
var orElseIf = /* @__PURE__ */ dual(2, (self2, options4) => {
  const fallback = Object.create(proto5);
  fallback._tag = OP_FALLBACK;
  fallback.first = self2;
  fallback.second = suspend5(options4.orElse);
  fallback.condition = options4.if;
  return fallback;
});
var primitive = /* @__PURE__ */ __name((description, parse4) => {
  const primitive2 = Object.create(proto5);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse4;
  return primitive2;
}, "primitive");
var string3 = /* @__PURE__ */ __name((name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested2(config2, name);
}, "string");
var succeed11 = /* @__PURE__ */ __name((value6) => {
  const constant3 = Object.create(proto5);
  constant3._tag = OP_CONSTANT;
  constant3.value = value6;
  constant3.parse = () => right2(value6);
  return constant3;
}, "succeed");
var suspend5 = /* @__PURE__ */ __name((config2) => {
  const lazy = Object.create(proto5);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
}, "suspend");
var withDefault = /* @__PURE__ */ dual(2, (self2, def) => orElseIf(self2, {
  orElse: () => succeed11(def),
  if: isMissingDataOnly2
}));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Config.js
var map22 = map21;
var mapOrFail2 = mapOrFail;
var string4 = string3;
var withDefault2 = withDefault;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/DateTime.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context4,
  die: () => die8,
  dieSync: () => dieSync5,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty32,
  extendScope: () => extendScope2,
  fail: () => fail12,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync5,
  failSync: () => failSync5,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap15,
  flatten: () => flatten11,
  fresh: () => fresh2,
  function: () => fromFunction2,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally3,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map23,
  mapError: () => mapError5,
  match: () => match15,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll5,
  mock: () => mock2,
  orDie: () => orDie4,
  orElse: () => orElse8,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped4,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  span: () => span3,
  succeed: () => succeed12,
  succeedContext: () => succeedContext2,
  suspend: () => suspend6,
  sync: () => sync8,
  syncContext: () => syncContext2,
  tap: () => tap5,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService3,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith10
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/layer/circular.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var minimumLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard(fiberRefLocallyScoped(currentMinimumLogLevel, level)), "minimumLogLevel");
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(currentMinimumLogLevel, level)(self2));
var addLogger = /* @__PURE__ */ __name((logger3) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add2(logger3))), "addLogger");
var addLoggerEffect = /* @__PURE__ */ __name((effect4) => unwrapEffect(map11(effect4, addLogger)), "addLoggerEffect");
var addLoggerScoped = /* @__PURE__ */ __name((effect4) => unwrapScoped(map11(effect4, addLogger)), "addLoggerScoped");
var removeLogger = /* @__PURE__ */ __name((logger3) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove5(logger3))), "removeLogger");
var replaceLogger = /* @__PURE__ */ dual(2, (self2, that) => flatMap13(removeLogger(self2), () => addLogger(that)));
var replaceLoggerEffect = /* @__PURE__ */ dual(2, (self2, that) => flatMap13(removeLogger(self2), () => addLoggerEffect(that)));
var replaceLoggerScoped = /* @__PURE__ */ dual(2, (self2, that) => flatMap13(removeLogger(self2), () => addLoggerScoped(that)));
var setConfigProvider = /* @__PURE__ */ __name((configProvider) => scopedDiscard(withConfigProviderScoped(configProvider)), "setConfigProvider");
var parentSpan = /* @__PURE__ */ __name((span4) => succeedContext(make10(spanTag, span4)), "parentSpan");
var span2 = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return scoped2(spanTag, options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit4) => options4.onEnd(span4, exit4))) : makeSpanScoped(name, options4));
}, "span");
var setTracer = /* @__PURE__ */ __name((tracer4) => scopedDiscard(withTracerScoped(tracer4)), "setTracer");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die8 = die5;
var dieSync5 = dieSync2;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty32 = empty30;
var extendScope2 = extendScope;
var fail12 = fail7;
var failSync5 = failSync2;
var failCause10 = failCause6;
var failCauseSync5 = failCauseSync2;
var flatMap15 = flatMap13;
var flatten11 = flatten9;
var fresh2 = fresh;
var mock2 = mock;
var fromFunction2 = fromFunction;
var launch2 = launch;
var map23 = map18;
var mapError5 = mapError3;
var match15 = match13;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll5 = mergeAll3;
var orDie4 = orDie2;
var orElse8 = orElse5;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally3 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped4 = scoped2;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed12 = succeed7;
var succeedContext2 = succeedContext;
var suspend6 = suspend3;
var sync8 = sync4;
var syncContext2 = syncContext;
var tap5 = tap3;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith10 = zipWith7;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = /* @__PURE__ */ __name((clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add4(clockTag, clock3))), "setClock");
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = /* @__PURE__ */ __name((random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add4(randomTag, random4))), "setRandom");
var setRequestBatching = /* @__PURE__ */ __name((requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching)), "setRequestBatching");
var setRequestCaching = /* @__PURE__ */ __name((requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching)), "setRequestCaching");
var setRequestCache = /* @__PURE__ */ __name((cache) => scopedDiscard2(isEffect(cache) ? flatMap9(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache)), "setRequestCache");
var setScheduler = /* @__PURE__ */ __name((scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2)), "setScheduler");
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2)), "setTracerEnabled");
var setTracerTiming = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2)), "setTracerTiming");
var setUnhandledErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level)), "setUnhandledErrorLogLevel");
var setVersionMismatchErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level)), "setVersionMismatchErrorLogLevel");
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer13, tag8, f) => provide3(layer13, map23(context4(), (c) => add4(c, tag8, f(unsafeGet5(c, tag8))))));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/DateTime.js
var isDateTime2 = isDateTime;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence5 = Equivalence2;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake11 = unsafeMake9;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZonedFromString2 = makeZonedFromString;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var toDateUtc2 = toDateUtc;
var toEpochMillis2 = toEpochMillis;
var formatIso3 = formatIso2;
var formatIsoZoned2 = formatIsoZoned;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Encoding.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/base64.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/common.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = /* @__PURE__ */ __name((input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
}, "DecodeException");
var EncodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = /* @__PURE__ */ __name((input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
}, "EncodeException");
var encoder = /* @__PURE__ */ new TextEncoder();
var decoder = /* @__PURE__ */ new TextDecoder();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = /* @__PURE__ */ __name((bytes) => {
  const length4 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length4; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length4 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length4) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}, "encode");
var decode2 = /* @__PURE__ */ __name((str) => {
  const stripped = stripCrlf(str);
  const length4 = stripped.length;
  if (length4 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length4}`));
  }
  const index2 = stripped.indexOf("=");
  if (index2 !== -1 && (index2 < length4 - 2 || index2 === length4 - 2 && stripped[length4 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length4 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length4; i += 4, j += 3) {
      const buffer4 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer4 >> 16;
      result[j + 1] = buffer4 >> 8 & 255;
      result[j + 2] = buffer4 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
}, "decode");
var stripCrlf = /* @__PURE__ */ __name((str) => str.replace(/[\n\r]/g, ""), "stripCrlf");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
__name(getBase64Code, "getBase64Code");
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/base64Url.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var encode2 = /* @__PURE__ */ __name((data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"), "encode");
var decode3 = /* @__PURE__ */ __name((str) => {
  const stripped = stripCrlf(str);
  const length4 = stripped.length;
  if (length4 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length4}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length4 % 4 === 2 ? `${stripped}==` : length4 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
}, "decode");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/hex.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var encode3 = /* @__PURE__ */ __name((bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
}, "encode");
var decode4 = /* @__PURE__ */ __name((str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length4 = bytes.length / 2;
    const result = new Uint8Array(length4);
    for (let i = 0; i < length4; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
}, "decode");
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = /* @__PURE__ */ __name((byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
}, "fromHexChar");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input), "encodeBase64");
var decodeBase64 = /* @__PURE__ */ __name((str) => decode2(str), "decodeBase64");
var decodeBase64String = /* @__PURE__ */ __name((str) => map(decodeBase64(str), (_) => decoder.decode(_)), "decodeBase64String");
var encodeBase64Url = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input), "encodeBase64Url");
var decodeBase64Url = /* @__PURE__ */ __name((str) => decode3(str), "decodeBase64Url");
var decodeBase64UrlString = /* @__PURE__ */ __name((str) => map(decodeBase64Url(str), (_) => decoder.decode(_)), "decodeBase64UrlString");
var encodeHex = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input), "encodeHex");
var decodeHex = /* @__PURE__ */ __name((str) => decode4(str), "decodeHex");
var decodeHexString = /* @__PURE__ */ __name((str) => map(decodeHex(str), (_) => decoder.decode(_)), "decodeHexString");
var encodeUriComponent = /* @__PURE__ */ __name((str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
}), "encodeUriComponent");
var decodeUriComponent = /* @__PURE__ */ __name((str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
}), "decodeUriComponent");
var DecodeException2 = DecodeException;
var EncodeException2 = EncodeException;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/fast-check-default.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/Pre.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var PreconditionFailure = class extends Error {
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err) {
    return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
  }
};
__name(PreconditionFailure, "PreconditionFailure");
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Nil = class {
  [Symbol.iterator]() {
    return this;
  }
  next(value6) {
    return { value: value6, done: true };
  }
};
__name(Nil, "Nil");
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
__name(nilHelper, "nilHelper");
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
__name(mapHelper, "mapHelper");
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
__name(flatMapHelper, "flatMapHelper");
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
__name(filterHelper, "filterHelper");
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
__name(takeNHelper, "takeNHelper");
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
__name(takeWhileHelper, "takeWhileHelper");
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}
__name(joinHelper, "joinHelper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class {
  static nil() {
    return new Stream(nilHelper());
  }
  static of(...elements) {
    return new Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f(v)) {
        foundEligible = true;
        yield v;
      }
    }
    __name(helper, "helper");
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    __name(helper, "helper");
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v of this.g) {
      if (!f(v)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v of this.g) {
      if (f(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last5 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last5 = v;
    }
    return last5;
  }
};
__name(Stream, "Stream");
function stream(g) {
  return new Stream(g);
}
__name(stream, "stream");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
__name(hasCloneMethod, "hasCloneMethod");
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}
__name(cloneIfNeeded, "cloneIfNeeded");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  constructor(value_, context11, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context11;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};
__name(Value, "Value");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
__name(Arbitrary, "Arbitrary");
var ChainArbitrary = class extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src2 = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src2, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return false;
  }
  shrink(value6, context11) {
    if (this.isSafeContext(context11)) {
      return (!context11.stoppedForOriginal ? this.arb.shrink(context11.originalValue, context11.originalContext).map((v) => this.valueChainer(v, context11.clonedMrng.clone(), context11.clonedMrng, context11.originalBias)) : Stream.nil()).join(context11.chainedArbitrary.shrink(value6, context11.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context11), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context11 = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context11);
  }
  isSafeContext(context11) {
    return context11 != null && typeof context11 === "object" && "originalBias" in context11 && "originalValue" in context11 && "originalContext" in context11 && "stoppedForOriginal" in context11 && "chainedArbitrary" in context11 && "chainedContext" in context11 && "clonedMrng" in context11;
  }
};
__name(ChainArbitrary, "ChainArbitrary");
var MapArbitrary = class extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value6) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value6);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value6, context11) {
    if (this.isSafeContext(context11)) {
      return this.arb.shrink(context11.originalValue, context11.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value6);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context11 = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context11);
  }
  isSafeContext(context11) {
    return context11 != null && typeof context11 === "object" && "originalValue" in context11 && "originalContext" in context11;
  }
};
__name(MapArbitrary, "MapArbitrary");
var FilterArbitrary = class extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6) && this.refinement(value6);
  }
  shrink(value6, context11) {
    return this.arb.shrink(value6, context11).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
};
__name(FilterArbitrary, "FilterArbitrary");
var NoShrinkArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
__name(NoShrinkArbitrary, "NoShrinkArbitrary");
var NoBiasArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(value6, context11) {
    return this.arb.shrink(value6, context11);
  }
  noBias() {
    return this;
  }
};
__name(NoBiasArbitrary, "NoBiasArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/tuple.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return void 0;
  }
}
__name(safeExtractApply, "safeExtractApply");
function safeApplyHacky(f, instance, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
__name(safeApplyHacky, "safeApplyHacky");
function safeApply(f, instance, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args2);
  }
  return safeApplyHacky(f, instance, args2);
}
__name(safeApply, "safeApply");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return void 0;
  }
}
__name(extractIndexOf, "extractIndexOf");
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err) {
    return void 0;
  }
}
__name(extractJoin, "extractJoin");
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return void 0;
  }
}
__name(extractMap, "extractMap");
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err) {
    return void 0;
  }
}
__name(extractFilter, "extractFilter");
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return void 0;
  }
}
__name(extractPush, "extractPush");
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return void 0;
  }
}
__name(extractSlice, "extractSlice");
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
__name(safeIndexOf, "safeIndexOf");
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
__name(safeJoin, "safeJoin");
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
__name(safeMap, "safeMap");
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
__name(safeFilter, "safeFilter");
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
__name(safePush, "safePush");
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
__name(safeSlice, "safeSlice");
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err) {
    return void 0;
  }
}
__name(extractGetTime, "extractGetTime");
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err) {
    return void 0;
  }
}
__name(extractToISOString, "extractToISOString");
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
__name(safeGetTime, "safeGetTime");
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
__name(safeToISOString, "safeToISOString");
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
__name(extractMapSet, "extractMapSet");
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
__name(extractMapGet, "extractMapGet");
function safeMapSet(instance, key, value6) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value6);
  }
  return safeApply(untouchedMapSet, instance, [key, value6]);
}
__name(safeMapSet, "safeMapSet");
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
__name(safeMapGet, "safeMapGet");
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err) {
    return void 0;
  }
}
__name(extractSplit, "extractSplit");
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err) {
    return void 0;
  }
}
__name(extractCharCodeAt, "extractCharCodeAt");
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
__name(safeSplit, "safeSplit");
function safeCharCodeAt(instance, index2) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index2);
  }
  return safeApply(untouchedCharCodeAt, instance, [index2]);
}
__name(safeCharCodeAt, "safeCharCodeAt");
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err) {
    return void 0;
  }
}
__name(extractNumberToString, "extractNumberToString");
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
__name(safeNumberToString, "safeNumberToString");
var untouchedToString = Object.prototype.toString;
function safeToString(instance) {
  return safeApply(untouchedToString, instance, []);
}
__name(safeToString, "safeToString");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var LazyIterableIterator = class {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
__name(LazyIterableIterator, "LazyIterableIterator");
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}
__name(makeLazy, "makeLazy");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var safeArrayIsArray = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IRawProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}
__name(runIdToFrequency, "runIdToFrequency");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var globalParameters = {};
function readConfigureGlobal() {
  return globalParameters;
}
__name(readConfigureGlobal, "readConfigureGlobal");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value6) {
  if (value6.context !== void 0) {
    return value6;
  }
  if (value6.hasToBeCloned) {
    return new Value(value6.value_, UndefinedContextPlaceholder, () => value6.value);
  }
  return new Value(value6.value_, UndefinedContextPlaceholder);
}
__name(noUndefinedAsContext, "noUndefinedAsContext");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output = await this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
__name(AsyncProperty, "AsyncProperty");
AsyncProperty.dummyHook = () => {
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.generic.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Property = class {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output = this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
__name(Property, "Property");
Property.dummyHook = () => {
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Runner.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function unsafeGenerateN(rng, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
__name(unsafeGenerateN, "unsafeGenerateN");
function generateN(rng, num) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
__name(generateN, "generateN");
function unsafeSkipN(rng, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng.unsafeNext();
  }
}
__name(unsafeSkipN, "unsafeSkipN");
function skipN(rng, num) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}
__name(skipN, "skipN");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK2 = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = /* @__PURE__ */ __name(function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK2;
}, "computeNextSeed");
var computeValueFromNextSeed = /* @__PURE__ */ __name(function(nextseed) {
  return (nextseed & MASK_2) >> 16;
}, "computeValueFromNextSeed");
var LinearCongruential32 = function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  __name(LinearCongruential322, "LinearCongruential32");
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v3 = computeValueFromNextSeed(this.seed);
    var vnext = v3 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
}();
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
__name(fromState, "fromState");
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
  function MersenneTwister2(states, index2) {
    this.states = states;
    this.index = index2;
  }
  __name(MersenneTwister2, "MersenneTwister");
  MersenneTwister2.twist = function(prev) {
    var mt = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
    mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
    return mt;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y = this.states[this.index];
    y ^= this.states[this.index] >>> MersenneTwister2.U;
    y ^= y << MersenneTwister2.S & MersenneTwister2.B;
    y ^= y << MersenneTwister2.T & MersenneTwister2.C;
    y ^= y >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state) {
    var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state.slice(1), state[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
}();
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
__name(fromState2, "fromState");
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XorShift.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var XorShift128Plus = function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  __name(XorShift128Plus2, "XorShift128Plus");
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
}();
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
__name(fromState3, "fromState");
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var XoroShiro128Plus = function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  __name(XoroShiro128Plus2, "XoroShiro128Plus");
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
}();
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
__name(fromState4, "fromState");
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
__name(addArrayIntToNew, "addArrayIntToNew");
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index2 = data.length - 1; index2 >= 0; --index2) {
    if (data[index2] === 4294967295) {
      data[index2] = 0;
    } else {
      data[index2] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
__name(addOneToPositiveArrayInt, "addOneToPositiveArrayInt");
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index2 = 0; index2 < maxLength2; ++index2) {
    var indexA = index2 + dataA.length - maxLength2;
    var indexB = index2 + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
__name(isStrictlySmaller, "isStrictlySmaller");
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
__name(substractArrayIntToNew, "substractArrayIntToNew");
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
__name(trimArrayIntInplace, "trimArrayIntInplace");
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
__name(fromNumberToArrayInt64, "fromNumberToArrayInt64");
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}
__name(substractArrayInt64, "substractArrayInt64");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}
__name(unsafeUniformIntDistributionInternal, "unsafeUniformIntDistributionInternal");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var indexRangeSize = index2 === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index2] = g;
    }
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var current2 = out[index2];
      var currentInRange = rangeSize[index2];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}
__name(unsafeUniformArrayIntDistributionInternal, "unsafeUniformArrayIntDistributionInternal");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));
}
__name(unsafeUniformArrayIntDistribution, "unsafeUniformArrayIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformArrayIntDistribution, "uniformArrayIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff9 = to - from + SBigInt(1);
  var MinRng = SBigInt(-2147483648);
  var NumValues = SBigInt(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff9) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff9;
  while (true) {
    var value6 = SBigInt(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng.unsafeNext();
      value6 = NumValues * value6 + (SBigInt(out) - MinRng);
    }
    if (value6 < MaxAcceptedRandom) {
      var inDiff = value6 % diff9;
      return inDiff + from;
    }
  }
}
__name(unsafeUniformBigIntDistribution, "unsafeUniformBigIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformBigIntDistribution, "uniformBigIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
__name(uniformLargeIntInternal, "uniformLargeIntInternal");
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}
__name(unsafeUniformIntDistribution, "unsafeUniformIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformIntDistribution, "uniformIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class {
  constructor(op) {
    const p = op || {};
    this.seed = QualifiedParameters.readSeed(p);
    this.randomType = QualifiedParameters.readRandomType(p);
    this.numRuns = QualifiedParameters.readNumRuns(p);
    this.verbose = QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = QualifiedParameters.readOrDefault(p, "logger", (v) => {
      console.log(v);
    });
    this.path = QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined2 = /* @__PURE__ */ __name((value6) => value6 !== null ? value6 : void 0, "orUndefined");
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined2(this.timeout),
      skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined2(this.reporter),
      asyncReporter: orUndefined2(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new QualifiedParameters(op);
  }
};
__name(QualifiedParameters, "QualifiedParameters");
QualifiedParameters.createQualifiedRandomGenerator = (random4) => {
  return (seed) => {
    const rng = random4(seed);
    if (rng.unsafeJump === void 0) {
      rng.unsafeJump = () => unsafeSkipN(rng, 42);
    }
    return rng;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value6 = p[key];
  return value6 != null ? value6 : defaultValue;
};
QualifiedParameters.safeTimeout = (value6) => {
  if (value6 === null) {
    return null;
  }
  return safeMathMin(value6, 2147483647);
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/stringify.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
__name(hasToStringMethod, "hasToStringMethod");
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
__name(hasAsyncToStringMethod, "hasAsyncToStringMethod");
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
__name(getSymbolDescription, "getSymbolDescription");
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
__name(stringifyNumber, "stringifyNumber");
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index2 in arr) {
    const numberedIndex = Number(index2);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
__name(isSparseArray, "isSparseArray");
function stringifyInternal(value6, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value6];
  if (typeof value6 === "object") {
    if (safeIndexOf(previousValues, value6) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value6)) {
    const content = getAsyncContent(value6);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value6)) {
    try {
      return value6[toStringMethod]();
    } catch (err) {
    }
  }
  switch (safeToString(value6)) {
    case "[object Array]": {
      const arr = value6;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index2 in arr) {
          if (!safeNumberIsNaN(Number(index2)))
            safePush(assignments, `${index2}:${stringifyInternal(arr[index2], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value6}n`;
    case "[object Boolean]": {
      const unboxedToString = value6 == true ? "true" : "false";
      return typeof value6 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value6;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value6 === "number" ? stringifyNumber(value6) : `new Number(${stringifyNumber(Number(value6))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value6.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value6.toString();
        }
      } catch (err) {
        return "[object Object]";
      }
      const mapper = /* @__PURE__ */ __name((k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value6[k], currentValues, getAsyncContent)}`, "mapper");
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value6), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value6), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value6, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value6) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value6 === "string" ? safeJsonStringify(value6) : `new String(${safeJsonStringify(value6)})`;
    case "[object Symbol]": {
      const s = value6;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value6);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value6 instanceof Error) {
        return `new Error(${stringifyInternal(value6.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value6)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value6.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value6);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray = value6;
        const valuesFromTypedArr = typedArray.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value6.toString();
  } catch (_a) {
    return safeToString(value6);
  }
}
__name(stringifyInternal, "stringifyInternal");
function stringify(value6) {
  return stringifyInternal(value6, [], () => ({ state: "unknown", value: void 0 }));
}
__name(stringify, "stringify");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class {
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status3, value6) {
    const currentTree = { status: status3, value: value6, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value6, id3, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value6);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id3}`;
    else
      this.pathToFailure += `:${id3}`;
    this.value = value6;
    this.failure = failure;
  }
  skip(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures3 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures3.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures3;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
__name(RunExecution, "RunExecution");
RunExecution.mergePaths = (offsetPath, path) => {
  if (offsetPath.length === 0)
    return path;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
var RunnerIterator = class {
  constructor(sourceValues, shrink, verbose, interruptedAsFailure) {
    this.sourceValues = sourceValues;
    this.shrink = shrink;
    this.runExecution = new RunExecution(verbose, interruptedAsFailure);
    this.currentIdx = -1;
    this.nextValues = sourceValues;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const nextValue = this.nextValues.next();
    if (nextValue.done || this.runExecution.interrupted) {
      return { done: true, value: void 0 };
    }
    this.currentValue = nextValue.value;
    ++this.currentIdx;
    return { done: false, value: nextValue.value.value_ };
  }
  handleResult(result) {
    if (result != null && typeof result === "object" && !PreconditionFailure.isFailure(result)) {
      this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
      this.currentIdx = -1;
      this.nextValues = this.shrink(this.currentValue);
    } else if (result != null) {
      if (!result.interruptExecution) {
        this.runExecution.skip(this.currentValue.value_);
        this.sourceValues.skippedOne();
      } else {
        this.runExecution.interrupt();
      }
    } else {
      this.runExecution.success(this.currentValue.value_);
    }
  }
};
__name(RunnerIterator, "RunnerIterator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SourceValuesIterator = class {
  constructor(initialValues, maxInitialIterations, remainingSkips) {
    this.initialValues = initialValues;
    this.maxInitialIterations = maxInitialIterations;
    this.remainingSkips = remainingSkips;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
      const n = this.initialValues.next();
      if (!n.done)
        return { value: n.value, done: false };
    }
    return { value: void 0, done: true };
  }
  skippedOne() {
    --this.remainingSkips;
    ++this.maxInitialIterations;
  }
};
__name(SourceValuesIterator, "SourceValuesIterator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Tosser.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/random/generator/Random.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Random = class {
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new Random(this.internalRng);
  }
  next(bits) {
    return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min5, max8) {
    return unsafeUniformIntDistribution(min5 == null ? Random.MIN_INT : min5, max8 == null ? Random.MAX_INT : max8, this.internalRng);
  }
  nextBigInt(min5, max8) {
    return unsafeUniformBigIntDistribution(min5, max8, this.internalRng);
  }
  nextArrayInt(min5, max8) {
    return unsafeUniformArrayIntDistribution(min5, max8, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b = this.next(27);
    return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
__name(Random, "Random");
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Sampler.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/gen.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeArrayIsArray2 = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
__name(integerLogLike, "integerLogLike");
function biasNumericRange(min5, max8, logLike) {
  if (min5 === max8) {
    return [{ min: min5, max: max8 }];
  }
  if (min5 < 0 && max8 > 0) {
    const logMin = logLike(-min5);
    const logMax = logLike(max8);
    return [
      { min: -logMin, max: logMax },
      { min: max8 - logMax, max: max8 },
      { min: min5, max: min5 + logMin }
    ];
  }
  const logGap = logLike(max8 - min5);
  const arbCloseToMin = { min: min5, max: min5 + logGap };
  const arbCloseToMax = { min: max8 - logGap, max: max8 };
  return min5 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}
__name(biasNumericRange, "biasNumericRange");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
__name(halvePosInteger, "halvePosInteger");
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
__name(halveNegInteger, "halveNegInteger");
function shrinkInteger(current2, target2, tryTargetAsap) {
  const realGap = current2 - target2;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target2;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next = toremove === realGap ? target2 : current2 - toremove;
      yield new Value(next, previous2);
      previous2 = next;
    }
  }
  __name(shrinkDecr, "shrinkDecr");
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target2;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next = toremove === realGap ? target2 : current2 - toremove;
      yield new Value(next, previous2);
      previous2 = next;
    }
  }
  __name(shrinkIncr, "shrinkIncr");
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}
__name(shrinkInteger, "shrinkInteger");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;
var IntegerArbitrary = class extends Arbitrary {
  constructor(min5, max8) {
    super();
    this.min = min5;
    this.max = max8;
  }
  generate(mrng, biasFactor) {
    const range4 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range4.min, range4.max), void 0);
  }
  canShrinkWithoutContext(value6) {
    return typeof value6 === "number" && safeNumberIsInteger(value6) && !safeObjectIs(value6, -0) && this.min <= value6 && value6 <= this.max;
  }
  shrink(current2, context11) {
    if (!IntegerArbitrary.isValidContext(current2, context11)) {
      const target2 = this.defaultTarget();
      return shrinkInteger(current2, target2, true);
    }
    if (this.isLastChanceTry(current2, context11)) {
      return Stream.of(new Value(context11, void 0));
    }
    return shrinkInteger(current2, context11, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  isLastChanceTry(current2, context11) {
    if (current2 > 0)
      return current2 === context11 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context11 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context11) {
    if (context11 === void 0) {
      return false;
    }
    if (typeof context11 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context11 !== 0 && safeMathSign(current2) !== safeMathSign(context11)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};
__name(IntegerArbitrary, "IntegerArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min5 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max8 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min5, max: max8 };
}
__name(buildCompleteIntegerConstraints, "buildCompleteIntegerConstraints");
function integer2(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}
__name(integer2, "integer");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context11 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context11);
  return context11;
}
__name(getDepthContextFor, "getDepthContextFor");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var NoopSlicedGenerator = class {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};
__name(NoopSlicedGenerator, "NoopSlicedGenerator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index2 = 0; index2 !== this.slices.length; ++index2) {
        const slice = this.slices[index2];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index2);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], void 0);
  }
};
__name(SlicedBasedGenerator, "SlicedBasedGenerator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}
__name(buildSlicedGenerator, "buildSlicedGenerator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray3 = Array.isArray;
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
__name(biasedMaxLength, "biasedMaxLength");
var ArrayArbitrary = class extends Arbitrary {
  constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength2;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength2;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer2({ min: minLength2, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index2 = 0; index2 !== tab.length; ++index2) {
      s.tryAdd(tab[index2]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index2 = 0; index2 !== N; ++index2) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context11 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context11);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer2({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value6) {
    if (!safeArrayIsArray3(value6) || this.minLength > value6.length || value6.length > this.maxLength) {
      return false;
    }
    for (let index2 = 0; index2 !== value6.length; ++index2) {
      if (!(index2 in value6)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value6[index2])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value6, (item) => new Value(item, void 0)));
    return filtered.length === value6.length;
  }
  shrinkItemByItem(value6, safeContext, endIndex) {
    const shrinks = [];
    for (let index2 = safeContext.startIndex; index2 < endIndex; ++index2) {
      safePush(shrinks, makeLazy(() => this.arb.shrink(value6[index2], safeContext.itemsContexts[index2]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value6, 0, index2), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value6, index2 + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index2 + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          void 0,
          index2
        ];
      })));
    }
    return Stream.nil().join(...shrinks);
  }
  shrinkImpl(value6, context11) {
    if (value6.length === 0) {
      return Stream.nil();
    }
    const safeContext = context11 !== void 0 ? context11 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value6.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value6.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value6.length - lengthValue.value;
      return [
        safeMap(safeSlice(value6, sliceStart), (v, index2) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index2 + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value6.length > this.minLength ? this.shrinkItemByItem(value6, safeContext, 1) : this.shrinkItemByItem(value6, safeContext, value6.length))).join(value6.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value6, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value6[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value6, context11) {
    return this.shrinkImpl(value6, context11).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};
__name(ArrayArbitrary, "ArrayArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength2, size18) {
  switch (size18) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size18}`);
  }
}
__name(maxLengthFromMinLength, "maxLengthFromMinLength");
function relativeSizeToSize(size18, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size18);
  if (sizeInRelative === -1) {
    return size18;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
__name(relativeSizeToSize, "relativeSizeToSize");
function maxGeneratedLengthFromSizeForArbitrary(size18, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size18 !== void 0 ? size18 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}
__name(maxGeneratedLengthFromSizeForArbitrary, "maxGeneratedLengthFromSizeForArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array5(arb, constraints = {}) {
  const size18 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size18, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}
__name(array5, "array");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigInt.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigIntN.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUint.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUintN.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/boolean.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/noBias.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/falsy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ascii.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}
__name(indexToCharStringUnmapper, "indexToCharStringUnmapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min5, max8, mapToCode, unmapFromCode) {
  return integer2({ min: min5, max: max8 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}
__name(buildCharacterArbitrary, "buildCharacterArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
__name(indexToPrintableIndexMapper, "indexToPrintableIndexMapper");
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}
__name(indexToPrintableIndexUnmapper, "indexToPrintableIndexUnmapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/base64.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function identity2(v) {
  return v;
}
__name(identity2, "identity");
function char() {
  return buildCharacterArbitrary(32, 126, identity2, identity2);
}
__name(char, "char");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char16bits.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
__name(unicodeMapper, "unicodeMapper");
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
__name(unicodeUnmapper, "unicodeUnmapper");
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}
__name(fullUnicode, "fullUnicode");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/hexa.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicode.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var gapSize2 = 57343 + 1 - 55296;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constant.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/context.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ContextImplem = class {
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new ContextImplem();
  }
};
__name(ContextImplem, "ContextImplem");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/clone.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeIsArray = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/dictionary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNumberIsNaN4 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/emailAddress.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/oneof.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/nat.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNumberIsInteger4 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var safeStringFromCharCode = String.fromCharCode;
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
__name(percentCharArbMapper, "percentCharArbMapper");
function percentCharArbUnmapper(value6) {
  if (typeof value6 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value6);
  return decoded;
}
__name(percentCharArbUnmapper, "percentCharArbUnmapper");
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/domain.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/option.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/string.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeStringFromCodePoint = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var AdaptedValue = Symbol("adapted-value");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer, f64.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNumberIsInteger5 = Number.isInteger;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var f32 = new Float32Array(1);
var u322 = new Uint32Array(f32.buffer, f32.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}
__name(escapeForTemplateString, "escapeForTemplateString");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/hash.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/noShrink.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/compareFunc.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/func.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV4.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var safeNumberParseInt = Number.parseInt;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV6.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/hexaString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/letrec.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/lorem.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/memo.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/mixedCase.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/object.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float32Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float64Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int16Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int32Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int8Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeArrayIsArray4 = SArray.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/json.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/jsonValue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/anything.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/record.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/asciiString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/base64String.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/string16bits.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringOf.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/subarray.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var safeArrayIsArray5 = Array.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
function encodeSymbol(symbol6) {
  return symbol6 < 10 ? SString(symbol6) : encodeSymbolLookupTable[symbol6];
}
__name(encodeSymbol, "encodeSymbol");
function pad(value6, paddingLength) {
  let extraPadding = "";
  while (value6.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value6;
}
__name(pad, "pad");
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next = remaining >> 5;
    const current2 = remaining - (next << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next;
  }
  return base32Str;
}
__name(smallUintToBase32StringMapper, "smallUintToBase32StringMapper");
function uintToBase32StringMapper(num, paddingLength) {
  const head10 = ~~(num / 1073741824);
  const tail2 = num & 1073741823;
  return pad(smallUintToBase32StringMapper(head10), paddingLength - 6) + pad(smallUintToBase32StringMapper(tail2), 6);
}
__name(uintToBase32StringMapper, "uintToBase32StringMapper");
function paddedUintToBase32StringMapper(paddingLength) {
  return /* @__PURE__ */ __name(function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  }, "padded");
}
__name(paddedUintToBase32StringMapper, "paddedUintToBase32StringMapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uuid.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uuidV.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webAuthority.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webFragments.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webPath.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webSegment.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webUrl.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/commands.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var CommandsIterable = class {
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};
__name(CommandsIterable, "CommandsIterable");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/ReplayPath.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/ModelRunner.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/scheduler.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var defaultSchedulerAct = /* @__PURE__ */ __name((f) => f(), "defaultSchedulerAct");
var SchedulerImplem = class {
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status3, data) {
    this.triggeredTasks.push({
      status: status3,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve3, reject) => {
      trigger = /* @__PURE__ */ __name(() => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve3(data);
        }, (err) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err);
          return reject(err);
        });
      }, "trigger");
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status3 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: (f) => f() };
    let resolveSequenceTask = /* @__PURE__ */ __name(() => {
    }, "resolveSequenceTask");
    const sequenceTask = new Promise((resolve3) => resolveSequenceTask = resolve3);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status3.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status3.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status3, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status3.done, faulty: status3.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = /* @__PURE__ */ __name(async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    }, "awaiter");
    const handleNotified = /* @__PURE__ */ __name(() => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    }, "handleNotified");
    const clearAndReplaceWatcher = /* @__PURE__ */ __name(() => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    }, "clearAndReplaceWatcher");
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(SchedulerImplem.buildLog).map((log5) => `-> ${log5}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};
__name(SchedulerImplem, "SchedulerImplem");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/limitShrink.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/errors.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/util.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var getKeysForIndexSignature = /* @__PURE__ */ __name((input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
}, "getKeysForIndexSignature");
var memoizeThunk = /* @__PURE__ */ __name((f) => {
  let done12 = false;
  let a;
  return () => {
    if (done12) {
      return a;
    }
    a = f();
    done12 = true;
    return a;
  };
}, "memoizeThunk");
var formatDate = /* @__PURE__ */ __name((date4) => {
  try {
    return date4.toISOString();
  } catch {
    return String(date4);
  }
}, "formatDate");
var CIRCULAR = "[Circular]";
function formatUnknown(input, whitespace = 0) {
  const seen = /* @__PURE__ */ new WeakSet();
  const gap = !whitespace ? "" : typeof whitespace === "number" ? " ".repeat(whitespace) : whitespace;
  const ind = /* @__PURE__ */ __name((d) => gap.repeat(d), "ind");
  const safeToString2 = /* @__PURE__ */ __name((x) => {
    try {
      const s = x.toString();
      return typeof s === "string" ? s : String(s);
    } catch {
      return "[toString threw]";
    }
  }, "safeToString");
  const wrap2 = /* @__PURE__ */ __name((v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  }, "wrap");
  const ownKeys = /* @__PURE__ */ __name((o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  }, "ownKeys");
  function go3(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1)
        return `[${v.map((x) => go3(x, d)).join(",")}]`;
      const inner = v.map((x) => go3(x, d + 1)).join(",\n" + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v))
      return formatDate(v);
    if (hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString)
      return safeToString2(v);
    if (isString(v))
      return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v))
      return String(v);
    if (isBigInt(v))
      return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go3(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      const keys6 = ownKeys(v);
      if (!gap || keys6.length <= 1) {
        const body2 = `{${keys6.map((k) => `${formatPropertyKey(k)}:${go3(v[k], d)}`).join(",")}}`;
        return wrap2(v, body2);
      }
      const body = `{
${keys6.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go3(v[k], d + 1)}`).join(",\n")}
${ind(d)}}`;
      return wrap2(v, body);
    }
    return String(v);
  }
  __name(go3, "go");
  return go3(input, 0);
}
__name(formatUnknown, "formatUnknown");
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
__name(formatPropertyKey, "formatPropertyKey");
var isNonEmpty6 = /* @__PURE__ */ __name((x) => Array.isArray(x), "isNonEmpty");
var isSingle = /* @__PURE__ */ __name((x) => !Array.isArray(x), "isSingle");
var formatPathKey = /* @__PURE__ */ __name((key) => `[${formatPropertyKey(key)}]`, "formatPathKey");
var formatPath = /* @__PURE__ */ __name((path) => isNonEmpty6(path) ? path.map(formatPathKey).join("") : formatPathKey(path), "formatPath");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = /* @__PURE__ */ __name((reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
}, "getErrorMessage");
var getInvalidArgumentErrorMessage = /* @__PURE__ */ __name((details) => getErrorMessage("Invalid Argument", details), "getInvalidArgumentErrorMessage");
var getUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast), "getUnsupportedSchemaErrorMessage");
var getEquivalenceUnsupportedErrorMessage = /* @__PURE__ */ __name((ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast), "getEquivalenceUnsupportedErrorMessage");
var getSchemaExtendErrorMessage = /* @__PURE__ */ __name((x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path), "getSchemaExtendErrorMessage");
var getSchemaUnsupportedLiteralSpanErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast), "getSchemaUnsupportedLiteralSpanErrorMessage");
var getASTUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedSchemaErrorMessage");
var getASTUnsupportedKeySchemaErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast), "getASTUnsupportedKeySchemaErrorMessage");
var getASTUnsupportedLiteralErrorMessage = /* @__PURE__ */ __name((literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`), "getASTUnsupportedLiteralErrorMessage");
var getASTDuplicateIndexSignatureErrorMessage = /* @__PURE__ */ __name((type3) => getErrorMessage("Duplicate index signature", `${type3} index signature`), "getASTDuplicateIndexSignatureErrorMessage");
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureTransformationErrorMessage");
var getASTUnsupportedRenameSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedRenameSchemaErrorMessage");
var getASTDuplicatePropertySignatureErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureErrorMessage");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/schemaId.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ParseResult.js
var ParseResult_exports = {};
__export(ParseResult_exports, {
  ArrayFormatter: () => ArrayFormatter,
  Composite: () => Composite2,
  Forbidden: () => Forbidden,
  Missing: () => Missing,
  ParseError: () => ParseError,
  ParseErrorTypeId: () => ParseErrorTypeId,
  Pointer: () => Pointer,
  Refinement: () => Refinement2,
  Transformation: () => Transformation2,
  TreeFormatter: () => TreeFormatter,
  Type: () => Type2,
  Unexpected: () => Unexpected,
  asserts: () => asserts,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown2,
  decodeUnknownEither: () => decodeUnknownEither,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  eitherOrUndefined: () => eitherOrUndefined,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown,
  encodeUnknownEither: () => encodeUnknownEither,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  fail: () => fail13,
  flatMap: () => flatMap16,
  fromOption: () => fromOption4,
  getFinalTransformation: () => getFinalTransformation,
  getLiterals: () => getLiterals,
  getOption: () => getOption3,
  getRefinementExpected: () => getRefinementExpected,
  getSearchTree: () => getSearchTree,
  is: () => is,
  isComposite: () => isComposite2,
  isParseError: () => isParseError,
  map: () => map24,
  mapBoth: () => mapBoth5,
  mapError: () => mapError6,
  mergeInternalOptions: () => mergeInternalOptions,
  orElse: () => orElse9,
  parseError: () => parseError,
  succeed: () => succeed13,
  try: () => _try,
  validate: () => validate4,
  validateEither: () => validateEither,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/SchemaAST.js
var SchemaAST_exports = {};
__export(SchemaAST_exports, {
  AnyKeyword: () => AnyKeyword,
  ArbitraryAnnotationId: () => ArbitraryAnnotationId,
  AutoTitleAnnotationId: () => AutoTitleAnnotationId,
  BatchingAnnotationId: () => BatchingAnnotationId,
  BigIntKeyword: () => BigIntKeyword,
  BooleanKeyword: () => BooleanKeyword,
  BrandAnnotationId: () => BrandAnnotationId,
  ComposeTransformation: () => ComposeTransformation,
  ConcurrencyAnnotationId: () => ConcurrencyAnnotationId,
  Declaration: () => Declaration,
  DecodingFallbackAnnotationId: () => DecodingFallbackAnnotationId,
  DefaultAnnotationId: () => DefaultAnnotationId,
  DescriptionAnnotationId: () => DescriptionAnnotationId,
  DocumentationAnnotationId: () => DocumentationAnnotationId,
  Enums: () => Enums,
  EquivalenceAnnotationId: () => EquivalenceAnnotationId,
  ExamplesAnnotationId: () => ExamplesAnnotationId,
  FinalTransformation: () => FinalTransformation,
  IdentifierAnnotationId: () => IdentifierAnnotationId,
  IndexSignature: () => IndexSignature,
  JSONIdentifierAnnotationId: () => JSONIdentifierAnnotationId,
  JSONSchemaAnnotationId: () => JSONSchemaAnnotationId,
  Literal: () => Literal,
  MessageAnnotationId: () => MessageAnnotationId,
  MissingMessageAnnotationId: () => MissingMessageAnnotationId,
  NeverKeyword: () => NeverKeyword,
  NumberKeyword: () => NumberKeyword,
  ObjectKeyword: () => ObjectKeyword,
  OptionalType: () => OptionalType,
  ParseIssueTitleAnnotationId: () => ParseIssueTitleAnnotationId,
  ParseJsonSchemaId: () => ParseJsonSchemaId,
  ParseOptionsAnnotationId: () => ParseOptionsAnnotationId,
  PrettyAnnotationId: () => PrettyAnnotationId,
  PropertySignature: () => PropertySignature,
  PropertySignatureTransformation: () => PropertySignatureTransformation,
  Refinement: () => Refinement,
  SchemaIdAnnotationId: () => SchemaIdAnnotationId,
  StableFilterAnnotationId: () => StableFilterAnnotationId,
  StringKeyword: () => StringKeyword,
  SurrogateAnnotationId: () => SurrogateAnnotationId,
  Suspend: () => Suspend,
  SymbolKeyword: () => SymbolKeyword,
  TemplateLiteral: () => TemplateLiteral,
  TemplateLiteralSpan: () => TemplateLiteralSpan,
  TitleAnnotationId: () => TitleAnnotationId,
  Transformation: () => Transformation,
  TupleType: () => TupleType,
  Type: () => Type,
  TypeLiteral: () => TypeLiteral,
  TypeLiteralTransformation: () => TypeLiteralTransformation,
  UndefinedKeyword: () => UndefinedKeyword,
  Union: () => Union,
  UniqueSymbol: () => UniqueSymbol,
  UnknownKeyword: () => UnknownKeyword,
  VoidKeyword: () => VoidKeyword,
  annotations: () => annotations,
  anyKeyword: () => anyKeyword,
  bigIntKeyword: () => bigIntKeyword,
  booleanKeyword: () => booleanKeyword,
  compose: () => compose2,
  composeTransformation: () => composeTransformation,
  defaultParseOption: () => defaultParseOption,
  encodedAST: () => encodedAST,
  encodedBoundAST: () => encodedBoundAST,
  equals: () => equals4,
  flatten: () => flatten12,
  getAnnotation: () => getAnnotation,
  getAutoTitleAnnotation: () => getAutoTitleAnnotation,
  getBatchingAnnotation: () => getBatchingAnnotation,
  getBrandAnnotation: () => getBrandAnnotation,
  getCompiler: () => getCompiler,
  getConcurrencyAnnotation: () => getConcurrencyAnnotation,
  getDecodingFallbackAnnotation: () => getDecodingFallbackAnnotation,
  getDefaultAnnotation: () => getDefaultAnnotation,
  getDescriptionAnnotation: () => getDescriptionAnnotation,
  getDocumentationAnnotation: () => getDocumentationAnnotation,
  getEncodedParameter: () => getEncodedParameter,
  getExamplesAnnotation: () => getExamplesAnnotation,
  getIdentifierAnnotation: () => getIdentifierAnnotation,
  getJSONIdentifier: () => getJSONIdentifier,
  getJSONIdentifierAnnotation: () => getJSONIdentifierAnnotation,
  getJSONSchemaAnnotation: () => getJSONSchemaAnnotation,
  getMessageAnnotation: () => getMessageAnnotation,
  getMissingMessageAnnotation: () => getMissingMessageAnnotation,
  getNumberIndexedAccess: () => getNumberIndexedAccess,
  getParseIssueTitleAnnotation: () => getParseIssueTitleAnnotation,
  getParseOptionsAnnotation: () => getParseOptionsAnnotation,
  getPropertyKeyIndexedAccess: () => getPropertyKeyIndexedAccess,
  getPropertySignatures: () => getPropertySignatures,
  getSchemaIdAnnotation: () => getSchemaIdAnnotation,
  getSurrogateAnnotation: () => getSurrogateAnnotation,
  getTemplateLiteralCapturingRegExp: () => getTemplateLiteralCapturingRegExp,
  getTemplateLiteralRegExp: () => getTemplateLiteralRegExp,
  getTitleAnnotation: () => getTitleAnnotation,
  getTransformationFrom: () => getTransformationFrom,
  hasStableFilter: () => hasStableFilter,
  isAnyKeyword: () => isAnyKeyword,
  isBigIntKeyword: () => isBigIntKeyword,
  isBooleanKeyword: () => isBooleanKeyword,
  isComposeTransformation: () => isComposeTransformation,
  isDeclaration: () => isDeclaration,
  isEnums: () => isEnums,
  isFinalTransformation: () => isFinalTransformation,
  isLiteral: () => isLiteral,
  isMembers: () => isMembers,
  isNeverKeyword: () => isNeverKeyword,
  isNumberKeyword: () => isNumberKeyword,
  isObjectKeyword: () => isObjectKeyword,
  isParameter: () => isParameter,
  isRefinement: () => isRefinement,
  isStringKeyword: () => isStringKeyword,
  isSuspend: () => isSuspend,
  isSymbolKeyword: () => isSymbolKeyword,
  isTemplateLiteral: () => isTemplateLiteral,
  isTransformation: () => isTransformation,
  isTupleType: () => isTupleType,
  isTypeLiteral: () => isTypeLiteral,
  isTypeLiteralTransformation: () => isTypeLiteralTransformation,
  isUndefinedKeyword: () => isUndefinedKeyword,
  isUnion: () => isUnion,
  isUniqueSymbol: () => isUniqueSymbol,
  isUnknownKeyword: () => isUnknownKeyword,
  isVoidKeyword: () => isVoidKeyword,
  keyof: () => keyof,
  mapMembers: () => mapMembers,
  mutable: () => mutable,
  neverKeyword: () => neverKeyword,
  null: () => $null,
  numberKeyword: () => numberKeyword,
  objectKeyword: () => objectKeyword,
  omit: () => omit2,
  omitAnnotations: () => omitAnnotations,
  orUndefined: () => orUndefined,
  partial: () => partial,
  pick: () => pick2,
  pickAnnotations: () => pickAnnotations,
  pruneUndefined: () => pruneUndefined,
  record: () => record2,
  rename: () => rename,
  required: () => required,
  stringKeyword: () => stringKeyword,
  symbolKeyword: () => symbolKeyword,
  typeAST: () => typeAST,
  undefinedKeyword: () => undefinedKeyword,
  unify: () => unify,
  unknownKeyword: () => unknownKeyword,
  voidKeyword: () => voidKeyword
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some3(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getSchemaIdAnnotation = /* @__PURE__ */ getAnnotation(SchemaIdAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = /* @__PURE__ */ getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = /* @__PURE__ */ getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = /* @__PURE__ */ getAnnotation(JSONSchemaAnnotationId);
var getDocumentationAnnotation = /* @__PURE__ */ getAnnotation(DocumentationAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = /* @__PURE__ */ __name((annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true), "hasStableFilter");
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = /* @__PURE__ */ __name((annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated)), "getJSONIdentifier");
var ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown4, encodeUnknown3, annotations3 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(Declaration, "Declaration");
var createASTGuard = /* @__PURE__ */ __name((tag8) => (ast) => ast._tag === tag8, "createASTGuard");
var isDeclaration = /* @__PURE__ */ createASTGuard("Declaration");
var Literal = class {
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal2, annotations3 = {}) {
    this.literal = literal2;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(Literal, "Literal");
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var $null = /* @__PURE__ */ new Literal(null);
var UniqueSymbol = class {
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol6, annotations3 = {}) {
    this.symbol = symbol6;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(UniqueSymbol, "UniqueSymbol");
var isUniqueSymbol = /* @__PURE__ */ createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(UndefinedKeyword, "UndefinedKeyword");
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var isUndefinedKeyword = /* @__PURE__ */ createASTGuard("UndefinedKeyword");
var VoidKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "VoidKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(VoidKeyword, "VoidKeyword");
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var isVoidKeyword = /* @__PURE__ */ createASTGuard("VoidKeyword");
var NeverKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(NeverKeyword, "NeverKeyword");
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(UnknownKeyword, "UnknownKeyword");
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var isUnknownKeyword = /* @__PURE__ */ createASTGuard("UnknownKeyword");
var AnyKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(AnyKeyword, "AnyKeyword");
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var isAnyKeyword = /* @__PURE__ */ createASTGuard("AnyKeyword");
var StringKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(StringKeyword, "StringKeyword");
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(NumberKeyword, "NumberKeyword");
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(BooleanKeyword, "BooleanKeyword");
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(BigIntKeyword, "BigIntKeyword");
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var isBigIntKeyword = /* @__PURE__ */ createASTGuard("BigIntKeyword");
var SymbolKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(SymbolKeyword, "SymbolKeyword");
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(ObjectKeyword, "ObjectKeyword");
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var isObjectKeyword = /* @__PURE__ */ createASTGuard("ObjectKeyword");
var Enums = class {
  enums;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Enums";
  constructor(enums, annotations3 = {}) {
    this.enums = enums;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value6]) => JSON.stringify(value6)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(Enums, "Enums");
var isEnums = /* @__PURE__ */ createASTGuard("Enums");
var isTemplateLiteralSpanType = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
}, "isTemplateLiteralSpanType");
var templateLiteralSpanUnionTypeToString = /* @__PURE__ */ __name((type3) => {
  switch (type3._tag) {
    case "Literal":
      return JSON.stringify(String(type3.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type3);
    case "Union":
      return type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
}, "templateLiteralSpanUnionTypeToString");
var templateLiteralSpanTypeToString = /* @__PURE__ */ __name((type3) => {
  switch (type3._tag) {
    case "Literal":
      return String(type3.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type3) + "}";
    case "Union":
      return "${" + type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
}, "templateLiteralSpanTypeToString");
var TemplateLiteralSpan = class {
  literal;
  /**
   * @since 3.10.0
   */
  type;
  constructor(type3, literal2) {
    this.literal = literal2;
    if (isTemplateLiteralSpanType(type3)) {
      this.type = type3;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type3));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
__name(TemplateLiteralSpan, "TemplateLiteralSpan");
var TemplateLiteral = class {
  head;
  spans;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TemplateLiteral";
  constructor(head10, spans, annotations3 = {}) {
    this.head = head10;
    this.spans = spans;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(TemplateLiteral, "TemplateLiteral");
var formatTemplateLiteral = /* @__PURE__ */ __name((ast) => "`" + ast.head + ast.spans.map(String).join("") + "`", "formatTemplateLiteral");
var isTemplateLiteral = /* @__PURE__ */ createASTGuard("TemplateLiteral");
var Type = class {
  type;
  annotations;
  constructor(type3, annotations3 = {}) {
    this.type = type3;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
__name(Type, "Type");
var OptionalType = class extends Type {
  isOptional;
  constructor(type3, isOptional, annotations3 = {}) {
    super(type3, annotations3);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
__name(OptionalType, "OptionalType");
var getRestASTs = /* @__PURE__ */ __name((rest) => rest.map((annotatedAST) => annotatedAST.type), "getRestASTs");
var TupleType = class {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations3 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations3;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(TupleType, "TupleType");
var formatTuple = /* @__PURE__ */ __name((ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head10, tail2) => {
      const formattedHead = String(head10);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail2.length > 0) {
        const formattedTail = tail2.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
}, "formatTuple");
var isTupleType = /* @__PURE__ */ createASTGuard("TupleType");
var PropertySignature = class extends OptionalType {
  name;
  isReadonly;
  constructor(name, type3, isOptional, isReadonly, annotations3) {
    super(type3, isOptional, annotations3);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(PropertySignature, "PropertySignature");
var isParameter = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
}, "isParameter");
var IndexSignature = class {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type3, isReadonly) {
    this.type = type3;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
__name(IndexSignature, "IndexSignature");
var TypeLiteral = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations3 = {}) {
    this.annotations = annotations3;
    const keys6 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(TypeLiteral, "TypeLiteral");
var formatIndexSignatures = /* @__PURE__ */ __name((iss) => iss.map(String).join("; "), "formatIndexSignatures");
var formatTypeLiteral = /* @__PURE__ */ __name((ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
}, "formatTypeLiteral");
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput3(Order2, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten12 = /* @__PURE__ */ __name((candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten12(ast.types) : [ast]), "flatten");
var unify = /* @__PURE__ */ __name((candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type3 = typeof ast.literal;
        switch (type3) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type3];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
}, "unify");
var _Union = class {
  types;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations3 = {}) {
    this.types = types;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var Union = _Union;
__name(Union, "Union");
__publicField(Union, "make", (types, annotations3) => {
  return isMembers(types) ? new _Union(types, annotations3) : types.length === 1 ? types[0] : neverKeyword;
});
/** @internal */
__publicField(Union, "unify", (candidates, annotations3) => {
  return _Union.make(unify(flatten12(candidates)), annotations3);
});
var mapMembers = /* @__PURE__ */ __name((members, f) => members.map(f), "mapMembers");
var isMembers = /* @__PURE__ */ __name((as14) => as14.length > 1, "isMembers");
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f, annotations3 = {}) {
    this.f = f;
    this.annotations = annotations3;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
__name(Suspend, "Suspend");
var isSuspend = /* @__PURE__ */ createASTGuard("Suspend");
var Refinement = class {
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter15, annotations3 = {}) {
    this.from = from;
    this.filter = filter15;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(Refinement, "Refinement");
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations3 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__name(Transformation, "Transformation");
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode8, encode7) {
    this.decode = decode8;
    this.encode = encode7;
  }
};
__name(FinalTransformation, "FinalTransformation");
var createTransformationGuard = /* @__PURE__ */ __name((tag8) => (ast) => ast._tag === tag8, "createTransformationGuard");
var isFinalTransformation = /* @__PURE__ */ createTransformationGuard("FinalTransformation");
var ComposeTransformation = class {
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
__name(ComposeTransformation, "ComposeTransformation");
var composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var isComposeTransformation = /* @__PURE__ */ createTransformationGuard("ComposeTransformation");
var PropertySignatureTransformation = class {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode8, encode7) {
    this.from = from;
    this.to = to;
    this.decode = decode8;
    this.encode = encode7;
  }
};
__name(PropertySignatureTransformation, "PropertySignatureTransformation");
var isRenamingPropertySignatureTransformation = /* @__PURE__ */ __name((t) => t.decode === identity && t.encode === identity, "isRenamingPropertySignatureTransformation");
var TypeLiteralTransformation = class {
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
__name(TypeLiteralTransformation, "TypeLiteralTransformation");
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = /* @__PURE__ */ __name((ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value6 = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value6[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value6;
  return Object.create(Object.getPrototypeOf(ast), d);
}, "annotations");
var keyof = /* @__PURE__ */ __name((ast) => Union.unify(_keyof(ast)), "keyof");
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = /* @__PURE__ */ __name((type3, capture2) => {
  switch (type3._tag) {
    case "Literal":
      return escape(String(type3.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type3, capture2, false);
    case "Union":
      return type3.types.map((type4) => getTemplateLiteralSpanTypePattern(type4, capture2)).join("|");
  }
}, "getTemplateLiteralSpanTypePattern");
var handleTemplateLiteralSpanTypeParens = /* @__PURE__ */ __name((type3, s, capture2, top) => {
  if (isUnion(type3)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
}, "handleTemplateLiteralSpanTypeParens");
var getTemplateLiteralPattern = /* @__PURE__ */ __name((ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head10 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head10})` : head10;
  }
  for (const span4 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
    if (span4.literal !== "") {
      const literal2 = escape(span4.literal);
      pattern2 += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern2;
}, "getTemplateLiteralPattern");
var getTemplateLiteralRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`), "getTemplateLiteralRegExp");
var getTemplateLiteralCapturingRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`), "getTemplateLiteralCapturingRegExp");
var getPropertySignatures = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertySignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
    case "Refinement":
      return getPropertySignatures(ast.from);
  }
  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
}, "getPropertySignatures");
var getIndexSignatures = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
}, "getIndexSignatures");
var getNumberIndexedAccess = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "getNumberIndexedAccess");
var getTypeLiteralPropertySignature = /* @__PURE__ */ __name((ast, name) => {
  const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is4.type, false, true);
      }
    }
  }
}, "getTypeLiteralPropertySignature");
var getPropertyKeyIndexedAccess = /* @__PURE__ */ __name((ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "getPropertyKeyIndexedAccess");
var getPropertyKeys = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
}, "getPropertyKeys");
var record2 = /* @__PURE__ */ __name((key, value6) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go3 = /* @__PURE__ */ __name((key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value6, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value6, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value6, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value6, false, true));
        break;
      case "Union":
        key2.types.forEach(go3);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  }, "go");
  go3(key);
  return {
    propertySignatures,
    indexSignatures
  };
}, "record");
var pick2 = /* @__PURE__ */ __name((ast, keys6) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick2(annotation.value, keys6);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys6.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys6) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys6.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick2(ast.f(), keys6);
    case "Refinement":
      return pick2(ast.from, keys6);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick2(ast.from, keys6), pick2(ast.to, keys6), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys6) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick2(ast.from, fromKeys), pick2(ast.to, keys6), new TypeLiteralTransformation(ts)) : pick2(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "pick");
var omit2 = /* @__PURE__ */ __name((ast, keys6) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is4) => isStringKeyword(getEncodedParameter(is4.parameter)))) {
      indexSignatures = indexSignatures.filter((is4) => !isTemplateLiteral(getEncodedParameter(is4.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick2(ast, getPropertyKeys(ast).filter((name) => !keys6.includes(name)));
}, "omit");
var orUndefined = /* @__PURE__ */ __name((ast) => Union.make([ast, undefinedKeyword]), "orUndefined");
var partial = /* @__PURE__ */ __name((ast, options4) => {
  const exact = options4?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature(is4.parameter, orUndefined(is4.type), is4.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options4)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options4));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options4), partial(ast.to, options4), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
}, "partial");
var required = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
}, "required");
var mutable = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
}, "mutable");
var getCompiler = /* @__PURE__ */ __name((match21) => {
  const compile = /* @__PURE__ */ __name((ast, path) => match21[ast._tag](ast, compile, path), "compile");
  return compile;
}, "getCompiler");
var pickAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
  let out = void 0;
  for (const id3 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id3)) {
      if (out === void 0) {
        out = {};
      }
      out[id3] = annotated.annotations[id3];
    }
  }
  return out;
}, "pickAnnotations");
var omitAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id3 of annotationIds) {
    delete out[id3];
  }
  return out;
}, "omitAnnotations");
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = typeAST(e.type);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type3) => new Type(type3)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type3 = typeAST(p.type);
        return type3 === p.type ? p : new PropertySignature(p.name, type3, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = typeAST(is4.type);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
}, "typeAST");
function changeMap(as14, f) {
  let changed = false;
  const out = allocate(as14.length);
  for (let i = 0; i < as14.length; i++) {
    const a = as14[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as14;
}
__name(changeMap, "changeMap");
var getTransformationFrom = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
}, "getTransformationFrom");
var encodedAST_ = /* @__PURE__ */ __name((ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = encodedAST_(e.type, isBound);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type3 = encodedAST_(ps.type, isBound);
        return type3 === ps.type ? ps : new PropertySignature(ps.name, type3, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = encodedAST_(is4.type, isBound);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = void 0;
      const identifier2 = getJSONIdentifier(ast);
      if (isSome2(identifier2)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier2.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from)
          return ast;
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
}, "encodedAST_");
var encodedAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, false), "encodedAST");
var encodedBoundAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, true), "encodedBoundAST");
var toJSONAnnotations = /* @__PURE__ */ __name((annotations3) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations3)) {
    out[String(k)] = annotations3[k];
  }
  return out;
}, "toJSONAnnotations");
var getEncodedParameter = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
}, "getEncodedParameter");
var equals4 = /* @__PURE__ */ __name((self2, that) => {
  switch (self2._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self2.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self2.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self2._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self2.head && equalsTemplateLiteralSpan(that.spans, self2.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self2.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self2.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self2 === that;
  }
}, "equals");
var equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence4((self2, that) => {
  return self2.literal === that.literal && equals4(self2.type, that.type);
});
var equalsEnums = /* @__PURE__ */ getEquivalence4((self2, that) => that[0] === self2[0] && that[1] === self2[1]);
var equalsUnion = /* @__PURE__ */ getEquivalence4(equals4);
var intersection5 = /* @__PURE__ */ intersectionWith(equals4);
var _keyof = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is4) => getEncodedParameter(is4.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection5(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "_keyof");
var compose2 = /* @__PURE__ */ __name((ab, cd) => new Transformation(ab, cd, composeTransformation), "compose");
var rename = /* @__PURE__ */ __name((ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of Reflect.ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose2(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
}, "rename");
var formatKeyword = /* @__PURE__ */ __name((ast) => getOrElse(getExpected(ast), () => ast._tag), "formatKeyword");
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join("")
  });
}
__name(getBrands, "getBrands");
var getOrElseExpected = /* @__PURE__ */ __name((ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast))), "getOrElseExpected");
var getExpected = /* @__PURE__ */ __name((ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast)), "getExpected");
var pruneUndefined = /* @__PURE__ */ __name((ast, self2, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined2 = false;
      for (const type3 of ast.types) {
        const pruned = self2(type3);
        if (pruned) {
          hasUndefined2 = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type3);
        }
      }
      if (hasUndefined2) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self2(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
}, "pruneUndefined");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
__name(Pointer, "Pointer");
var Unexpected = class {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
__name(Unexpected, "Unexpected");
var Missing = class {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
__name(Missing, "Missing");
var Composite2 = class {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
__name(Composite2, "Composite");
var Refinement2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
__name(Refinement2, "Refinement");
var Transformation2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
__name(Transformation2, "Transformation");
var Type2 = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
__name(Type2, "Type");
var Forbidden = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
__name(Forbidden, "Forbidden");
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var isParseError = /* @__PURE__ */ __name((u) => hasProperty(u, ParseErrorTypeId), "isParseError");
var ParseError = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
__name(ParseError, "ParseError");
var parseError = /* @__PURE__ */ __name((issue) => new ParseError({
  issue
}), "parseError");
var succeed13 = right2;
var fail13 = left2;
var _try = try_;
var fromOption4 = fromOption2;
var isEither3 = isEither2;
var flatMap16 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap14(self2, f);
});
var map24 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? map(self2, f) : map20(self2, f);
});
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? mapLeft(self2, f) : mapError4(self2, f);
});
var eitherOrUndefined = /* @__PURE__ */ __name((self2) => {
  if (isEither3(self2)) {
    return self2;
  }
}, "eitherOrUndefined");
var mapBoth5 = /* @__PURE__ */ dual(2, (self2, options4) => {
  return isEither3(self2) ? mapBoth(self2, {
    onLeft: options4.onFailure,
    onRight: options4.onSuccess
  }) : mapBoth4(self2, options4);
});
var orElse9 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self2, f);
});
var mergeInternalOptions = /* @__PURE__ */ __name((options4, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options4;
  }
  if (options4 === void 0) {
    return overrideOptions;
  }
  return {
    ...options4,
    ...overrideOptions
  };
}, "mergeInternalOptions");
var getEither = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options4, overrideOptions));
}, "getEither");
var getSync = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = getEither(ast, isDecoding, options4);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
}, "getSync");
var getOption3 = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = getEither(ast, isDecoding, options4);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
}, "getOption");
var getEffect = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options4, overrideOptions),
    isEffectAllowed: true
  });
}, "getEffect");
var decodeUnknownSync = /* @__PURE__ */ __name((schema3, options4) => getSync(schema3.ast, true, options4), "decodeUnknownSync");
var decodeUnknownOption = /* @__PURE__ */ __name((schema3, options4) => getOption3(schema3.ast, true, options4), "decodeUnknownOption");
var decodeUnknownEither = /* @__PURE__ */ __name((schema3, options4) => getEither(schema3.ast, true, options4), "decodeUnknownEither");
var decodeUnknownPromise = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = decodeUnknown2(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "decodeUnknownPromise");
var decodeUnknown2 = /* @__PURE__ */ __name((schema3, options4) => getEffect(schema3.ast, true, options4), "decodeUnknown");
var encodeUnknownSync = /* @__PURE__ */ __name((schema3, options4) => getSync(schema3.ast, false, options4), "encodeUnknownSync");
var encodeUnknownOption = /* @__PURE__ */ __name((schema3, options4) => getOption3(schema3.ast, false, options4), "encodeUnknownOption");
var encodeUnknownEither = /* @__PURE__ */ __name((schema3, options4) => getEither(schema3.ast, false, options4), "encodeUnknownEither");
var encodeUnknownPromise = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = encodeUnknown(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "encodeUnknownPromise");
var encodeUnknown = /* @__PURE__ */ __name((schema3, options4) => getEffect(schema3.ast, false, options4), "encodeUnknown");
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var decodeEither = decodeUnknownEither;
var decodePromise = decodeUnknownPromise;
var decode5 = decodeUnknown2;
var validateSync = /* @__PURE__ */ __name((schema3, options4) => getSync(typeAST(schema3.ast), true, options4), "validateSync");
var validateOption = /* @__PURE__ */ __name((schema3, options4) => getOption3(typeAST(schema3.ast), true, options4), "validateOption");
var validateEither = /* @__PURE__ */ __name((schema3, options4) => getEither(typeAST(schema3.ast), true, options4), "validateEither");
var validatePromise = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = validate4(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "validatePromise");
var validate4 = /* @__PURE__ */ __name((schema3, options4) => getEffect(typeAST(schema3.ast), true, options4), "validate");
var is = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = goMemo(typeAST(schema3.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options4, overrideOptions)
  }));
}, "is");
var asserts = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = goMemo(typeAST(schema3.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options4, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
}, "asserts");
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var encodeEither = encodeUnknownEither;
var encodePromise = encodeUnknownPromise;
var encode4 = encodeUnknown;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = /* @__PURE__ */ __name((ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw3 = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options4) => raw3(i, mergeInternalOptions(options4, parseOptionsAnnotation.value)) : raw3;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options4) => handleForbidden(orElse9(parserWithOptions(i, options4), decodingFallbackAnnotation.value), ast, i, options4) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
}, "goMemo");
var getConcurrency = /* @__PURE__ */ __name((ast) => getOrUndefined(getConcurrencyAnnotation(ast)), "getConcurrency");
var getBatching = /* @__PURE__ */ __name((ast) => getOrUndefined(getBatchingAnnotation(ast)), "getBatching");
var go = /* @__PURE__ */ __name((ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options4) => {
          options4 = options4 ?? defaultParseOption;
          const allErrors = options4?.errors === "all";
          const result = flatMap16(orElse9(from(i, options4), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options4, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options4, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options4);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options4) => handleForbidden(flatMap16(from(i, options4), (a) => to(a, options4)), ast, i, options4);
      }
    }
    case "Transformation": {
      const transform5 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options4) => handleForbidden(flatMap16(mapError6(from(i, options4), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap16(mapError6(transform5(a, options4 ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError6(to(i2, options4), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options4);
    }
    case "Declaration": {
      const parse4 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options4) => handleForbidden(parse4(i, options4 ?? defaultParseOption, ast), ast, i, options4);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value6]) => value6 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options4) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options4?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options4);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index2 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap14(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head10, ...tail2] = rest;
          for (; i < len - tail2.length; i++) {
            const te = head10(input[i], options4);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index2 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap14(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail2.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail2[j](input[i], options4);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index2 = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap14(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index2, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = /* @__PURE__ */ __name(({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2)), "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap14(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo(is4.parameter, isDecoding), goMemo(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options4) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options4?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options4?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options4?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options4);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options4?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options4);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index2 = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap14(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index2, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index2] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type3 = indexSignature[1];
          const keys6 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = parameter(key, options4);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type3(input[key], options4);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index2 = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap14(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index2, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = /* @__PURE__ */ __name(({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options4?.propertyOrder === "original") {
            const keys6 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        }, "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap14(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map33 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map33.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options4) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map33.get(candidate)(input, options4);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap14(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = /* @__PURE__ */ __name((es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        ), "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap14(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get23 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options4) => get23()(a, options4);
    }
  }
}, "go");
var fromRefinement = /* @__PURE__ */ __name((ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u)), "fromRefinement");
var getLiterals = /* @__PURE__ */ __name((ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type3 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type3) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type3]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element2 = ast.elements[i];
        const type3 = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
        if (isLiteral(type3) && !element2.isOptional) {
          out.push([i, type3]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
}, "getLiterals");
var getSearchTree = /* @__PURE__ */ __name((members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags3 = getLiterals(member, isDecoding);
    if (tags3.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags3.length; j++) {
        const [key, literal2] = tags3[j];
        const hash5 = String(literal2.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash5)) {
          if (j < tags3.length - 1) {
            continue;
          }
          buckets[hash5].push(member);
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
        } else {
          buckets[hash5] = [member];
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise,
    candidates
  };
}, "getSearchTree");
var dropRightRefinement = /* @__PURE__ */ __name((ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast, "dropRightRefinement");
var handleForbidden = /* @__PURE__ */ __name((effect4, ast, actual, options4) => {
  if (options4?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither3(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess2(exit4)) {
      return right2(exit4.value);
    }
    const cause3 = exit4.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
}, "handleForbidden");
var compare = /* @__PURE__ */ __name(([a], [b]) => a > b ? 1 : a < b ? -1 : 0, "compare");
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
__name(sortByIndex, "sortByIndex");
var getFinalTransformation = /* @__PURE__ */ __name((transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = /* @__PURE__ */ __name((input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some3(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          }, "f");
          out = map24(out, f);
        }
        return out;
      };
  }
}, "getFinalTransformation");
var makeTree = /* @__PURE__ */ __name((value6, forest = []) => ({
  value: value6,
  forest
}), "makeTree");
var TreeFormatter = {
  formatIssue: (issue) => map24(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error3) => TreeFormatter.formatIssue(error3.issue),
  formatErrorSync: (error3) => TreeFormatter.formatIssueSync(error3.issue)
};
var drawTree = /* @__PURE__ */ __name((tree) => tree.value + draw("\n", tree.forest), "drawTree");
var draw = /* @__PURE__ */ __name((indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
}, "draw");
var formatTransformationKind = /* @__PURE__ */ __name((kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
}, "formatTransformationKind");
var formatRefinementKind = /* @__PURE__ */ __name((kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
}, "formatRefinementKind");
var getAnnotated = /* @__PURE__ */ __name((issue) => "ast" in issue ? some3(issue.ast) : none2(), "getAnnotated");
var Either_void = /* @__PURE__ */ right2(void 0);
var getCurrentMessage = /* @__PURE__ */ __name((issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union11 = messageAnnotation(issue);
    if (isString(union11)) {
      return right2({
        message: union11,
        override: false
      });
    }
    if (isEffect2(union11)) {
      return map20(union11, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union11.message)) {
      return right2({
        message: union11.message,
        override: union11.override
      });
    }
    return map20(union11.message, (message) => ({
      message,
      override: union11.override
    }));
  }
})), "getCurrentMessage");
var createParseIssueGuard = /* @__PURE__ */ __name((tag8) => (issue) => issue._tag === tag8, "createParseIssueGuard");
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = /* @__PURE__ */ __name((issue) => flatMap16(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
}), "getMessage");
var getParseIssueTitleAnnotation2 = /* @__PURE__ */ __name((issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined), "getParseIssueTitleAnnotation");
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
__name(getRefinementExpected, "getRefinementExpected");
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
__name(getDefaultTypeMessage, "getDefaultTypeMessage");
var formatTypeMessage = /* @__PURE__ */ __name((issue) => map24(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue)), "formatTypeMessage");
var getParseIssueTitle = /* @__PURE__ */ __name((issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast), "getParseIssueTitle");
var formatForbiddenMessage = /* @__PURE__ */ __name((issue) => issue.message ?? "is forbidden", "formatForbiddenMessage");
var formatUnexpectedMessage = /* @__PURE__ */ __name((issue) => issue.message ?? "is unexpected", "formatUnexpectedMessage");
var formatMissingMessage = /* @__PURE__ */ __name((issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
}, "formatMissingMessage");
var formatTree = /* @__PURE__ */ __name((issue) => {
  switch (issue._tag) {
    case "Type":
      return map24(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map24(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map24(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map24(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map24(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map24(forEach10(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map24(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
}, "formatTree");
var makeArrayFormatterIssue = /* @__PURE__ */ __name((_tag, path, message) => ({
  _tag,
  path,
  message
}), "makeArrayFormatterIssue");
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, void 0, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error3) => ArrayFormatter.formatIssue(error3.issue),
  formatErrorSync: (error3) => ArrayFormatter.formatIssueSync(error3.issue)
};
var getArrayFormatterIssues = /* @__PURE__ */ __name((issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map24(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map24(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path.concat(issue.path));
    case "Composite":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty6(issue.issues) ? map24(forEach10(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path)), flatten2) : getArrayFormatterIssues(issue.issues, void 0, path);
      });
    case "Refinement":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path);
      });
    case "Transformation":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path);
      });
  }
}, "getArrayFormatterIssues");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Redacted.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isRedacted2 = isRedacted;
var make46 = make44;
var value2 = value;
var getEquivalence8 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isEquivalent(value2(x), value2(y))), "getEquivalence");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Struct.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var pick3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {};
  for (const k of keys6) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {
    ...s
  };
  for (const k of keys6) {
    delete out[k];
  }
  return out;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Schema.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make47(ast) {
  return /* @__PURE__ */ __name(class SchemaClass {
    [TypeId19] = variance5;
    static ast = ast;
    static annotations(annotations3) {
      return make47(mergeSchemaAnnotations(this.ast, annotations3));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId19] = variance5;
  }, "SchemaClass");
}
__name(make47, "make");
var variance5 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var makeStandardResult = /* @__PURE__ */ __name((exit4) => isSuccess2(exit4) ? exit4.value : makeStandardFailureResult(pretty3(exit4.cause)), "makeStandardResult");
var makeStandardFailureResult = /* @__PURE__ */ __name((message) => ({
  issues: [{
    message
  }]
}), "makeStandardFailureResult");
var makeStandardFailureFromParseIssue = /* @__PURE__ */ __name((issue) => map20(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
})), "makeStandardFailureFromParseIssue");
var standardSchemaV1 = /* @__PURE__ */ __name((schema3, overrideOptions) => {
  const decodeUnknown4 = decodeUnknown2(schema3, {
    errors: "all"
  });
  return /* @__PURE__ */ __name(class StandardSchemaV1Class extends make47(schema3.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value6) {
        const scheduler2 = new SyncScheduler();
        const fiber = runFork2(matchEffect3(decodeUnknown4(value6, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: (value7) => succeed10({
            value: value7
          })
        }), {
          scheduler: scheduler2
        });
        scheduler2.flush();
        const exit4 = fiber.unsafePoll();
        if (exit4) {
          return makeStandardResult(exit4);
        }
        return new Promise((resolve3) => {
          fiber.addObserver((exit5) => {
            resolve3(makeStandardResult(exit5));
          });
        });
      }
    };
  }, "StandardSchemaV1Class");
}, "standardSchemaV1");
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = /* @__PURE__ */ __name((annotations3) => {
  if (!annotations3) {
    return {};
  }
  const out = {
    ...annotations3
  };
  for (const key in builtInAnnotations) {
    if (key in annotations3) {
      const id3 = builtInAnnotations[key];
      out[id3] = annotations3[key];
      delete out[key];
    }
  }
  return out;
}, "toASTAnnotations");
var mergeSchemaAnnotations = /* @__PURE__ */ __name((ast, annotations3) => annotations(ast, toASTAnnotations(annotations3)), "mergeSchemaAnnotations");
function asSchema(schema3) {
  return schema3;
}
__name(asSchema, "asSchema");
var format6 = /* @__PURE__ */ __name((schema3) => String(schema3.ast), "format");
var encodedSchema = /* @__PURE__ */ __name((schema3) => make47(encodedAST(schema3.ast)), "encodedSchema");
var encodedBoundSchema = /* @__PURE__ */ __name((schema3) => make47(encodedBoundAST(schema3.ast)), "encodedBoundSchema");
var typeSchema = /* @__PURE__ */ __name((schema3) => make47(typeAST(schema3.ast)), "typeSchema");
var encodeUnknown2 = /* @__PURE__ */ __name((schema3, options4) => {
  const encodeUnknown3 = encodeUnknown(schema3, options4);
  return (u, overrideOptions) => mapError6(encodeUnknown3(u, overrideOptions), parseError);
}, "encodeUnknown");
var encodeUnknownEither2 = /* @__PURE__ */ __name((schema3, options4) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema3, options4);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
}, "encodeUnknownEither");
var encodeUnknownPromise2 = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = encodeUnknown2(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "encodeUnknownPromise");
var encode5 = encodeUnknown2;
var encodeEither2 = encodeUnknownEither2;
var encodePromise2 = encodeUnknownPromise2;
var decodeUnknown3 = /* @__PURE__ */ __name((schema3, options4) => {
  const decodeUnknown4 = decodeUnknown2(schema3, options4);
  return (u, overrideOptions) => mapError6(decodeUnknown4(u, overrideOptions), parseError);
}, "decodeUnknown");
var decodeUnknownEither2 = /* @__PURE__ */ __name((schema3, options4) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema3, options4);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
}, "decodeUnknownEither");
var decodeUnknownPromise2 = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = decodeUnknown3(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "decodeUnknownPromise");
var decode6 = decodeUnknown3;
var decodeEither2 = decodeUnknownEither2;
var decodePromise2 = decodeUnknownPromise2;
var validate5 = /* @__PURE__ */ __name((schema3, options4) => {
  const validate6 = validate4(schema3, options4);
  return (u, overrideOptions) => mapError6(validate6(u, overrideOptions), parseError);
}, "validate");
var validateEither2 = /* @__PURE__ */ __name((schema3, options4) => {
  const validateEither3 = validateEither(schema3, options4);
  return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
}, "validateEither");
var validatePromise2 = /* @__PURE__ */ __name((schema3, options4) => {
  const parser = validate5(schema3, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "validatePromise");
var isSchema = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId19) && isObject(u[TypeId19]), "isSchema");
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
__name(getDefaultLiteralAST, "getDefaultLiteralAST");
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return /* @__PURE__ */ __name(class LiteralClass extends make47(ast) {
    static annotations(annotations3) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static literals = [...literals];
  }, "LiteralClass");
}
__name(makeLiteralClass, "makeLiteralClass");
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
__name(Literal2, "Literal");
var pickLiteral = /* @__PURE__ */ __name((...literals) => (_schema) => Literal2(...literals), "pickLiteral");
var UniqueSymbolFromSelf = /* @__PURE__ */ __name((symbol6) => make47(new UniqueSymbol(symbol6)), "UniqueSymbolFromSelf");
var getDefaultEnumsAST = /* @__PURE__ */ __name((enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]])), "getDefaultEnumsAST");
var makeEnumsClass = /* @__PURE__ */ __name((enums, ast = getDefaultEnumsAST(enums)) => /* @__PURE__ */ __name(class EnumsClass extends make47(ast) {
  static annotations(annotations3) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations3));
  }
  static enums = {
    ...enums
  };
}, "EnumsClass"), "makeEnumsClass");
var Enums2 = /* @__PURE__ */ __name((enums) => makeEnumsClass(enums), "Enums");
var TemplateLiteral2 = /* @__PURE__ */ __name((...[head10, ...tail2]) => {
  const spans = [];
  let h = "";
  let ts = tail2;
  if (isSchema(head10)) {
    if (isLiteral(head10.ast)) {
      h = String(head10.ast.literal);
    } else {
      ts = [head10, ...ts];
    }
  } else {
    h = String(head10);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next = ts[i + 1];
        if (isSchema(next)) {
          if (isLiteral(next.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make47(new TemplateLiteral(h, spans));
  } else {
    return make47(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h), "")]));
  }
}, "TemplateLiteral");
function getTemplateLiteralParserCoercedElement(encoded, schema3) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal2 = ast.literal;
      if (!isString(literal2)) {
        const s = String(literal2);
        return transform2(Literal2(s), schema3, {
          strict: true,
          decode: () => literal2,
          encode: () => s
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose3(NumberFromString, schema3);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema4 = make47(member);
        const encoded2 = encodedSchema(schema4);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema4);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema4);
      }
      return hasCoercions ? compose3(Union2(...members), schema3) : schema3;
    }
  }
}
__name(getTemplateLiteralParserCoercedElement, "getTemplateLiteralParserCoercedElement");
var TemplateLiteralParser = /* @__PURE__ */ __name((...params2) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params2.length; i++) {
    const param = params2[i];
    const schema3 = isSchema(param) ? param : Literal2(param);
    schemas.push(schema3);
    const encoded = encodedSchema(schema3);
    encodedSchemas.push(encoded);
    const element2 = getTemplateLiteralParserCoercedElement(encoded, schema3);
    if (element2) {
      elements.push(element2);
      coerced = true;
    } else {
      elements.push(schema3);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format6(Tuple(...schemas))
    });
  }
  return /* @__PURE__ */ __name(class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match21 = re.exec(i);
      return match21 ? succeed13(match21.slice(1, params2.length + 1)) : fail13(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: (tuple4) => succeed13(tuple4.join(""))
  }) {
    static params = params2.slice();
  }, "TemplateLiteralParserClass");
}, "TemplateLiteralParser");
var declareConstructor = /* @__PURE__ */ __name((typeParameters, options4, annotations3) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options4.decode(...typeParameters2.map(make47)), (...typeParameters2) => options4.encode(...typeParameters2.map(make47)), toASTAnnotations(annotations3))), "declareConstructor");
var declarePrimitive = /* @__PURE__ */ __name((is4, annotations3) => {
  const decodeUnknown4 = /* @__PURE__ */ __name(() => (input, _, ast) => is4(input) ? succeed13(input) : fail13(new Type2(ast, input)), "decodeUnknown");
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations3)));
}, "declarePrimitive");
function makeDeclareClass(typeParameters, ast) {
  return /* @__PURE__ */ __name(class DeclareClass extends make47(ast) {
    static annotations(annotations3) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static typeParameters = [...typeParameters];
  }, "DeclareClass");
}
__name(makeDeclareClass, "makeDeclareClass");
var declare = /* @__PURE__ */ __name(function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options4 = arguments[1];
    const annotations4 = arguments[2];
    return declareConstructor(typeParameters, options4, annotations4);
  }
  const is4 = arguments[0];
  const annotations3 = arguments[1];
  return declarePrimitive(is4, annotations3);
}, "declare");
var BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
var fromBrand = /* @__PURE__ */ __name((constructor, annotations3) => (self2) => {
  const out = makeBrandClass(self2, new Refinement(self2.ast, /* @__PURE__ */ __name(function predicate(a, _, ast) {
    const either9 = constructor.either(a);
    return isLeft2(either9) ? some3(new Type2(ast, a, either9.left.map((v) => v.message).join(", "))) : none2();
  }, "predicate"), toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations3
  })));
  return out;
}, "fromBrand");
var InstanceOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf = /* @__PURE__ */ __name((constructor, annotations3) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations3
}), "instanceOf");
var Undefined = class extends (/* @__PURE__ */ make47(undefinedKeyword)) {
};
__name(Undefined, "Undefined");
var Void = class extends (/* @__PURE__ */ make47(voidKeyword)) {
};
__name(Void, "Void");
var Null = class extends (/* @__PURE__ */ make47($null)) {
};
__name(Null, "Null");
var Never = class extends (/* @__PURE__ */ make47(neverKeyword)) {
};
__name(Never, "Never");
var Unknown = class extends (/* @__PURE__ */ make47(unknownKeyword)) {
};
__name(Unknown, "Unknown");
var Any = class extends (/* @__PURE__ */ make47(anyKeyword)) {
};
__name(Any, "Any");
var BigIntFromSelf = class extends (/* @__PURE__ */ make47(bigIntKeyword)) {
};
__name(BigIntFromSelf, "BigIntFromSelf");
var SymbolFromSelf = class extends (/* @__PURE__ */ make47(symbolKeyword)) {
};
__name(SymbolFromSelf, "SymbolFromSelf");
var String$ = class extends (/* @__PURE__ */ make47(stringKeyword)) {
};
__name(String$, "String$");
var Number$ = class extends (/* @__PURE__ */ make47(numberKeyword)) {
};
__name(Number$, "Number$");
var Boolean$ = class extends (/* @__PURE__ */ make47(booleanKeyword)) {
};
__name(Boolean$, "Boolean$");
var Object$ = class extends (/* @__PURE__ */ make47(objectKeyword)) {
};
__name(Object$, "Object$");
var getDefaultUnionAST = /* @__PURE__ */ __name((members) => Union.make(members.map((m) => m.ast)), "getDefaultUnionAST");
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return /* @__PURE__ */ __name(class UnionClass extends make47(ast) {
    static annotations(annotations3) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static members = [...members];
  }, "UnionClass");
}
__name(makeUnionClass, "makeUnionClass");
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
__name(Union2, "Union");
var NullOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null), "NullOr");
var UndefinedOr = /* @__PURE__ */ __name((self2) => Union2(self2, Undefined), "UndefinedOr");
var NullishOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null, Undefined), "NullishOr");
var keyof2 = /* @__PURE__ */ __name((self2) => make47(keyof(self2.ast)), "keyof");
var element = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, false), self2), "element");
var optionalElement = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, true), self2), "optionalElement");
var ElementImpl = class {
  ast;
  from;
  [TypeId19];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations3) {
    return new ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations3)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
__name(ElementImpl, "ElementImpl");
var getDefaultTupleTypeAST = /* @__PURE__ */ __name((elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true), "getDefaultTupleTypeAST");
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return /* @__PURE__ */ __name(class TupleTypeClass extends make47(ast) {
    static annotations(annotations3) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static elements = [...elements];
    static rest = [...rest];
  }, "TupleTypeClass");
}
__name(makeTupleTypeClass, "makeTupleTypeClass");
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
__name(Tuple, "Tuple");
function makeArrayClass(value6, ast) {
  return /* @__PURE__ */ __name(class ArrayClass extends makeTupleTypeClass([], [value6], ast) {
    static annotations(annotations3) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  }, "ArrayClass");
}
__name(makeArrayClass, "makeArrayClass");
var Array$ = /* @__PURE__ */ __name((value6) => makeArrayClass(value6), "Array$");
function makeNonEmptyArrayClass(value6, ast) {
  return /* @__PURE__ */ __name(class NonEmptyArrayClass extends makeTupleTypeClass([value6], [value6], ast) {
    static annotations(annotations3) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  }, "NonEmptyArrayClass");
}
__name(makeNonEmptyArrayClass, "makeNonEmptyArrayClass");
var NonEmptyArray = /* @__PURE__ */ __name((value6) => makeNonEmptyArrayClass(value6), "NonEmptyArray");
function ArrayEnsure(value6) {
  return transform2(Union2(value6, Array$(value6)), Array$(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => ensure(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
__name(ArrayEnsure, "ArrayEnsure");
function NonEmptyArrayEnsure(value6) {
  return transform2(Union2(value6, NonEmptyArray(value6)), NonEmptyArray(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => isNonEmptyReadonlyArray(i) ? i : of(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
__name(NonEmptyArrayEnsure, "NonEmptyArrayEnsure");
var formatPropertySignatureToken = /* @__PURE__ */ __name((isOptional) => isOptional ? '"?:"' : '":"', "formatPropertySignatureToken");
var PropertySignatureDeclaration = class extends OptionalType {
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type3, isOptional, isReadonly, annotations3, defaultValue) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type3 = String(this.type);
    return `PropertySignature<${token}, ${type3}, never, ${token}, ${type3}>`;
  }
};
__name(PropertySignatureDeclaration, "PropertySignatureDeclaration");
var FromPropertySignature = class extends OptionalType {
  isReadonly;
  fromKey;
  constructor(type3, isOptional, isReadonly, annotations3, fromKey2) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey2;
  }
};
__name(FromPropertySignature, "FromPropertySignature");
var ToPropertySignature = class extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type3, isOptional, isReadonly, annotations3, defaultValue) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
__name(ToPropertySignature, "ToPropertySignature");
var formatPropertyKey2 = /* @__PURE__ */ __name((p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
}, "formatPropertyKey");
var PropertySignatureTransformation2 = class {
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode8, encode7) {
    this.from = from;
    this.to = to;
    this.decode = decode8;
    this.encode = encode7;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
__name(PropertySignatureTransformation2, "PropertySignatureTransformation");
var mergeSignatureAnnotations = /* @__PURE__ */ __name((ast, annotations3) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations3
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations3
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
}, "mergeSignatureAnnotations");
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = /* @__PURE__ */ __name((u) => hasProperty(u, PropertySignatureTypeId), "isPropertySignature");
var PropertySignatureImpl = class {
  ast;
  [TypeId19];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations3) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)));
  }
  toString() {
    return String(this.ast);
  }
};
__name(PropertySignatureImpl, "PropertySignatureImpl");
var makePropertySignature = /* @__PURE__ */ __name((ast) => new PropertySignatureImpl(ast), "makePropertySignature");
var PropertySignatureWithFromImpl = class extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations3) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)), this.from);
  }
};
__name(PropertySignatureWithFromImpl, "PropertySignatureWithFromImpl");
var propertySignature = /* @__PURE__ */ __name((self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, void 0), self2), "propertySignature");
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = /* @__PURE__ */ __name((o, defaultValue) => match2(o, {
  onNone: () => some3(defaultValue()),
  onSome: (value6) => some3(value6 === void 0 ? defaultValue() : value6)
}), "applyDefaultValue");
var pruneUndefined2 = /* @__PURE__ */ __name((ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
  const pruned = pruneUndefined2(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
}), "pruneUndefined");
var withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = /* @__PURE__ */ dual(2, (self2, key) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some3(options4.decode(o)), flatMap(options4.encode))), "optionalToRequired");
var requiredToOptional = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap(options4.decode), (o) => some3(options4.encode(o)))), "requiredToOptional");
var optionalToOptional = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options4.decode, options4.encode)), "optionalToOptional");
var optionalPropertySignatureAST = /* @__PURE__ */ __name((self2, options4) => {
  const isExact = options4?.exact;
  const defaultValue = options4?.default;
  const isNullable2 = options4?.nullable;
  const asOption = options4?.as == "Option";
  const asOptionEncode = options4?.onNoneEncoding ? orElse(options4.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self2, typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self2));
      if (isNullable2) {
        return optionalToRequired(NullOr(self2), to, {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self2, to, {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self2), typeSchema(self2), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self2.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self2));
      if (isNullable2) {
        return optionalToRequired(NullishOr(self2), to, {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self2), to, {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self2), UndefinedOr(typeSchema(self2)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self2).ast, true, true, {}, void 0);
      }
    }
  }
}, "optionalPropertySignatureAST");
var optional = /* @__PURE__ */ __name((self2) => {
  const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self2);
}, "optional");
var optionalWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options4) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self2, options4), self2);
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = /* @__PURE__ */ __name((fields, records) => {
  const ownKeys = Reflect.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type3 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type3, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type3), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type3, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
}, "getDefaultTypeLiteralAST");
var lazilyMergeDefaults = /* @__PURE__ */ __name((fields, out) => {
  const ownKeys = Reflect.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
}, "lazilyMergeDefaults");
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return /* @__PURE__ */ __name(class TypeLiteralClass extends make47(ast) {
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options4) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options4) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys6) {
      return Struct(pick3(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct(omit3(fields, ...keys6));
    }
  }, "TypeLiteralClass");
}
__name(makeTypeLiteralClass, "makeTypeLiteralClass");
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
__name(Struct, "Struct");
var tag = /* @__PURE__ */ __name((tag8) => Literal2(tag8).pipe(propertySignature, withConstructorDefault(() => tag8)), "tag");
var TaggedStruct = /* @__PURE__ */ __name((value6, fields) => Struct({
  _tag: tag(value6),
  ...fields
}), "TaggedStruct");
function makeRecordClass(key, value6, ast) {
  return /* @__PURE__ */ __name(class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value6
  }], ast) {
    static annotations(annotations3) {
      return makeRecordClass(key, value6, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static key = key;
    static value = value6;
  }, "RecordClass");
}
__name(makeRecordClass, "makeRecordClass");
var Record = /* @__PURE__ */ __name((options4) => makeRecordClass(options4.key, options4.value), "Record");
var pick4 = /* @__PURE__ */ __name((...keys6) => (self2) => make47(pick2(self2.ast, keys6)), "pick");
var omit4 = /* @__PURE__ */ __name((...keys6) => (self2) => make47(omit2(self2.ast, keys6)), "omit");
var pluck = /* @__PURE__ */ dual(2, (schema3, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema3.ast), key);
  const value6 = make47(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform2(schema3.pipe(pick4(key)), value6, {
    strict: true,
    decode: (i) => i[key],
    encode: (a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from, ast) {
  return /* @__PURE__ */ __name(class BrandClass extends make47(ast) {
    static annotations(annotations3) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static make = (a, options4) => {
      return getDisableValidationMakeOption(options4) ? a : validateSync(this)(a);
    };
    static from = from;
  }, "BrandClass");
}
__name(makeBrandClass, "makeBrandClass");
var brand = /* @__PURE__ */ __name((brand2, annotations3) => (self2) => {
  const annotation = match2(getBrandAnnotation(self2.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self2.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations3
  }));
  return makeBrandClass(self2, ast);
}, "brand");
var partial2 = /* @__PURE__ */ __name((self2) => make47(partial(self2.ast)), "partial");
var partialWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options4) => make47(partial(self2.ast, options4)));
var required2 = /* @__PURE__ */ __name((self2) => make47(required(self2.ast)), "required");
var mutable2 = /* @__PURE__ */ __name((schema3) => make47(mutable(schema3.ast)), "mutable");
var intersectTypeLiterals = /* @__PURE__ */ __name((x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type3
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type3, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}, "intersectTypeLiterals");
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = /* @__PURE__ */ __name((refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement))), "addRefinementToMembers");
var extendAST = /* @__PURE__ */ __name((x, y, path) => Union.make(intersectUnionMembers([x], [y], path)), "extendAST");
var getTypes = /* @__PURE__ */ __name((ast) => isUnion(ast) ? ast.types : [ast], "getTypes");
var intersectUnionMembers = /* @__PURE__ */ __name((xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options4, ast, fromI) => map24(transformation.decode(fromA, options4, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options4, ast, toA) => map24(transformation.encode(toI, options4, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
})), "intersectUnionMembers");
var extend3 = /* @__PURE__ */ dual(2, (self2, that) => make47(extendAST(self2.ast, that.ast, [])));
var compose3 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose2(from.ast, to.ast)));
var suspend7 = /* @__PURE__ */ __name((f) => make47(new Suspend(() => f().ast)), "suspend");
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter15, ast) {
  return /* @__PURE__ */ __name(class RefineClass extends make47(ast) {
    static annotations(annotations3) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter15;
    static make = (a, options4) => {
      return getDisableValidationMakeOption(options4) ? a : validateSync(this)(a);
    };
  }, "RefineClass");
}
__name(makeRefineClass, "makeRefineClass");
var fromFilterPredicateReturnTypeItem = /* @__PURE__ */ __name((item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some3(new Type2(ast, input));
  }
  if (isString(item)) {
    return some3(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some3(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some3(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
}, "fromFilterPredicateReturnTypeItem");
var toFilterParseIssue = /* @__PURE__ */ __name((out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some3(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
}, "toFilterParseIssue");
function filter12(predicate, annotations3) {
  return (self2) => {
    function filter15(input, options4, ast2) {
      return toFilterParseIssue(predicate(input, options4, ast2), ast2, input);
    }
    __name(filter15, "filter");
    const ast = new Refinement(self2.ast, filter15, toASTAnnotations(annotations3));
    return makeRefineClass(self2, filter15, ast);
  };
}
__name(filter12, "filter");
var filterEffect = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(self2, typeSchema(self2), {
  strict: true,
  decode: (i, options4, ast) => flatMap16(f(i, options4, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => succeed13(i),
    onSome: fail13
  })),
  encode: (a) => succeed13(a)
}));
function makeTransformationClass(from, to, ast) {
  return /* @__PURE__ */ __name(class TransformationClass extends make47(ast) {
    static annotations(annotations3) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static from = from;
    static to = to;
  }, "TransformationClass");
}
__name(makeTransformationClass, "makeTransformationClass");
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options4) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options4.decode, options4.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options4) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed13(options4.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed13(options4.encode(toI, toA))
}));
function transformLiteral(from, to) {
  return transform2(Literal2(from), Literal2(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
__name(transformLiteral, "transformLiteral");
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
__name(transformLiterals, "transformLiterals");
var attachPropertySignature = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (schema3, key, value6, annotations3) => {
  const ast = extend3(typeSchema(schema3), Struct({
    [key]: isSymbol(value6) ? UniqueSymbolFromSelf(value6) : Literal2(value6)
  })).ast;
  return make47(new Transformation(schema3.ast, annotations3 ? mergeSchemaAnnotations(ast, annotations3) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some3(value6), () => none2())])));
});
var annotations2 = /* @__PURE__ */ dual(2, (self2, annotations3) => self2.annotations(annotations3));
var rename2 = /* @__PURE__ */ dual(2, (self2, mapping) => make47(rename(self2.ast, mapping)));
var TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
var trimmed = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations3
})), "trimmed");
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = /* @__PURE__ */ __name((maxLength2, annotations3) => (self2) => self2.pipe(filter12((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations3
})), "maxLength");
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = /* @__PURE__ */ __name((minLength2, annotations3) => (self2) => self2.pipe(filter12((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations3
})), "minLength");
var LengthSchemaId2 = LengthSchemaId;
var length3 = /* @__PURE__ */ __name((length4, annotations3) => (self2) => {
  const minLength2 = isObject(length4) ? Math.max(0, Math.floor(length4.min)) : Math.max(0, Math.floor(length4));
  const maxLength2 = isObject(length4) ? Math.max(minLength2, Math.floor(length4.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self2.pipe(filter12((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations3
    }));
  }
  return self2.pipe(filter12((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations3
  }));
}, "length");
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = /* @__PURE__ */ __name((regex, annotations3) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter12((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations3
  }));
}, "pattern");
var StartsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/StartsWith");
var startsWith = /* @__PURE__ */ __name((startsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(startsWith2);
  return self2.pipe(filter12((a) => a.startsWith(startsWith2), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith2
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith2}`
    },
    ...annotations3
  }));
}, "startsWith");
var EndsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/EndsWith");
var endsWith = /* @__PURE__ */ __name((endsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(endsWith2);
  return self2.pipe(filter12((a) => a.endsWith(endsWith2), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith2
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith2}$`
    },
    ...annotations3
  }));
}, "endsWith");
var IncludesSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Includes");
var includes = /* @__PURE__ */ __name((searchString, annotations3) => (self2) => {
  const formatted = JSON.stringify(searchString);
  return self2.pipe(filter12((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations3
  }));
}, "includes");
var LowercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Lowercased");
var lowercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations3
})), "lowercased");
var Lowercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ lowercased({
  identifier: "Lowercased"
}))) {
};
__name(Lowercased, "Lowercased");
var UppercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uppercased");
var uppercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations3
})), "uppercased");
var Uppercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uppercased({
  identifier: "Uppercased"
}))) {
};
__name(Uppercased, "Uppercased");
var CapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Capitalized");
var capitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations3
})), "capitalized");
var Capitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ capitalized({
  identifier: "Capitalized"
}))) {
};
__name(Capitalized, "Capitalized");
var UncapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations3
})), "uncapitalized");
var Uncapitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uncapitalized({
  identifier: "Uncapitalized"
}))) {
};
__name(Uncapitalized, "Uncapitalized");
var Char = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ length3(1, {
  identifier: "Char"
}))) {
};
__name(Char, "Char");
var nonEmptyString2 = /* @__PURE__ */ __name((annotations3) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations3
}), "nonEmptyString");
var Lowercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i) => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
};
__name(Lowercase, "Lowercase");
var Uppercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i) => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
};
__name(Uppercase, "Uppercase");
var Capitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i) => capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
};
__name(Capitalize, "Capitalize");
var Uncapitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i) => uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
};
__name(Uncapitalize, "Uncapitalize");
var Trimmed = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed"
}))) {
};
__name(Trimmed, "Trimmed");
var NonEmptyTrimmedString = class extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyTrimmedString"
}))) {
};
__name(NonEmptyTrimmedString, "NonEmptyTrimmedString");
var Trim = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i) => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
};
__name(Trim, "Trim");
var split2 = /* @__PURE__ */ __name((separator) => transform2(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i) => i.split(separator),
  encode: (a) => a.join(separator)
}), "split");
var getErrorMessage2 = /* @__PURE__ */ __name((e) => e instanceof Error ? e.message : String(e), "getErrorMessage");
var getParseJsonTransformation = /* @__PURE__ */ __name((options4) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => JSON.parse(i, options4?.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _, ast) => _try({
    try: () => JSON.stringify(a, options4?.replacer, options4?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
}), "getParseJsonTransformation");
var parseJson = /* @__PURE__ */ __name((schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose3(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions), "parseJson");
var NonEmptyString = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyString"
}))) {
};
__name(NonEmptyString, "NonEmptyString");
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
};
__name(UUID, "UUID");
var ULIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
}))) {
};
__name(ULID, "ULID");
var URLFromSelf = class extends (/* @__PURE__ */ instanceOf(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url2) => url2.toString()
})) {
};
__name(URLFromSelf, "URLFromSelf");
var URL$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => new URL(i),
    catch: (e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed13(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url2) => url2.toString()
})) {
};
__name(URL$, "URL$");
var FiniteSchemaId2 = FiniteSchemaId;
var finite = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {},
  ...annotations3
})), "finite");
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan6 = /* @__PURE__ */ __name((exclusiveMinimum, annotations3) => (self2) => self2.pipe(filter12((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations3
})), "greaterThan");
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo5 = /* @__PURE__ */ __name((minimum, annotations3) => (self2) => self2.pipe(filter12((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations3
})), "greaterThanOrEqualTo");
var MultipleOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = /* @__PURE__ */ __name((divisor, annotations3) => (self2) => {
  const positiveDivisor = Math.abs(divisor);
  return self2.pipe(filter12((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations3
  }));
}, "multipleOf");
var IntSchemaId2 = IntSchemaId;
var int = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
})), "int");
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan10 = /* @__PURE__ */ __name((exclusiveMaximum, annotations3) => (self2) => self2.pipe(filter12((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations3
})), "lessThan");
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo5 = /* @__PURE__ */ __name((maximum, annotations3) => (self2) => self2.pipe(filter12((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations3
})), "lessThanOrEqualTo");
var BetweenSchemaId2 = BetweenSchemaId;
var between5 = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter12((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations3
})), "between");
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations3
})), "nonNaN");
var positive = /* @__PURE__ */ __name((annotations3) => greaterThan6(0, {
  title: "positive",
  ...annotations3
}), "positive");
var negative = /* @__PURE__ */ __name((annotations3) => lessThan10(0, {
  title: "negative",
  ...annotations3
}), "negative");
var nonPositive = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualTo5(0, {
  title: "nonPositive",
  ...annotations3
}), "nonPositive");
var nonNegative = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualTo5(0, {
  title: "nonNegative",
  ...annotations3
}), "nonNegative");
var clamp8 = /* @__PURE__ */ __name((minimum, maximum) => (self2) => {
  return transform2(self2, typeSchema(self2).pipe(between5(minimum, maximum)), {
    strict: false,
    decode: (i) => clamp4(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
}, "clamp");
function parseNumber(self2) {
  return transformOrFail(self2, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption4(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed13(String(a))
  });
}
__name(parseNumber, "parseNumber");
var NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
};
__name(NumberFromString, "NumberFromString");
var Finite = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  identifier: "Finite"
}))) {
};
__name(Finite, "Finite");
var Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
};
__name(Int, "Int");
var NonNaN = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
  identifier: "NonNaN"
}))) {
};
__name(NonNaN, "NonNaN");
var Positive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
  identifier: "Positive"
}))) {
};
__name(Positive, "Positive");
var Negative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
  identifier: "Negative"
}))) {
};
__name(Negative, "Negative");
var NonPositive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
  identifier: "NonPositive"
}))) {
};
__name(NonPositive, "NonPositive");
var NonNegative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative"
}))) {
};
__name(NonNegative, "NonNegative");
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
}))) {
};
__name(JsonNumber, "JsonNumber");
var Not = class extends (/* @__PURE__ */ transform2(/* @__PURE__ */ Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i) => not2(i),
  encode: (a) => not2(a)
})) {
};
__name(Not, "Not");
var encodeSymbol2 = /* @__PURE__ */ __name((sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail13(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed13(key);
}, "encodeSymbol");
var decodeSymbol = /* @__PURE__ */ __name((s) => succeed13(Symbol.for(s)), "decodeSymbol");
var Symbol$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i) => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol2(a, ast)
}).annotations({
  identifier: "Symbol"
})) {
};
__name(Symbol$, "Symbol$");
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => a > min5, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min5
  },
  title: `greaterThanBigInt(${min5})`,
  description: min5 === 0n ? "a positive bigint" : `a bigint greater than ${min5}n`,
  ...annotations3
})), "greaterThanBigInt");
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min5, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min5
  },
  title: `greaterThanOrEqualToBigInt(${min5})`,
  description: min5 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min5}n`,
  ...annotations3
})), "greaterThanOrEqualToBigInt");
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => a < max8, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max8
  },
  title: `lessThanBigInt(${max8})`,
  description: max8 === 0n ? "a negative bigint" : `a bigint less than ${max8}n`,
  ...annotations3
})), "lessThanBigInt");
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max8, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max8
  },
  title: `lessThanOrEqualToBigInt(${max8})`,
  description: max8 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max8}n`,
  ...annotations3
})), "lessThanOrEqualToBigInt");
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = /* @__PURE__ */ __name((min5, max8, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min5 && a <= max8, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min5,
    max: max8
  },
  title: `betweenBigInt(${min5}, ${max8})`,
  description: `a bigint between ${min5}n and ${max8}n`,
  ...annotations3
})), "betweenBigInt");
var positiveBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations3
}), "positiveBigInt");
var negativeBigInt = /* @__PURE__ */ __name((annotations3) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations3
}), "negativeBigInt");
var nonNegativeBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations3
}), "nonNegativeBigInt");
var nonPositiveBigInt = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations3
}), "nonPositiveBigInt");
var clampBigInt = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp6(i, {
    minimum,
    maximum
  }),
  encode: identity
}), "clampBigInt");
var BigInt$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromOption4(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed13(String(a))
}).annotations({
  identifier: "BigInt"
})) {
};
__name(BigInt$, "BigInt$");
var PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => fromOption4(fromNumber(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => fromOption4(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
})) {
};
__name(BigIntFromNumber, "BigIntFromNumber");
var redactedArbitrary = /* @__PURE__ */ __name((value6) => (fc) => value6(fc).map(make46), "redactedArbitrary");
var toComposite = /* @__PURE__ */ __name((eff, onSuccess, ast, actual) => mapBoth5(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
}), "toComposite");
var redactedParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isRedacted2(u) ? toComposite(decodeUnknown4(value2(u), options4), make46, ast, u) : fail13(new Type2(ast, u)), "redactedParse");
var RedactedFromSelf = /* @__PURE__ */ __name((value6) => declare([value6], {
  decode: (value7) => redactedParse(decodeUnknown2(value7)),
  encode: (value7) => redactedParse(encodeUnknown(value7))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence8
}), "RedactedFromSelf");
function Redacted(value6) {
  return transform2(value6, RedactedFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => make46(i),
    encode: (a) => value2(a)
  });
}
__name(Redacted, "Redacted");
var DurationFromSelf = class extends (/* @__PURE__ */ declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))),
  equivalence: () => Equivalence
})) {
};
__name(DurationFromSelf, "DurationFromSelf");
var DurationFromNanos = class extends (/* @__PURE__ */ transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter12((duration3) => isFinite(duration3), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i) => succeed13(nanos(i)),
  encode: (a, _, ast) => match2(toNanos(a), {
    onNone: () => fail13(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed13(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
})) {
};
__name(DurationFromNanos, "DurationFromNanos");
var NonNegativeInt = /* @__PURE__ */ NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends (/* @__PURE__ */ transform2(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i) => millis(i),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
})) {
};
__name(DurationFromMillis, "DurationFromMillis");
var DurationValueMillis = /* @__PURE__ */ TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = /* @__PURE__ */ TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = /* @__PURE__ */ TaggedStruct("Infinity", {});
var durationValueInfinity = /* @__PURE__ */ DurationValueInfinity.make({});
var DurationValue = /* @__PURE__ */ Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = /* @__PURE__ */ Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = /* @__PURE__ */ Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = /* @__PURE__ */ Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = /* @__PURE__ */ __name((u) => typeof u === "object", "isDurationValue");
var Duration = class extends (/* @__PURE__ */ transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
})) {
};
__name(Duration, "Duration");
var clampDuration = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp3(i, {
    minimum,
    maximum
  }),
  encode: identity
}), "clampDuration");
var LessThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => lessThan2(a, max8), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max8
  },
  title: `lessThanDuration(${max8})`,
  description: `a Duration less than ${decode(max8)}`,
  ...annotations3
})), "lessThanDuration");
var LessThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => lessThanOrEqualTo2(a, max8), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max8
  },
  title: `lessThanOrEqualToDuration(${max8})`,
  description: `a Duration less than or equal to ${decode(max8)}`,
  ...annotations3
})), "lessThanOrEqualToDuration");
var GreaterThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => greaterThan2(a, min5), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min5
  },
  title: `greaterThanDuration(${min5})`,
  description: `a Duration greater than ${decode(min5)}`,
  ...annotations3
})), "greaterThanDuration");
var GreaterThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => greaterThanOrEqualTo2(a, min5), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min5
  },
  title: `greaterThanOrEqualToDuration(${min5})`,
  description: `a Duration greater than or equal to ${decode(min5)}`,
  ...annotations3
})), "greaterThanOrEqualToDuration");
var BetweenDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter12((a) => between2(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations3
})), "betweenDuration");
var Uint8ArrayFromSelf = class extends (/* @__PURE__ */ declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence4(equals)
})) {
};
__name(Uint8ArrayFromSelf, "Uint8ArrayFromSelf");
var Uint8 = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between5(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
}))) {
};
__name(Uint8, "Uint8");
var Uint8Array$ = class extends (/* @__PURE__ */ transform2(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i) => Uint8Array.from(i),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
})) {
};
__name(Uint8Array$, "Uint8Array$");
var makeUint8ArrayTransformation = /* @__PURE__ */ __name((id3, decode8, encode7) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode8(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed13(encode7(a))
}).annotations({
  identifier: id3
}), "makeUint8ArrayTransformation");
var Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = /* @__PURE__ */ __name((id3, decode8, encode7) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id3}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode8(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed13(encode7(a))
}).annotations({
  identifier: `StringFrom${id3}`
}), "makeEncodingTransformation");
var StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = /* @__PURE__ */ transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "minItems");
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "maxItems");
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "itemsCount");
var getNumberIndexedAccess2 = /* @__PURE__ */ __name((self2) => make47(getNumberIndexedAccess(self2.ast)), "getNumberIndexedAccess");
function head5(self2) {
  return transform2(self2, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self2))), {
    strict: false,
    decode: (i) => head(i),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of
    })
  });
}
__name(head5, "head");
function headNonEmpty3(self2) {
  return transform2(self2, getNumberIndexedAccess2(typeSchema(self2)), {
    strict: false,
    decode: (i) => headNonEmpty(i),
    encode: (a) => of(a)
  });
}
__name(headNonEmpty3, "headNonEmpty");
var headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess2(typeSchema(self2)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? succeed13(i[0]) : fallback ? succeed13(fallback()) : fail13(new Type2(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed13(of(a))
}));
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations3
})), "validDate");
var LessThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => a < max8, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max8
  },
  title: `lessThanDate(${formatDate(max8)})`,
  description: `a date before ${formatDate(max8)}`,
  ...annotations3
})), "lessThanDate");
var LessThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = /* @__PURE__ */ __name((max8, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max8, {
  schemaId: LessThanOrEqualToDateSchemaId,
  [LessThanOrEqualToDateSchemaId]: {
    max: max8
  },
  title: `lessThanOrEqualToDate(${formatDate(max8)})`,
  description: `a date before or equal to ${formatDate(max8)}`,
  ...annotations3
})), "lessThanOrEqualToDate");
var GreaterThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => a > min5, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min5
  },
  title: `greaterThanDate(${formatDate(min5)})`,
  description: `a date after ${formatDate(min5)}`,
  ...annotations3
})), "greaterThanDate");
var GreaterThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = /* @__PURE__ */ __name((min5, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min5, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min5
  },
  title: `greaterThanOrEqualToDate(${formatDate(min5)})`,
  description: `a date after or equal to ${formatDate(min5)}`,
  ...annotations3
})), "greaterThanOrEqualToDate");
var BetweenDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = /* @__PURE__ */ __name((min5, max8, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max8 && a >= min5, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max8,
    min: min5
  },
  title: `betweenDate(${formatDate(min5)}, ${formatDate(max8)})`,
  description: `a date between ${formatDate(min5)} and ${formatDate(max8)}`,
  ...annotations3
})), "betweenDate");
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date4) => `new Date(${JSON.stringify(date4)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
};
__name(DateFromSelf, "DateFromSelf");
var ValidDateFromSelf = class extends (/* @__PURE__ */ DateFromSelf.pipe(/* @__PURE__ */ validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
};
__name(ValidDateFromSelf, "ValidDateFromSelf");
var DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
};
__name(DateFromString, "DateFromString");
var Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
};
__name(Date$, "Date$");
var DateFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
})) {
};
__name(DateFromNumber, "DateFromNumber");
var DateTimeUtcFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date4) => unsafeFromDate2(date4)),
  equivalence: () => Equivalence5
})) {
};
__name(DateTimeUtcFromSelf, "DateTimeUtcFromSelf");
var decodeDateTimeUtc = /* @__PURE__ */ __name((input, ast) => _try({
  try: () => unsafeMake11(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
}), "decodeDateTimeUtc");
var DateTimeUtcFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed13(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
})) {
};
__name(DateTimeUtcFromNumber, "DateTimeUtcFromNumber");
var DateTimeUtcFromDate = class extends (/* @__PURE__ */ transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed13(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
})) {
};
__name(DateTimeUtcFromDate, "DateTimeUtcFromDate");
var DateTimeUtc = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed13(formatIso3(a))
}).annotations({
  identifier: "DateTimeUtc"
})) {
};
__name(DateTimeUtc, "DateTimeUtc");
var timeZoneOffsetArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2), "timeZoneOffsetArbitrary");
var TimeZoneOffsetFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
})) {
};
__name(TimeZoneOffsetFromSelf, "TimeZoneOffsetFromSelf");
var TimeZoneOffset = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i) => zoneMakeOffset2(i),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
})) {
};
__name(TimeZoneOffset, "TimeZoneOffset");
var timeZoneNamedArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2), "timeZoneNamedArbitrary");
var TimeZoneNamedFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
})) {
};
__name(TimeZoneNamedFromSelf, "TimeZoneNamedFromSelf");
var TimeZoneNamed = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i),
    catch: () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed13(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
})) {
};
__name(TimeZoneNamed, "TimeZoneNamed");
var TimeZoneFromSelf = class extends (/* @__PURE__ */ Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)) {
};
__name(TimeZoneFromSelf, "TimeZoneFromSelf");
var TimeZone = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(zoneFromString2(i), {
    onNone: () => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: succeed13
  }),
  encode: (a) => succeed13(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
})) {
};
__name(TimeZone, "TimeZone");
var timeZoneArbitrary = /* @__PURE__ */ __name((fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc)), "timeZoneArbitrary");
var DateTimeZonedFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence5
})) {
};
__name(DateTimeZonedFromSelf, "DateTimeZonedFromSelf");
var DateTimeZoned = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(makeZonedFromString2(i), {
    onNone: () => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: succeed13
  }),
  encode: (a) => succeed13(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
})) {
};
__name(DateTimeZoned, "DateTimeZoned");
var OptionNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = /* @__PURE__ */ __name((value6) => Struct({
  _tag: Literal2("Some"),
  value: value6
}).annotations({
  description: `SomeEncoded<${format6(value6)}>`
}), "optionSomeEncoded");
var optionEncoded = /* @__PURE__ */ __name((value6) => Union2(OptionNoneEncoded, optionSomeEncoded(value6)).annotations({
  description: `OptionEncoded<${format6(value6)}>`
}), "optionEncoded");
var optionDecode = /* @__PURE__ */ __name((input) => input._tag === "None" ? none2() : some3(input.value), "optionDecode");
var optionArbitrary = /* @__PURE__ */ __name((value6, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value6(fc)
})).map(optionDecode), "optionArbitrary");
var optionPretty = /* @__PURE__ */ __name((value6) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value6(a)})`
}), "optionPretty");
var optionParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isOption2(u) ? isNone2(u) ? succeed13(none2()) : toComposite(decodeUnknown4(u.value, options4), some3, ast, u) : fail13(new Type2(ast, u)), "optionParse");
var OptionFromSelf_ = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (value7) => optionParse(decodeUnknown2(value7)),
    encode: (value7) => optionParse(encodeUnknown(value7))
  }, {
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
}, "OptionFromSelf_");
var OptionFromSelf = /* @__PURE__ */ __name((value6) => {
  return OptionFromSelf_(value6).annotations({
    description: `Option<${format6(value6)}>`
  });
}, "OptionFromSelf");
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = /* @__PURE__ */ __name((value6) => ({
  _tag: "Some",
  value: value6
}), "makeSomeEncoded");
function Option(value6) {
  const value_ = asSchema(value6);
  const out = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i) => optionDecode(i),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
__name(Option, "Option");
function OptionFromNullOr(value6) {
  return transform2(NullOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: (a) => getOrNull(a)
  });
}
__name(OptionFromNullOr, "OptionFromNullOr");
function OptionFromNullishOr(value6, onNoneEncoding) {
  return transform2(NullishOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: onNoneEncoding === null ? (a) => getOrNull(a) : (a) => getOrUndefined(a)
  });
}
__name(OptionFromNullishOr, "OptionFromNullishOr");
function OptionFromUndefinedOr(value6) {
  return transform2(UndefinedOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: (a) => getOrUndefined(a)
  });
}
__name(OptionFromUndefinedOr, "OptionFromUndefinedOr");
var OptionFromNonEmptyTrimmedString = class extends (/* @__PURE__ */ transform2(String$, /* @__PURE__ */ OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => filter(some3(i.trim()), isNonEmpty5),
  encode: (a) => getOrElse(a, () => "")
})) {
};
__name(OptionFromNonEmptyTrimmedString, "OptionFromNonEmptyTrimmedString");
var rightEncoded = /* @__PURE__ */ __name((right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
}), "rightEncoded");
var leftEncoded = /* @__PURE__ */ __name((left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
}), "leftEncoded");
var eitherEncoded = /* @__PURE__ */ __name((right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
}), "eitherEncoded");
var eitherDecode = /* @__PURE__ */ __name((input) => input._tag === "Left" ? left2(input.left) : right2(input.right), "eitherDecode");
var eitherArbitrary = /* @__PURE__ */ __name((right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode), "eitherArbitrary");
var eitherPretty = /* @__PURE__ */ __name((right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
}), "eitherPretty");
var eitherParse = /* @__PURE__ */ __name((parseRight, decodeUnknownLeft) => (u, options4, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options4), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options4), right2, ast, u)
}) : fail13(new Type2(ast, u)), "eitherParse");
var EitherFromSelf = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
}, "EitherFromSelf");
var makeLeftEncoded = /* @__PURE__ */ __name((left3) => ({
  _tag: "Left",
  left: left3
}), "makeLeftEncoded");
var makeRightEncoded = /* @__PURE__ */ __name((right3) => ({
  _tag: "Right",
  right: right3
}), "makeRightEncoded");
var Either = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform2(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i) => eitherDecode(i),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
}, "Either");
var EitherFromUnion = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform2(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  });
  const fromLeft = transform2(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  });
  const out = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i) => i._tag === "Left" ? left2(i.left) : right2(i.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
}, "EitherFromUnion");
var mapArbitrary = /* @__PURE__ */ __name((key, value6, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value6(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as14) => new Map(as14));
  };
}, "mapArbitrary");
var readonlyMapPretty = /* @__PURE__ */ __name((key, value6) => (map33) => `new Map([${Array.from(map33.entries()).map(([k, v]) => `[${key(k)}, ${value6(v)}]`).join(", ")}])`, "readonlyMapPretty");
var readonlyMapEquivalence = /* @__PURE__ */ __name((key, value6) => {
  const arrayEquivalence = getEquivalence4(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
}, "readonlyMapEquivalence");
var readonlyMapParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isMap(u) ? toComposite(decodeUnknown4(Array.from(u.entries()), options4), (as14) => new Map(as14), ast, u) : fail13(new Type2(ast, u)), "readonlyMapParse");
var mapFromSelf_ = /* @__PURE__ */ __name((key, value6, description) => declare([key, value6], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
}), "mapFromSelf_");
var ReadonlyMapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `ReadonlyMap<${format6(key)}, ${format6(value6)}>`), "ReadonlyMapFromSelf");
var MapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `Map<${format6(key)}, ${format6(value6)}>`), "MapFromSelf");
function ReadonlyMap({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
__name(ReadonlyMap, "ReadonlyMap");
function map25({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
__name(map25, "map");
var ReadonlyMapFromRecord = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
}), "ReadonlyMapFromRecord");
var MapFromRecord = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
}), "MapFromRecord");
var setArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as14) => new Set(as14));
}, "setArbitrary");
var readonlySetPretty = /* @__PURE__ */ __name((item) => (set15) => `new Set([${Array.from(set15.values()).map((a) => item(a)).join(", ")}])`, "readonlySetPretty");
var readonlySetEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
}, "readonlySetEquivalence");
var readonlySetParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isSet(u) ? toComposite(decodeUnknown4(Array.from(u.values()), options4), (as14) => new Set(as14), ast, u) : fail13(new Type2(ast, u)), "readonlySetParse");
var setFromSelf_ = /* @__PURE__ */ __name((value6, description) => declare([value6], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
}), "setFromSelf_");
var ReadonlySetFromSelf = /* @__PURE__ */ __name((value6) => setFromSelf_(value6, `ReadonlySet<${format6(value6)}>`), "ReadonlySetFromSelf");
var SetFromSelf = /* @__PURE__ */ __name((value6) => setFromSelf_(value6, `Set<${format6(value6)}>`), "SetFromSelf");
function ReadonlySet(value6) {
  return transform2(Array$(value6), ReadonlySetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
__name(ReadonlySet, "ReadonlySet");
function set7(value6) {
  return transform2(Array$(value6), SetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
__name(set7, "set");
var bigDecimalPretty = /* @__PURE__ */ __name(() => (val) => `BigDecimal(${format4(normalize(val))})`, "bigDecimalPretty");
var bigDecimalArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value6, scale2]) => make43(value6, scale2)), "bigDecimalArbitrary");
var BigDecimalFromSelf = class extends (/* @__PURE__ */ declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence4
})) {
};
__name(BigDecimalFromSelf, "BigDecimalFromSelf");
var BigDecimal = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromString(i).pipe(match2({
    onNone: () => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: (val) => succeed13(normalize(val))
  })),
  encode: (a) => succeed13(format4(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
})) {
};
__name(BigDecimal, "BigDecimal");
var BigDecimalFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i) => unsafeFromNumber(i),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
};
__name(BigDecimalFromNumber, "BigDecimalFromNumber");
var GreaterThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = /* @__PURE__ */ __name((min5, annotations3) => (self2) => {
  const formatted = format4(min5);
  return self2.pipe(filter12((a) => greaterThan4(a, min5), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min5
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations3
  }));
}, "greaterThanBigDecimal");
var GreaterThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = /* @__PURE__ */ __name((min5, annotations3) => (self2) => {
  const formatted = format4(min5);
  return self2.pipe(filter12((a) => greaterThanOrEqualTo3(a, min5), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min5
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations3
  }));
}, "greaterThanOrEqualToBigDecimal");
var LessThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = /* @__PURE__ */ __name((max8, annotations3) => (self2) => {
  const formatted = format4(max8);
  return self2.pipe(filter12((a) => lessThan8(a, max8), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max8
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations3
  }));
}, "lessThanBigDecimal");
var LessThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = /* @__PURE__ */ __name((max8, annotations3) => (self2) => {
  const formatted = format4(max8);
  return self2.pipe(filter12((a) => lessThanOrEqualTo3(a, max8), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max8
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations3
  }));
}, "lessThanOrEqualToBigDecimal");
var PositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations3
})), "positiveBigDecimal");
var PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations3
})), "nonNegativeBigDecimal");
var NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations3
})), "negativeBigDecimal");
var NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter12((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations3
})), "nonPositiveBigDecimal");
var NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => {
  const formattedMinimum = format4(minimum);
  const formattedMaximum = format4(maximum);
  return self2.pipe(filter12((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations3
  }));
}, "betweenBigDecimal");
var clampBigDecimal = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp5(i, {
    minimum,
    maximum
  }),
  encode: identity
}), "clampBigDecimal");
var chunkArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
}, "chunkArbitrary");
var chunkPretty = /* @__PURE__ */ __name((item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`, "chunkPretty");
var chunkParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isChunk(u) ? isEmpty(u) ? succeed13(empty3()) : toComposite(decodeUnknown4(toReadonlyArray(u), options4), fromIterable3, ast, u) : fail13(new Type2(ast, u)), "chunkParse");
var ChunkFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format6(value6)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence5
  });
}, "ChunkFromSelf");
function Chunk(value6) {
  return transform2(Array$(value6), ChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => i.length === 0 ? empty3() : fromIterable3(i),
    encode: (a) => toReadonlyArray(a)
  });
}
__name(Chunk, "Chunk");
var nonEmptyChunkArbitrary = /* @__PURE__ */ __name((item) => (fc) => array5(item(fc), {
  minLength: 1
}).map((as14) => unsafeFromNonEmptyArray(as14)), "nonEmptyChunkArbitrary");
var nonEmptyChunkPretty = /* @__PURE__ */ __name((item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`, "nonEmptyChunkPretty");
var nonEmptyChunkParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isChunk(u) && isNonEmpty(u) ? toComposite(decodeUnknown4(toReadonlyArray(u), options4), unsafeFromNonEmptyArray, ast, u) : fail13(new Type2(ast, u)), "nonEmptyChunkParse");
var NonEmptyChunkFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format6(value6)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence5
  });
}, "NonEmptyChunkFromSelf");
function NonEmptyChunk(value6) {
  return transform2(NonEmptyArray(value6), NonEmptyChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => unsafeFromNonEmptyArray(i),
    encode: (a) => toReadonlyArray(a)
  });
}
__name(NonEmptyChunk, "NonEmptyChunk");
var decodeData = /* @__PURE__ */ __name((a) => Array.isArray(a) ? array3(a) : struct3(a), "decodeData");
var dataArbitrary = /* @__PURE__ */ __name((item) => (fc) => item(fc).map(decodeData), "dataArbitrary");
var dataPretty = /* @__PURE__ */ __name((item) => (d) => `Data(${item(d)})`, "dataPretty");
var dataParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isEqual(u) ? toComposite(decodeUnknown4(u, options4), decodeData, ast, u) : fail13(new Type2(ast, u)), "dataParse");
var DataFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format6(value6)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
}, "DataFromSelf");
var Data = /* @__PURE__ */ __name((value6) => {
  return transform2(value6, DataFromSelf(typeSchema(value6)), {
    strict: false,
    decode: (i) => decodeData(i),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
}, "Data");
var isField = /* @__PURE__ */ __name((u) => isSchema(u) || isPropertySignature(u), "isField");
var isFields = /* @__PURE__ */ __name((fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key])), "isFields");
var getFields = /* @__PURE__ */ __name((hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]), "getFields");
var getSchemaFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr)), "getSchemaFromFieldsOr");
var getFieldsFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr), "getFieldsFromFieldsOr");
var Class6 = /* @__PURE__ */ __name((identifier2) => (fieldsOr, annotations3) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class4,
  annotations: annotations3
}), "Class");
var getClassTag = /* @__PURE__ */ __name((tag8) => withConstructorDefault(propertySignature(Literal2(tag8)), () => tag8), "getClassTag");
var TaggedClass2 = /* @__PURE__ */ __name((identifier2) => (tag8, fieldsOr, annotations3) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema3 = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag8)
  };
  const taggedFields = extendFields(newFields, fields);
  return /* @__PURE__ */ __name(class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag8,
    schema: extend3(schema3, Struct(newFields)),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations3
  }) {
    static _tag = tag8;
  }, "TaggedClass");
}, "TaggedClass");
var TaggedError2 = /* @__PURE__ */ __name((identifier2) => (tag8, fieldsOr, annotations3) => {
  class Base3 extends Error3 {
  }
  __name(Base3, "Base");
  ;
  Base3.prototype.name = tag8;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema3 = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag8)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag8,
    schema: extend3(schema3, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations3,
    disableToString: true
  }) {
    static _tag = tag8;
  }
  __name(TaggedErrorClass, "TaggedErrorClass");
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
}, "TaggedError");
var extendFields = /* @__PURE__ */ __name((a, b) => {
  const out = {
    ...a
  };
  for (const key of Reflect.ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
}, "extendFields");
function getDisableValidationMakeOption(options4) {
  return isBoolean(options4) ? options4 : options4?.disableValidation ?? false;
}
__name(getDisableValidationMakeOption, "getDisableValidationMakeOption");
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = /* @__PURE__ */ __name((annotations3) => {
  if (annotations3 === void 0) {
    return [];
  } else if (Array.isArray(annotations3)) {
    return annotations3;
  } else {
    return [annotations3];
  }
}, "getClassAnnotations");
var makeClass = /* @__PURE__ */ __name(({
  Base: Base3,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema: schema3
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
  const typeSchema_ = typeSchema(schema3);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema3.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema3.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema3.annotations({
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = /* @__PURE__ */ __name((u) => hasProperty(u, classSymbol) && is(typeSide)(u), "fallbackInstanceOf");
  const klass = /* @__PURE__ */ __name(class extends Base3 {
    constructor(props = {}, options4 = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options4)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId19] = variance5;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema3], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed13(input) : fail13(new Type2(ast, input)),
        encode: () => (input, options4) => input instanceof this ? succeed13(input) : map24(encodeUnknown(typeSide)(input, options4), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty6) => (self2) => `${identifier2}(${pretty6(self2)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make47(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema3, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options4, annotations4) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema3, typeSchema(Struct(transformedFields)), options4),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options4, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema3), Struct(transformedFields), options4),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  }, "klass");
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
}, "makeClass");
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend7(() => FiberIdEncoded),
  right: suspend7(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = /* @__PURE__ */ __name((fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode), "fiberIdArbitrary");
var fiberIdPretty = /* @__PURE__ */ __name((fiberId3) => {
  switch (fiberId3._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
  }
}, "fiberIdPretty");
var FiberIdFromSelf = class extends (/* @__PURE__ */ declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
})) {
};
__name(FiberIdFromSelf, "FiberIdFromSelf");
var fiberIdDecode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
}, "fiberIdDecode");
var fiberIdEncode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
}, "fiberIdEncode");
var FiberId = class extends (/* @__PURE__ */ transform2(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i) => fiberIdDecode(i),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
})) {
};
__name(FiberId, "FiberId");
var causeDieEncoded = /* @__PURE__ */ __name((defect) => Struct({
  _tag: Literal2("Die"),
  defect
}), "causeDieEncoded");
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = /* @__PURE__ */ __name((error3) => Struct({
  _tag: Literal2("Fail"),
  error: error3
}), "causeFailEncoded");
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = /* @__PURE__ */ __name((error3, defect) => {
  const error_ = asSchema(error3);
  const defect_ = asSchema(defect);
  const suspended3 = suspend7(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error3)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
}, "causeEncoded");
var causeArbitrary = /* @__PURE__ */ __name((error3, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error3(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode), "causeArbitrary");
var causePretty = /* @__PURE__ */ __name((error3) => (cause3) => {
  const f = /* @__PURE__ */ __name((cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error3(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  }, "f");
  return f(cause3);
}, "causePretty");
var causeParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options4), causeDecode, ast, u) : fail13(new Type2(ast, u)), "causeParse");
var CauseFromSelf = /* @__PURE__ */ __name(({
  defect,
  error: error3
}) => {
  return declare([error3, defect], {
    decode: (error4, defect2) => causeParse(decodeUnknown2(causeEncoded(error4, defect2))),
    encode: (error4, defect2) => causeParse(encodeUnknown(causeEncoded(error4, defect2)))
  }, {
    title: `Cause<${error3.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
}, "CauseFromSelf");
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty26;
    case "Fail":
      return fail5(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt4(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
__name(causeDecode, "causeDecode");
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
__name(causeEncode, "causeEncode");
var Cause = /* @__PURE__ */ __name(({
  defect,
  error: error3
}) => {
  const error_ = asSchema(error3);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
}, "Cause");
var Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return prettyErrorMessage(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
};
__name(Defect, "Defect");
var exitFailureEncoded = /* @__PURE__ */ __name((error3, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error3, defect)
}), "exitFailureEncoded");
var exitSuccessEncoded = /* @__PURE__ */ __name((value6) => Struct({
  _tag: Literal2("Success"),
  value: value6
}), "exitSuccessEncoded");
var exitEncoded = /* @__PURE__ */ __name((value6, error3, defect) => {
  return Union2(exitFailureEncoded(error3, defect), exitSuccessEncoded(value6)).annotations({
    title: `ExitEncoded<${format6(value6)}, ${format6(error3)}, ${format6(defect)}>`
  });
}, "exitEncoded");
var exitDecode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "Failure":
      return failCause3(causeDecode(input.cause));
    case "Success":
      return succeed3(input.value);
  }
}, "exitDecode");
var exitArbitrary = /* @__PURE__ */ __name((value6, error3, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error3, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value6(fc)
})).map(exitDecode), "exitArbitrary");
var exitPretty = /* @__PURE__ */ __name((value6, error3) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty(error3)(exit4.cause)})` : `Exit.succeed(${value6(exit4.value)})`, "exitPretty");
var exitParse = /* @__PURE__ */ __name((decodeUnknownValue, decodeUnknownCause) => (u, options4, ast) => isExit(u) ? match9(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options4), failCause3, ast, u),
  onSuccess: (value6) => toComposite(decodeUnknownValue(value6, options4), succeed3, ast, u)
}) : fail13(new Type2(ast, u)), "exitParse");
var ExitFromSelf = /* @__PURE__ */ __name(({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
}), "ExitFromSelf");
var Exit = /* @__PURE__ */ __name(({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
}, "Exit");
var hashSetArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
}, "hashSetArbitrary");
var hashSetPretty = /* @__PURE__ */ __name((item) => (set15) => `HashSet(${Array.from(set15).map((a) => item(a)).join(", ")})`, "hashSetPretty");
var hashSetEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "hashSetEquivalence");
var hashSetParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isHashSet2(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable6, ast, u) : fail13(new Type2(ast, u)), "hashSetParse");
var HashSetFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format6(value6)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
}, "HashSetFromSelf");
function HashSet(value6) {
  return transform2(Array$(value6), HashSetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromIterable6(i),
    encode: (a) => Array.from(a)
  });
}
__name(HashSet, "HashSet");
var hashMapArbitrary = /* @__PURE__ */ __name((key, value6, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value6(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
}, "hashMapArbitrary");
var hashMapPretty = /* @__PURE__ */ __name((key, value6) => (map33) => `HashMap([${Array.from(map33).map(([k, v]) => `[${key(k)}, ${value6(v)}]`).join(", ")}])`, "hashMapPretty");
var hashMapEquivalence = /* @__PURE__ */ __name((key, value6) => {
  const arrayEquivalence = getEquivalence4(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "hashMapEquivalence");
var hashMapParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isHashMap2(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable7, ast, u) : fail13(new Type2(ast, u)), "hashMapParse");
var HashMapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => {
  return declare([key, value6], {
    decode: (key2, value7) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value7)))),
    encode: (key2, value7) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value7))))
  }, {
    description: `HashMap<${format6(key)}, ${format6(value6)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
}, "HashMapFromSelf");
var HashMap = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => {
  return transform2(Array$(Tuple(key, value6)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: (i) => fromIterable7(i),
    encode: (a) => Array.from(a)
  });
}, "HashMap");
var listArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
}, "listArbitrary");
var listPretty = /* @__PURE__ */ __name((item) => (set15) => `List(${Array.from(set15).map((a) => item(a)).join(", ")})`, "listPretty");
var listEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "listEquivalence");
var listParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isList(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable8, ast, u) : fail13(new Type2(ast, u)), "listParse");
var ListFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format6(value6)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
}, "ListFromSelf");
function List(value6) {
  return transform2(Array$(value6), ListFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: (i) => fromIterable8(i),
    encode: (a) => Array.from(a)
  });
}
__name(List, "List");
var sortedSetArbitrary = /* @__PURE__ */ __name((item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as14) => fromIterable12(as14, ord));
}, "sortedSetArbitrary");
var sortedSetPretty = /* @__PURE__ */ __name((item) => (set15) => `new SortedSet([${Array.from(values5(set15)).map((a) => item(a)).join(", ")}])`, "sortedSetPretty");
var sortedSetParse = /* @__PURE__ */ __name((decodeUnknown4, ord) => (u, options4, ast) => isSortedSet(u) ? toComposite(decodeUnknown4(Array.from(values5(u)), options4), (as14) => fromIterable12(as14, ord), ast, u) : fail13(new Type2(ast, u)), "sortedSetParse");
var SortedSetFromSelf = /* @__PURE__ */ __name((value6, ordA, ordI) => {
  return declare([value6], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format6(value6)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence7()
  });
}, "SortedSetFromSelf");
function SortedSet(value6, ordA) {
  const to = typeSchema(asSchema(value6));
  return transform2(Array$(value6), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (i) => fromIterable12(i, ordA),
    encode: (a) => Array.from(values5(a))
  });
}
__name(SortedSet, "SortedSet");
var BooleanFromUnknown = class extends (/* @__PURE__ */ transform2(Unknown, Boolean$, {
  strict: true,
  decode: (i) => isTruthy(i),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
};
__name(BooleanFromUnknown, "BooleanFromUnknown");
var BooleanFromString = class extends (/* @__PURE__ */ transform2(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i) => i === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
})) {
};
__name(BooleanFromString, "BooleanFromString");
var Config = /* @__PURE__ */ __name((name, schema3) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema3);
  return string4(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error3) => InvalidData2([], TreeFormatter.formatIssueSync(error3))))));
}, "Config");
var symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = /* @__PURE__ */ __name((serializable) => serializable, "asSerializable");
var serializableSchema = /* @__PURE__ */ __name((self2) => self2[symbolSerializable], "serializableSchema");
var serialize = /* @__PURE__ */ __name((self2) => encodeUnknown2(self2[symbolSerializable])(self2), "serialize");
var deserialize = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolSerializable])(value6));
var symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = /* @__PURE__ */ __name((withExit) => withExit, "asWithResult");
var failureSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].failure, "failureSchema");
var successSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].success, "successSchema");
var exitSchemaCache = /* @__PURE__ */ globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = /* @__PURE__ */ __name((self2) => {
  const proto14 = Object.getPrototypeOf(self2);
  if (!(symbolWithResult in proto14)) {
    return Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
  }
  let schema3 = exitSchemaCache.get(proto14);
  if (schema3 === void 0) {
    schema3 = Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
    exitSchemaCache.set(proto14, schema3);
  }
  return schema3;
}, "exitSchema");
var serializeFailure = /* @__PURE__ */ dual(2, (self2, value6) => encode5(self2[symbolWithResult].failure)(value6));
var deserializeFailure = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolWithResult].failure)(value6));
var serializeSuccess = /* @__PURE__ */ dual(2, (self2, value6) => encode5(self2[symbolWithResult].success)(value6));
var deserializeSuccess = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolWithResult].success)(value6));
var serializeExit = /* @__PURE__ */ dual(2, (self2, value6) => encode5(exitSchema(self2))(value6));
var deserializeExit = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(exitSchema(self2))(value6));
var asSerializableWithResult = /* @__PURE__ */ __name((procedure) => procedure, "asSerializableWithResult");
var TaggedRequest = /* @__PURE__ */ __name((identifier2) => (tag8, options4, annotations3) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag8)
  }, options4.payload);
  return /* @__PURE__ */ __name(class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag8,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations3
  }) {
    static _tag = tag8;
    static success = options4.success;
    static failure = options4.failure;
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options4.failure,
        success: options4.success
      };
    }
  }, "TaggedRequestClass");
}, "TaggedRequest");
var equivalence2 = /* @__PURE__ */ __name((schema3) => go2(schema3.ast, []), "equivalence");
var getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);
var go2 = /* @__PURE__ */ __name((ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go2(tp, path)));
      case "Refinement":
        return hook.value(go2(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go2(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go2(ast.from, path);
    case "Suspend": {
      const get23 = memoizeThunk(() => go2(ast.f(), path));
      return (a, b) => get23()(a, b);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i) => go2(element2.type, path.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
      return make((a, b) => {
        if (!Array.isArray(a) || !Array.isArray(b)) {
          return false;
        }
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head10, ...tail2] = rest;
          for (; i < len - tail2.length; i++) {
            if (!head10(a[i], b[i])) {
              return false;
            }
          }
          for (let j = 0; j < tail2.length; j++) {
            i += j;
            if (!tail2[j](a[i], b[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go2(is4.type, path));
      return make((a, b) => {
        if (!isRecord(a) || !isRecord(b)) {
          return false;
        }
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is4 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol2 = isSymbolKeyword(encodedParameter);
          if (isSymbol2) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
          for (let j = 0; j < aKeys.length; j++) {
            const key = aKeys[j];
            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const len = ownKeys.length;
      return make((a, b) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal2 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                candidates = candidates.concat(buckets[literal2]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go2(ast2, path), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is4] = tuples[i];
          if (is4(a) && is4(b)) {
            if (equivalence3(a, b)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
}, "go");
var SymbolStruct = /* @__PURE__ */ TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = /* @__PURE__ */ transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i) => decodeSymbol(i.key),
  encode: (a, _, ast) => map24(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  }))
});
var PropertyKey$ = class extends (/* @__PURE__ */ Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
})) {
};
__name(PropertyKey$, "PropertyKey$");
var ArrayFormatterIssue = class extends (/* @__PURE__ */ Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
})) {
};
__name(ArrayFormatterIssue, "ArrayFormatterIssue");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Error.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId20 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
var TypeIdError = /* @__PURE__ */ __name((typeId, tag8) => {
  class Base3 extends Error3 {
    _tag = tag8;
  }
  __name(Base3, "Base");
  ;
  Base3.prototype[typeId] = typeId;
  Base3.prototype.name = tag8;
  return Base3;
}, "TypeIdError");
var Module = /* @__PURE__ */ Literal2("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");
var BadArgument = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/BadArgument")("BadArgument", {
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  /**
   * @since 1.0.0
   */
  [TypeId20] = TypeId20;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
  }
};
__name(BadArgument, "BadArgument");
var SystemErrorReason = /* @__PURE__ */ Literal2("AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero");
var SystemError = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/SystemError")("SystemError", {
  reason: SystemErrorReason,
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  syscall: /* @__PURE__ */ optional(String$),
  pathOrDescriptor: /* @__PURE__ */ optional(/* @__PURE__ */ Union2(String$, Number$)),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  /**
   * @since 1.0.0
   */
  [TypeId20] = TypeId20;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.reason}: ${this.module}.${this.method}${this.pathOrDescriptor !== void 0 ? ` (${this.pathOrDescriptor})` : ""}${this.description ? `: ${this.description}` : ""}`;
  }
};
__name(SystemError, "SystemError");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/KeyValueStore.js
var KeyValueStore_exports = {};
__export(KeyValueStore_exports, {
  KeyValueStore: () => KeyValueStore,
  SchemaStoreTypeId: () => SchemaStoreTypeId2,
  TypeId: () => TypeId24,
  layerFileSystem: () => layerFileSystem2,
  layerMemory: () => layerMemory2,
  layerSchema: () => layerSchema2,
  layerStorage: () => layerStorage2,
  make: () => make64,
  makeStringOnly: () => makeStringOnly2,
  prefix: () => prefix2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/keyValueStore.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/FileSystem.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all9,
  error: () => error,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined,
  unbranded: () => unbranded
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var BrandTypeId = /* @__PURE__ */ Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var error = /* @__PURE__ */ __name((message, meta) => [{
  message,
  meta
}], "error");
var errors = /* @__PURE__ */ __name((...errors3) => flatten2(errors3), "errors");
function refined(...args2) {
  const either9 = args2.length === 2 ? (unbranded2) => args2[0](unbranded2) ? right2(unbranded2) : left2(args2[1](unbranded2)) : (unbranded2) => {
    return match2(args2[0](unbranded2), {
      onNone: () => right2(unbranded2),
      onSome: left2
    });
  };
  return Object.assign((unbranded2) => getOrThrowWith(either9(unbranded2), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args3) => getRight2(either9(args3)),
    either: either9,
    is: (args3) => isRight2(either9(args3))
  });
}
__name(refined, "refined");
var nominal = /* @__PURE__ */ __name(() => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some3(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
}, "nominal");
var all9 = /* @__PURE__ */ __name((...brands) => {
  const either9 = /* @__PURE__ */ __name((args2) => {
    let result = right2(args2);
    for (const brand2 of brands) {
      const nextResult = brand2.either(args2);
      if (isLeft2(result) && isLeft2(nextResult)) {
        result = left2([...result.left, ...nextResult.left]);
      } else {
        result = isLeft2(result) ? result : nextResult;
      }
    }
    return result;
  }, "either");
  return Object.assign((args2) => match(either9(args2), {
    onLeft: (e) => {
      throw e;
    },
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => getRight2(either9(args2)),
    either: either9,
    is: (args2) => isRight2(either9(args2))
  });
}, "all");
var unbranded = unsafeCoerce;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Channel.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRef.js
var FiberRef_exports = {};
__export(FiberRef_exports, {
  FiberRefTypeId: () => FiberRefTypeId2,
  currentConcurrency: () => currentConcurrency2,
  currentContext: () => currentContext2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentLogLevel: () => currentLogLevel2,
  currentLogSpan: () => currentLogSpan2,
  currentLoggers: () => currentLoggers2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentScheduler: () => currentScheduler2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentSupervisor: () => currentSupervisor2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  delete: () => _delete,
  get: () => get14,
  getAndSet: () => getAndSet3,
  getAndUpdate: () => getAndUpdate3,
  getAndUpdateSome: () => getAndUpdateSome3,
  getWith: () => getWith,
  interruptedCause: () => interruptedCause,
  make: () => make48,
  makeContext: () => makeContext2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeWith: () => makeWith,
  modify: () => modify7,
  modifySome: () => modifySome3,
  reset: () => reset,
  set: () => set8,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  unsafeMake: () => unsafeMake12,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  update: () => update5,
  updateAndGet: () => updateAndGet3,
  updateSome: () => updateSome3,
  updateSomeAndGet: () => updateSomeAndGet3,
  versionMismatchErrorLogLevel: () => versionMismatchErrorLogLevel
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var FiberRefTypeId2 = FiberRefTypeId;
var make48 = fiberRefMake;
var makeWith = fiberRefMakeWith;
var makeContext2 = fiberRefMakeContext;
var makeRuntimeFlags = fiberRefMakeRuntimeFlags;
var unsafeMake12 = fiberRefUnsafeMake;
var unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
var unsafeMakeContext = fiberRefUnsafeMakeContext;
var unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
var unsafeMakePatch = fiberRefUnsafeMakePatch;
var get14 = fiberRefGet;
var getAndSet3 = fiberRefGetAndSet;
var getAndUpdate3 = fiberRefGetAndUpdate;
var getAndUpdateSome3 = fiberRefGetAndUpdateSome;
var getWith = fiberRefGetWith;
var set8 = fiberRefSet;
var _delete = fiberRefDelete;
var reset = fiberRefReset;
var modify7 = fiberRefModify;
var modifySome3 = fiberRefModifySome;
var update5 = fiberRefUpdate;
var updateSome3 = fiberRefUpdateSome;
var updateAndGet3 = fiberRefUpdateAndGet;
var updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
var currentConcurrency2 = currentConcurrency;
var currentRequestBatchingEnabled = currentRequestBatching;
var currentRequestCache = currentCache;
var currentRequestCacheEnabled = currentCacheEnabled;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
var unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
var versionMismatchErrorLogLevel = currentVersionMismatchErrorLogLevel;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentLogLevel2 = currentLogLevel;
var currentMinimumLogLevel2 = currentMinimumLogLevel;
var currentLogSpan2 = currentLogSpan;
var currentRuntimeFlags2 = currentRuntimeFlags;
var currentScheduler2 = currentScheduler;
var currentSupervisor2 = currentSupervisor;
var currentMetricLabels2 = currentMetricLabels;
var currentTracerEnabled2 = currentTracerEnabled;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;
var currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
var currentTracerSpanLinks2 = currentTracerSpanLinks;
var interruptedCause = currentInterruptedCause;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/PubSub.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/pubsub.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/queue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var QueueImpl = class extends Class2 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map11(this.size, (size18) => size18 <= 0);
  }
  get isFull() {
    return map11(this.size, (size18) => size18 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll4(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value6);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value6);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll4(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value6);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value6);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value6], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const values6 = fromIterable2(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values6.length)) : empty2;
      const [forTakers, remaining] = pipe(values6, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get7(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values6 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values6);
      });
    });
  }
  takeUpTo(max8) {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values6 = this.queue.pollUpTo(max8);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable3(values6);
    }));
  }
  takeBetween(min5, max8) {
    return suspend(() => takeRemainderLoop(this, min5, max8, empty3()));
  }
};
__name(QueueImpl, "QueueImpl");
var takeRemainderLoop = /* @__PURE__ */ __name((self2, min5, max8, acc) => {
  if (max8 < min5) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self2, max8), flatMap9((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self2), map11((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self2), flatMap9((b) => takeRemainderLoop(self2, remaining - 1, max8 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, "takeRemainderLoop");
var bounded2 = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make49(backingQueueFromMutableQueue(queue), backPressureStrategy()))), "bounded");
var dropping = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make49(backingQueueFromMutableQueue(queue), droppingStrategy()))), "dropping");
var sliding = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make49(backingQueueFromMutableQueue(queue), slidingStrategy()))), "sliding");
var unbounded2 = /* @__PURE__ */ __name(() => pipe(sync(() => unbounded()), flatMap9((queue) => make49(backingQueueFromMutableQueue(queue), droppingStrategy()))), "unbounded");
var unsafeMake13 = /* @__PURE__ */ __name((queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
}, "unsafeMake");
var make49 = /* @__PURE__ */ __name((queue, strategy) => pipe(deferredMake(), map11((deferred) => unsafeMake13(queue, unbounded(), deferred, make12(false), strategy))), "make");
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable3) {
    this.mutable = mutable3;
  }
  poll(def) {
    return poll4(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element2) {
    return offer(this.mutable, element2);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
__name(BackingQueueFromMutableQueue, "BackingQueueFromMutableQueue");
var backingQueueFromMutableQueue = /* @__PURE__ */ __name((mutable3) => new BackingQueueFromMutableQueue(mutable3), "backingQueueFromMutableQueue");
var capacity2 = /* @__PURE__ */ __name((self2) => self2.capacity(), "capacity");
var size13 = /* @__PURE__ */ __name((self2) => self2.size, "size");
var isFull = /* @__PURE__ */ __name((self2) => self2.isFull, "isFull");
var isEmpty11 = /* @__PURE__ */ __name((self2) => self2.isEmpty, "isEmpty");
var isShutdown = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
var awaitShutdown = /* @__PURE__ */ __name((self2) => self2.awaitShutdown, "awaitShutdown");
var shutdown = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var offer2 = /* @__PURE__ */ dual(2, (self2, value6) => self2.offer(value6));
var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var poll5 = /* @__PURE__ */ __name((self2) => map11(self2.takeUpTo(1), head2), "poll");
var take2 = /* @__PURE__ */ __name((self2) => self2.take, "take");
var takeAll = /* @__PURE__ */ __name((self2) => self2.takeAll, "takeAll");
var takeUpTo = /* @__PURE__ */ dual(2, (self2, max8) => self2.takeUpTo(max8));
var takeBetween = /* @__PURE__ */ dual(3, (self2, min5, max8) => self2.takeBetween(min5, max8));
var takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
var backPressureStrategy = /* @__PURE__ */ __name(() => new BackPressureStrategy(), "backPressureStrategy");
var droppingStrategy = /* @__PURE__ */ __name(() => new DroppingStrategy(), "droppingStrategy");
var slidingStrategy = /* @__PURE__ */ __name(() => new SlidingStrategy(), "slidingStrategy");
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty10(this.putters) && !isEmpty10(takers)) {
      const taker = poll4(takers, void 0);
      const putter = poll4(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap9((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap9((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get7(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll4(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable2(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value6 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value6, deferred, true]));
      } else {
        pipe(this.putters, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
};
__name(BackPressureStrategy, "BackPressureStrategy");
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_2;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
__name(DroppingStrategy, "DroppingStrategy");
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_2;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
};
__name(SlidingStrategy, "SlidingStrategy");
var unsafeCompleteDeferred = /* @__PURE__ */ __name((deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
}, "unsafeCompleteDeferred");
var unsafeOfferAll = /* @__PURE__ */ __name((queue, as14) => {
  return pipe(queue, offerAll(as14));
}, "unsafeOfferAll");
var unsafePollAll = /* @__PURE__ */ __name((queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, "unsafePollAll");
var unsafePollN = /* @__PURE__ */ __name((queue, max8) => {
  return pipe(queue, pollUpTo(max8));
}, "unsafePollN");
var unsafeRemove = /* @__PURE__ */ __name((queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
}, "unsafeRemove");
var unsafeCompleteTakers = /* @__PURE__ */ __name((strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll4(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element2 = queue.poll(EmptyMutableQueue);
      if (element2 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element2);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty10(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
}, "unsafeCompleteTakers");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set15 = subscribers.get(subscription);
  set15.add(pollers);
}, "addSubscribers");
var removeSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set15 = subscribers.get(subscription);
  set15.delete(pollers);
  if (set15.size === 0) {
    subscribers.delete(subscription);
  }
}, "removeSubscribers");
var bounded3 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new BackPressureStrategy2());
}), "bounded");
var dropping2 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new DroppingStrategy2());
}), "dropping");
var sliding2 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new SlidingStrategy2());
}), "sliding");
var unbounded3 = /* @__PURE__ */ __name((options4) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options4);
  return makePubSub(pubsub, new DroppingStrategy2());
}), "unbounded");
var shutdown2 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var subscribe = /* @__PURE__ */ __name((self2) => self2.subscribe, "subscribe");
var makeBoundedPubSub = /* @__PURE__ */ __name((capacity7) => {
  const options4 = typeof capacity7 === "number" ? {
    capacity: capacity7
  } : capacity7;
  ensureCapacity(options4.capacity);
  const replayBuffer = options4.replay && options4.replay > 0 ? new ReplayBuffer(Math.ceil(options4.replay)) : void 0;
  if (options4.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options4.capacity) === options4.capacity) {
    return new BoundedPubSubPow2(options4.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options4.capacity, replayBuffer);
  }
}, "makeBoundedPubSub");
var makeUnboundedPubSub = /* @__PURE__ */ __name((options4) => new UnboundedPubSub(options4?.replay ? new ReplayBuffer(options4.replay) : void 0), "makeUnboundedPubSub");
var makeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, strategy) => map11(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make12(false), strategy)), "makeSubscription");
var unsafeMakeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow()), "unsafeMakeSubscription");
var BoundedPubSubArb = class {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index2 = this.publisherIndex % this.capacity;
      this.array[index2] = value6;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty3();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size18 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size18;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet2(chunk4, iteratorIndex++);
      const index2 = this.publisherIndex % this.capacity;
      this.array[index2] = a;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index2 = this.subscribersIndex % this.capacity;
      this.array[index2] = AbsentValue;
      this.subscribers[index2] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
__name(BoundedPubSubArb, "BoundedPubSubArb");
var BoundedPubSubArbSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index2 = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty3();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size18 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size18);
    if (toPoll <= 0) {
      return empty3();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index2 = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index2 = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index2] -= 1;
        if (this.self.subscribers[index2] === 0) {
          this.self.array[index2] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
__name(BoundedPubSubArbSubscription, "BoundedPubSubArbSubscription");
var BoundedPubSubPow2 = class {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.mask = capacity7 - 1;
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index2 = this.publisherIndex & this.mask;
      this.array[index2] = value6;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty3();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size18 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size18;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet2(chunk4, iteratorIndex++);
      const index2 = this.publisherIndex & this.mask;
      this.array[index2] = elem;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index2 = this.subscribersIndex & this.mask;
      this.array[index2] = AbsentValue;
      this.subscribers[index2] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
__name(BoundedPubSubPow2, "BoundedPubSubPow2");
var BoundedPubSubPow2Subscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index2 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty3();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size18 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size18);
    if (toPoll <= 0) {
      return empty3();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index2 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index2 = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index2] -= 1;
        if (this.self.subscribers[index2] === 0) {
          this.self.array[index2] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
__name(BoundedPubSubPow2Subscription, "BoundedPubSubPow2Subscription");
var BoundedPubSubSingle = class {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value6;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty3();
    }
    const chunk4 = fromIterable3(elements);
    if (isEmpty(chunk4)) {
      return chunk4;
    }
    if (this.publish(unsafeHead2(chunk4))) {
      return drop2(chunk4, 1);
    } else {
      return chunk4;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
__name(BoundedPubSubSingle, "BoundedPubSubSingle");
var BoundedPubSubSingleSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty3();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
__name(BoundedPubSubSingleSubscription, "BoundedPubSubSingleSubscription");
var UnboundedPubSub = class {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value6,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty3();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
__name(UnboundedPubSub, "UnboundedPubSub");
var UnboundedPubSubSubscription = class {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty44 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty44 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty44;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
__name(UnboundedPubSubSubscription, "UnboundedPubSubSubscription");
var SubscriptionImpl = class extends Class2 {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map11(this.size, (size18) => size18 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty10(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const as14 = isEmpty10(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty3();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as14));
      }
      return succeed(as14);
    });
  }
  takeUpTo(max8) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max8) {
        const as15 = this.replayWindow.takeN(max8);
        return succeed(as15);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max8 = max8 - replay.length;
      }
      const as14 = isEmpty10(this.pollers) ? unsafePollN2(this.subscription, max8) : empty3();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as14)) : succeed(as14);
    });
  }
  takeBetween(min5, max8) {
    return suspend(() => takeRemainderLoop2(this, min5, max8, empty3()));
  }
};
__name(SubscriptionImpl, "SubscriptionImpl");
var takeRemainderLoop2 = /* @__PURE__ */ __name((self2, min5, max8, acc) => {
  if (max8 < min5) {
    return succeed(acc);
  }
  return pipe(self2.takeUpTo(max8), flatMap9((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(self2.take, map11((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self2.take, flatMap9((b) => takeRemainderLoop2(self2, remaining - 1, max8 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, "takeRemainderLoop");
var PubSubImpl = class {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.pubsub.size());
  }
  get isFull() {
    return map11(this.size, (size18) => size18 === this.capacity());
  }
  get isEmpty() {
    return map11(this.size, (size18) => size18 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value6)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value6), this.shutdownFlag);
    });
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value6)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap2(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
    return map11(acquireRelease(acquire, (tuple4, exit4) => tuple4[0].close(exit4)), (tuple4) => tuple4[1]);
  }
  offer(value6) {
    return this.publish(value6);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(PubSubImpl, "PubSubImpl");
var makePubSub = /* @__PURE__ */ __name((pubsub, strategy) => flatMap9(scopeMake(), (scope5) => map11(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make12(false), strategy))), "makePubSub");
var unsafeMakePubSub = /* @__PURE__ */ __name((pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy), "unsafeMakePubSub");
var ensureCapacity = /* @__PURE__ */ __name((capacity7) => {
  if (capacity7 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity7}`);
  }
}, "ensureCapacity");
var unsafeCompleteDeferred2 = /* @__PURE__ */ __name((deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
}, "unsafeCompleteDeferred");
var unsafeOfferAll2 = /* @__PURE__ */ __name((queue, as14) => {
  return pipe(queue, offerAll(as14));
}, "unsafeOfferAll");
var unsafePollAllQueue = /* @__PURE__ */ __name((queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, "unsafePollAllQueue");
var unsafePollAllSubscription = /* @__PURE__ */ __name((subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
}, "unsafePollAllSubscription");
var unsafePollN2 = /* @__PURE__ */ __name((subscription, max8) => {
  return subscription.pollUpTo(max8);
}, "unsafePollN");
var unsafePublishAll = /* @__PURE__ */ __name((pubsub, as14) => {
  return pubsub.publishAll(as14);
}, "unsafePublishAll");
var unsafeRemove2 = /* @__PURE__ */ __name((queue, value6) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value6)));
}, "unsafeRemove");
var BackPressureStrategy2 = class {
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap9(fiberId, (fiberId3) => flatMap9(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last5]) => last5 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get7(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll4(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next = iterator.next();
    if (!next.done) {
      while (1) {
        const value6 = next.value;
        next = iterator.next();
        if (next.done) {
          pipe(this.publishers, offer([value6, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
  }
};
__name(BackPressureStrategy2, "BackPressureStrategy");
var DroppingStrategy2 = class {
  get shutdown() {
    return void_2;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
__name(DroppingStrategy2, "DroppingStrategy");
var SlidingStrategy2 = class {
  get shutdown() {
    return void_2;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next = it.next();
    if (!next.done && pubsub.capacity > 0) {
      let a = next.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next = it.next()) && !next.done) {
          a = next.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
};
__name(SlidingStrategy2, "SlidingStrategy");
var unsafeStrategyCompletePollers = /* @__PURE__ */ __name((strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll4(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty10(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
}, "unsafeStrategyCompletePollers");
var unsafeStrategyCompleteSubscribers = /* @__PURE__ */ __name((strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
}, "unsafeStrategyCompleteSubscribers");
var ReplayBuffer = class {
  capacity;
  constructor(capacity7) {
    this.capacity = capacity7;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as14) {
    for (const a of as14) {
      this.offer(a);
    }
  }
};
__name(ReplayBuffer, "ReplayBuffer");
var ReplayWindowImpl = class {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer4) {
    this.buffer = buffer4;
    this.index = buffer4.index;
    this.remaining = buffer4.size;
    this.head = buffer4.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value6 = this.head.value;
    this.head = this.head.next;
    return value6;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty3();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value6 = this.head.value;
      this.head = this.head.next;
      items[i] = value6;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
__name(ReplayWindowImpl, "ReplayWindowImpl");
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty3(),
  takeAll: () => empty3()
};

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var shutdown3 = shutdown2;
var subscribe2 = subscribe;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Queue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var DequeueTypeId2 = DequeueTypeId;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity4 = capacity2;
var size15 = size13;
var isEmpty13 = isEmpty11;
var isFull3 = isFull;
var isShutdown3 = isShutdown;
var awaitShutdown3 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take3 = take2;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core-stream.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto6 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto6);
  op._tag = OP_CONTINUE2;
  return op;
}, "Continue");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/continuation.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/continuation.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure3(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
__name(ContinuationKImpl, "ContinuationKImpl");
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer3) {
    this.finalizer = finalizer3;
  }
};
__name(ContinuationFinalizerImpl, "ContinuationFinalizerImpl");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto7 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = /* @__PURE__ */ __name((emitSeparator) => {
  const op = Object.create(proto7);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
}, "PullAfterNext");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channel.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto8 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelTypeId2) || isEffect2(u), "isChannel");
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
  const op = Object.create(proto8);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self2;
  op.finalizer = release;
  return op;
});
var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(succeed14, f);
  return op;
});
var collectElements = /* @__PURE__ */ __name((self2) => {
  return suspend8(() => {
    const builder = [];
    return flatMap17(pipeTo(self2, collectElementsReader(builder)), (value6) => sync9(() => [fromIterable3(builder), value6]));
  });
}, "collectElements");
var collectElementsReader = /* @__PURE__ */ __name((builder) => readWith({
  onInput: (outElem) => flatMap17(sync9(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail14,
  onDone: succeedNow
}), "collectElementsReader");
var concatAllWith = /* @__PURE__ */ __name((channels, f, g) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
}, "concatAllWith");
var concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self2;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
  const op = Object.create(proto8);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self2;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer3) => {
  const op = Object.create(proto8);
  op._tag = OP_ENSURING;
  op.channel = self2;
  op.finalizer = finalizer3;
  return op;
});
var fail14 = /* @__PURE__ */ __name((error3) => failCause11(fail5(error3)), "fail");
var failCause11 = /* @__PURE__ */ __name((cause3) => failCauseSync6(() => cause3), "failCause");
var failCauseSync6 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
}, "failCauseSync");
var flatMap17 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(f, failCause11);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options4) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(options4.onSuccess, options4.onFailure);
  return op;
});
var fromEffect5 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto8);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
}, "fromEffect");
var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto8);
  op._tag = OP_PIPE_TO;
  op.left = () => self2;
  op.right = () => that;
  return op;
});
var provideContext3 = /* @__PURE__ */ dual(2, (self2, env) => {
  const op = Object.create(proto8);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self2;
  return op;
});
var readWith = /* @__PURE__ */ __name((options4) => readWithCause({
  onInput: options4.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options4.onFailure,
    onRight: failCause11
  }),
  onDone: options4.onDone
}), "readWith");
var readWithCause = /* @__PURE__ */ __name((options4) => {
  const op = Object.create(proto8);
  op._tag = OP_READ;
  op.more = options4.onInput;
  op.done = new ContinuationKImpl(options4.onDone, options4.onFailure);
  return op;
}, "readWithCause");
var succeed14 = /* @__PURE__ */ __name((value6) => sync9(() => value6), "succeed");
var succeedNow = /* @__PURE__ */ __name((result) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
}, "succeedNow");
var suspend8 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
}, "suspend");
var sync9 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
}, "sync");
var void_7 = /* @__PURE__ */ succeedNow(void 0);
var write = /* @__PURE__ */ __name((out) => {
  const op = Object.create(proto8);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
}, "write");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/channelState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto9 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = /* @__PURE__ */ __name(() => {
  const op = Object.create(proto9);
  op._tag = OP_DONE3;
  return op;
}, "Done");
var Emit = /* @__PURE__ */ __name(() => {
  const op = Object.create(proto9);
  op._tag = OP_EMIT2;
  return op;
}, "Emit");
var fromEffect6 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
}, "fromEffect");
var Read = /* @__PURE__ */ __name((upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto9);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
}, "Read");
var isFromEffect = /* @__PURE__ */ __name((self2) => self2._tag === OP_FROM_EFFECT3, "isFromEffect");
var effect2 = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? self2.effect : _void, "effect");
var effectOrUndefinedIgnored = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? ignore2(self2.effect) : void 0, "effectOrUndefinedIgnored");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/subexecutor.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith8(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
__name(PullFromChild, "PullFromChild");
var PullFromUpstream = class {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith8(acc, exit3(next), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
__name(PullFromUpstream, "PullFromUpstream");
var DrainChildExecutors = class {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith8(acc, exit3(next), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
__name(DrainChildExecutors, "DrainChildExecutors");
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value6, next) {
    this.value = value6;
    this.next = next;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
__name(Emit2, "Emit");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto10 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = /* @__PURE__ */ __name((value6) => {
  const op = Object.create(proto10);
  op._tag = OP_PULLED;
  op.value = value6;
  return op;
}, "Pulled");
var NoUpstream = /* @__PURE__ */ __name((activeDownstreamCount) => {
  const op = Object.create(proto10);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
}, "NoUpstream");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = /* @__PURE__ */ __name(() => flatMap14(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value6) => bridgeInput.done(value6)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap14(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  })), "drainer");
                  result = fromEffect6(flatMap14(forkDaemon2(interruptible4(drainer())), (fiber) => sync6(() => this.addFinalizer((exit4) => flatMap14(interrupt5(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync6(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight6(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value6) => channel.k(value6), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value6) => channel.onEmit(value6));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_7;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect4, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value6) => {
                    const state = this.doneSucceed(value6);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync6(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read3 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read3.more(emitted);
                  } catch (error3) {
                    this._currentChannel = read3.done.onExit(die3(error3));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit4 = /* @__PURE__ */ __name((exit5) => {
                    return read3.done.onExit(exit5);
                  }, "onExit");
                  this._currentChannel = onExit4(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error3) {
          this._currentChannel = failCause11(die4(error3));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring2(sync6(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync6(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip8(exit3(ifNotNull(runInProgressFinalizers))),
      zip8(exit3(ifNotNull(closeSelf))),
      map20(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap14((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value6) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const head10 = this._doneStack[this._doneStack.length - 1];
    if (head10._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head10.onSuccess(value6);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value6));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring2(sync6(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap14(() => sync6(() => this.doneSucceed(value6))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head10 = this._doneStack[this._doneStack.length - 1];
    if (head10._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head10.onHalt(cause3);
      } catch (error3) {
        this._currentChannel = failCause11(die4(error3));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring2(sync6(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap14(() => sync6(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync6(() => {
        this._currentChannel = failCause11(cause3);
      }),
      onSuccess: (out) => sync6(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring9) {
    this.addFinalizer(ensuring9.finalizer);
    this._currentChannel = ensuring9.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match9(exit4, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value6) => this.doneSucceed(value6)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach10((closeFunc) => pipe(sync6(() => closeFunc(subexecutorDone)), flatMap14((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value6) => this.doneSucceed(value6)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight6(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map20(() => {
          const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map20(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map13((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed10(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
__name(ChannelExecutor, "ChannelExecutor");
var ifNotNull = /* @__PURE__ */ __name((effect4) => effect4 !== void 0 ? effect4 : _void, "ifNotNull");
var runFinalizers = /* @__PURE__ */ __name((finalizers, exit4) => {
  return pipe(forEach10(finalizers, (fin) => exit3(fin(exit4))), map20((exits) => pipe(all4(exits), getOrElse(() => void_4))), flatMap14((exit5) => suspend4(() => exit5)));
}, "runFinalizers");
var readUpstream = /* @__PURE__ */ __name((r, onSuccess, onFailure) => {
  const readStack = [r];
  const read3 = /* @__PURE__ */ __name(() => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause3((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause3(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read3());
      }
    }
  }, "read");
  return read3();
}, "readUpstream");
var runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
  const run6 = /* @__PURE__ */ __name((channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync6(() => new ChannelExecutor(self2, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight6(_await3(channelDeferred)), zipLeft6(_await3(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause9(cause3)));
  }), "run");
  return uninterruptibleMask3((restore) => all7([fork2(scope5, sequential3), make41(), make41()]).pipe(flatMap14(([child, channelDeferred, scopeDeferred]) => restore(run6(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap14((fiber) => scope5.addFinalizer((exit4) => {
    const interruptors3 = isFailure3(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone5(channelDeferred).pipe(flatMap14((isDone7) => isDone7 ? succeed8(scopeDeferred, void 0).pipe(zipRight6(_await2(fiber)), zipRight6(inheritAll2(fiber))) : succeed8(scopeDeferred, void 0).pipe(zipRight6(interruptors3 && size4(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt5(fiber)), zipRight6(inheritAll2(fiber)))));
  }).pipe(zipRight6(restore(_await3(channelDeferred)))))))));
});
var runScopedInterpret = /* @__PURE__ */ __name((channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap14(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause9);
    }
  }
}, "runScopedInterpret");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto11 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto11);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
}, "Done");
var Await = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto11);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
}, "Await");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto12 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = /* @__PURE__ */ __name((left3, right3) => {
  const op = Object.create(proto12);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
}, "BothRunning");
var LeftDone = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto12);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
}, "LeftDone");
var RightDone = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto12);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
}, "RightDone");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto13 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto13);
  op._tag = OP_BACK_PRESSURE;
  return op;
}, "BackPressure");
var BufferSliding = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto13);
  op._tag = OP_BUFFER_SLIDING;
  return op;
}, "BufferSliding");
var match17 = /* @__PURE__ */ dual(2, (self2, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self2._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = /* @__PURE__ */ __name((notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
}), "stateEmpty");
var stateEmit = /* @__PURE__ */ __name((notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
}), "stateEmit");
var stateError = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
}), "stateError");
var stateDone = /* @__PURE__ */ __name((done12) => ({
  _tag: OP_STATE_DONE2,
  done: done12
}), "stateDone");
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten10(modify6(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await3(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt4(fiberId3)));
  }
  done(value6) {
    return flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach10(state.notifyConsumers, (deferred) => succeed8(deferred, left2(value6)), {
            discard: true
          }), stateDone(value6)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element2) {
    return flatMap14(make41(), (deferred) => flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed8(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach10(state.notifyConsumers, (deferred) => failCause7(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map16(cause3, left2)), (elem) => succeed3(elem), (done12) => fail3(right2(done12)));
  }
  takeWith(onError5, onElement, onDone3) {
    return flatMap14(make41(), (deferred) => flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight6(succeed8(state.notifyProducer, void 0), matchCause4(_await3(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await3(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed10(onError5(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed10(onDone3(state.done)), state];
        }
      }
    })));
  }
};
__name(SingleProducerAsyncInputImpl, "SingleProducerAsyncInputImpl");
var make50 = /* @__PURE__ */ __name(() => pipe(make41(), flatMap14((deferred) => make25(stateEmpty(deferred))), map20((ref) => new SingleProducerAsyncInputImpl(ref))), "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = /* @__PURE__ */ __name((acquire, use3, release) => flatMap17(fromEffect5(make25(() => _void)), (ref) => pipe(fromEffect5(uninterruptible2(tap4(acquire, (a) => set5(ref, (exit4) => release(a, exit4))))), flatMap17(use3), ensuringWith((exit4) => flatMap14(get12(ref), (f) => f(exit4))))), "acquireUseRelease");
var as8 = /* @__PURE__ */ dual(2, (self2, value6) => map26(self2, () => value6));
var catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause11
})));
var concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => void 0, () => void 0));
var drain = /* @__PURE__ */ __name((self2) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause11,
    onDone: succeed14
  });
  return pipeTo(self2, drainer);
}, "drain");
var ensuring3 = /* @__PURE__ */ dual(2, (self2, finalizer3) => ensuringWith(self2, () => finalizer3));
var flatten13 = /* @__PURE__ */ __name((self2) => flatMap17(self2, identity), "flatten");
var foldChannel = /* @__PURE__ */ dual(2, (self2, options4) => foldCauseChannel(self2, {
  onFailure: (cause3) => {
    const either9 = failureOrCause2(cause3);
    switch (either9._tag) {
      case "Left": {
        return options4.onFailure(either9.left);
      }
      case "Right": {
        return failCause11(either9.right);
      }
    }
  },
  onSuccess: options4.onSuccess
}));
var fromInput = /* @__PURE__ */ __name((input) => unwrap2(input.takeWith(failCause11, (elem) => flatMap17(write(elem), () => fromInput(input)), succeed14)), "fromInput");
var fromQueue = /* @__PURE__ */ __name((queue) => suspend8(() => fromQueueInternal(queue)), "fromQueue");
var fromQueueInternal = /* @__PURE__ */ __name((queue) => pipe(fromEffect5(take3(queue)), flatMap17(match({
  onLeft: match9({
    onFailure: failCause11,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap17(write(elem), () => fromQueueInternal(queue))
}))), "fromQueueInternal");
var identityChannel = /* @__PURE__ */ __name(() => readWith({
  onInput: (input) => flatMap17(write(input), () => identityChannel()),
  onFailure: fail14,
  onDone: succeedNow
}), "identityChannel");
var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect4) => mergeWith2(self2, {
  other: fromEffect5(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await3(deferred)));
var map26 = /* @__PURE__ */ dual(2, (self2, f) => flatMap17(self2, (a) => sync9(() => f(a))));
var mapError7 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause4(self2, map16(f)));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => failCause11(f(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap17(write(f(outElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect5(f(outElem)), flatMap17(write), flatMap17(() => reader)),
    onFailure: failCause11,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope5) => gen3(function* () {
  const input = yield* make50();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const errorSignal = yield* make41();
  const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause9(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight6(interruptible4(withPermits(n)(_void)), asVoid5(offer3(queue, succeed10(left2(outDone))))),
      onRight: (outElem) => gen3(function* () {
        const deferred = yield* make41();
        const latch = yield* make41();
        yield* offer3(queue, map20(_await3(deferred), right2));
        yield* succeed8(latch, void 0).pipe(zipRight6(uninterruptibleMask3((restore) => exit3(restore(_await3(errorSignal))).pipe(raceFirst2(exit3(restore(f(outElem)))), flatMap14(identity))).pipe(tapErrorCause3((cause3) => failCause7(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
        yield* _await3(latch);
      })
    })
  }), forever3, interruptible4, forkIn2(scope5));
  const consumer = unwrap2(matchCause4(flatten10(take3(queue)), {
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap17(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll6 = /* @__PURE__ */ __name((options4) => {
  return (channels) => mergeAllWith(options4)(channels, constVoid);
}, "mergeAll");
var mergeAllWith = /* @__PURE__ */ __name(({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope5) => gen3(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make50();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope5, shutdown4(cancelers));
  const lastDone = yield* make25(none2());
  const errorSignal = yield* make41();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap14(match({
      onLeft: (done12) => succeed10(some3(done12)),
      onRight: (outElem) => as7(offer3(queue, succeed10(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap14((outDone) => update3(lastDone, match2({
      onNone: () => some3(outDone.value),
      onSome: (lastDone2) => some3(f(lastDone2, outDone.value))
    }))), catchAllCause3((cause3) => isInterrupted3(cause3) ? failCause9(cause3) : offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed8(errorSignal, void 0)), asVoid5)));
  }
  __name(evaluatePull, "evaluatePull");
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed10(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await3(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as7(interrupt5(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight6(interrupt5(failureAwait), get12(lastDone).pipe(flatMap14(match2({
          onNone: () => offer3(queue, succeed10(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed10(left2(f(lastDone2, outDone))))
        })), as7(false)))
      }),
      onRight: (channel) => match17(mergeStrategy, {
        onBackPressure: () => gen3(function* () {
          const latch = yield* make41();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap14((pull2) => race2(exit3(evaluatePull(pull2)), exit3(interruptible4(_await3(errorSignal))))), flatMap14(identity)));
          yield* succeed8(latch, void 0).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen3(function* () {
          const canceler = yield* make41();
          const latch = yield* make41();
          const size18 = yield* size15(cancelers);
          yield* take3(cancelers).pipe(flatMap14((canceler2) => succeed8(canceler2, void 0)), when2(() => size18 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap14((pull2) => exit3(evaluatePull(pull2)).pipe(race2(exit3(interruptible4(_await3(errorSignal)))), race2(exit3(interruptible4(_await3(canceler)))))), flatMap14(identity)));
          yield* succeed8(latch, void 0).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope5));
  const consumer = pipe(take3(queue), flatten10, matchCause4({
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap17(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
})), "mergeAllWith");
var mergeMap = /* @__PURE__ */ dual(3, (self2, f, options4) => mergeAll6(options4)(mapOut(self2, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options4) => {
  function merge13(scope5) {
    return gen3(function* () {
      const input = yield* make50();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options4.other), scope5);
      function handleSide(exit4, fiber, pull) {
        return (done12, both2, single2) => {
          function onDecision2(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed10(fromEffect5(zipRight6(interrupt5(fiber), op.effect)));
            }
            return map20(_await2(fiber), match9({
              onFailure: (cause3) => fromEffect5(op.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done13) => fromEffect5(op.f(succeed3(done13))),
                onRight: (elem) => zipRight7(write(elem), go3(single2(op.f)))
              })
            }));
          }
          __name(onDecision2, "onDecision");
          return match9(exit4, {
            onFailure: (cause3) => onDecision2(done12(failCause3(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision2(done12(succeed3(z))),
              onRight: (elem) => succeed10(flatMap17(write(elem), () => flatMap17(fromEffect5(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go3(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      __name(handleSide, "handleSide");
      function go3(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join4(state.left));
            const rightJoin = interruptible4(join4(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight6(interrupt5(rf), handleSide(leftExit, state.right, pullL)(options4.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight6(interrupt5(lf), handleSide(rightExit, state.left, pullR)(options4.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map20(exit3(pullR), match9({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done12) => fromEffect5(state.f(succeed3(done12))),
                onRight: (elem) => flatMap17(write(elem), () => go3(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map20(exit3(pullL), match9({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done12) => fromEffect5(state.f(succeed3(done12))),
                onRight: (elem) => flatMap17(write(elem), () => go3(RightDone(state.f)))
              })
            })));
          }
        }
      }
      __name(go3, "go");
      return fromEffect5(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope5));
        return zipWith8(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap17(go3), embedInput(input));
    });
  }
  __name(merge13, "merge");
  return unwrapScopedWith(merge13);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll5(self2, (e) => failCauseSync6(() => die4(f(e)))));
var orElse10 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend8(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap17(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause11(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap17(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail14(cause3.defect.error) : failCause11(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
}));
var repeated = /* @__PURE__ */ __name((self2) => flatMap17(self2, () => repeated(self2)), "repeated");
var run = /* @__PURE__ */ __name((self2) => scopedWith2((scope5) => runIn(self2, scope5)), "run");
var runDrain = /* @__PURE__ */ __name((self2) => run(drain(self2)), "runDrain");
var runScoped = /* @__PURE__ */ __name((self2) => scopeWith2((scope5) => runIn(self2, scope5)), "runScoped");
var scoped5 = /* @__PURE__ */ __name((effect4) => unwrap2(uninterruptibleMask3((restore) => map20(make39(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect4, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit4) => close(scope5, exit4))))), "scoped");
var scopedWith3 = /* @__PURE__ */ __name((f) => unwrapScoped3(map20(scope3, (scope5) => flatMap17(fromEffect5(f(scope5)), write))), "scopedWith");
var splitLines = /* @__PURE__ */ __name(() => suspend8(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = /* @__PURE__ */ __name((chunk4) => {
    const chunkBuilder = [];
    map5(chunk4, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  }, "splitLinesChunk");
  const loop3 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop3 : flatMap17(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause11(cause3) : flatMap17(write(of2(stringBuilder)), () => failCause11(cause3)),
    onDone: (done12) => stringBuilder.length === 0 ? succeed14(done12) : flatMap17(write(of2(stringBuilder)), () => succeed14(done12))
  });
  return loop3;
}), "splitLines");
var toPubSub = /* @__PURE__ */ __name((pubsub) => toQueue(pubsub), "toPubSub");
var toPull = /* @__PURE__ */ __name((self2) => flatMap14(scope3, (scope5) => toPullIn(self2, scope5)), "toPull");
var toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip8(sync6(() => new ChannelExecutor(self2, void 0, identity)), runtime4()).pipe(tap4(([executor, runtime6]) => addFinalizerExit(scope5, (exit4) => {
  const finalizer3 = executor.close(exit4);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime6) : _void;
})), uninterruptible2, map20(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = /* @__PURE__ */ __name((channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause9,
        onSuccess: (done12) => succeed10(left2(done12))
      });
    }
    case OP_EMIT2: {
      return succeed10(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap14(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause9(cause3));
    }
  }
}, "interpretToPull");
var toQueue = /* @__PURE__ */ __name((queue) => suspend8(() => toQueueInternal(queue)), "toQueue");
var toQueueInternal = /* @__PURE__ */ __name((queue) => {
  return readWithCause({
    onInput: (elem) => flatMap17(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(offer3(queue, left2(failCause3(cause3)))),
    onDone: (done12) => fromEffect5(offer3(queue, left2(succeed3(done12))))
  });
}, "toQueueInternal");
var unwrap2 = /* @__PURE__ */ __name((channel) => flatten13(fromEffect5(channel)), "unwrap");
var unwrapScoped3 = /* @__PURE__ */ __name((self2) => concatAllWith(scoped5(self2), (d, _) => d, (d, _) => d), "unwrapScoped");
var unwrapScopedWith = /* @__PURE__ */ __name((f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d), "unwrapScopedWith");
var withSpan5 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all7([makeSpan2(name, options4), context3(), clock2, get14(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self2 = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context11]) => provideContext3(self2, add4(context11, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  }
  return (self2) => acquireUseRelease3(acquire, ([span4, context11]) => provideContext3(self2, add4(context11, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
}, "withSpan");
var writeAll = /* @__PURE__ */ __name((...outs) => writeChunk(fromIterable3(outs)), "writeAll");
var writeChunk = /* @__PURE__ */ __name((outs) => writeChunkWriter(0, outs.length, outs), "writeChunk");
var writeChunkWriter = /* @__PURE__ */ __name((idx, len, chunk4) => {
  return idx === len ? void_7 : pipe(write(pipe(chunk4, unsafeGet2(idx))), flatMap17(() => writeChunkWriter(idx + 1, len, chunk4)));
}, "writeChunkWriter");
var zip10 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? mergeWith2(self2, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip4(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip4(exit1, exit22)))
}) : flatMap17(self2, (a) => map26(that, (b) => [a, b])));
var zipLeft7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? map26(zip10(self2, that, {
  concurrent: true
}), (tuple4) => tuple4[0]) : flatMap17(self2, (z) => as8(that, z)));
var zipRight7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? map26(zip10(self2, that, {
  concurrent: true
}), (tuple4) => tuple4[1]) : flatMap17(self2, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = /* @__PURE__ */ __name((error3) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error3
}), "ChannelException");
var isChannelException = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelExceptionTypeId), "isChannelException");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/sink.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var SinkImpl = class {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(SinkImpl, "SinkImpl");
var isSink = /* @__PURE__ */ __name((u) => hasProperty(u, SinkTypeId2), "isSink");
var suspend9 = /* @__PURE__ */ __name((evaluate3) => new SinkImpl(suspend8(() => toChannel(evaluate3()))), "suspend");
var collectAll = /* @__PURE__ */ __name(() => new SinkImpl(collectAllLoop(empty3())), "collectAll");
var collectAllLoop = /* @__PURE__ */ __name((acc) => readWithCause({
  onInput: (chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))),
  onFailure: failCause11,
  onDone: () => succeed14(acc)
}), "collectAllLoop");
var collectAllN = /* @__PURE__ */ __name((n) => suspend9(() => fromChannel(collectAllNLoop(n, empty3()))), "collectAllN");
var collectAllNLoop = /* @__PURE__ */ __name((n, acc) => readWithCause({
  onInput: (chunk4) => {
    const [collected, leftovers] = splitAt2(chunk4, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed14(appendAll2(acc, collected));
    }
    return flatMap17(write(leftovers), () => succeed14(appendAll2(acc, collected)));
  },
  onFailure: failCause11,
  onDone: () => succeed14(acc)
}), "collectAllNLoop");
var collectLeftover = /* @__PURE__ */ __name((self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map26(([chunks3, z]) => [z, flatten3(chunks3)]))), "collectLeftover");
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail15 = /* @__PURE__ */ __name((e) => new SinkImpl(fail14(e)), "fail");
var fold = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldReader(s, contFn, f))), "fold");
var foldReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty(leftovers)) {
        return pipe(write(leftovers), as8(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
}, "foldReader");
var foldChunkSplit = /* @__PURE__ */ __name((s, chunk4, contFn, f, index2, length4) => {
  if (index2 === length4) {
    return [s, empty3()];
  }
  const s1 = f(s, pipe(chunk4, unsafeGet2(index2)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk4, contFn, f, index2 + 1, length4);
  }
  return [s1, pipe(chunk4, drop2(index2 + 1))];
}, "foldChunkSplit");
var foldSink = /* @__PURE__ */ dual(2, (self2, options4) => {
  const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
    onFailure: (error3) => toChannel(options4.onFailure(error3)),
    onSuccess: ([leftovers, z]) => suspend8(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter3(isNonEmpty))
      };
      const refReader = pipe(
        sync9(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty3();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap17((chunk4) => writeChunk(chunk4))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight7(passthrough5), pipeTo(toChannel(options4.onSuccess(z))));
      return flatMap17(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed14(leftoversRef.ref), flatMap17(writeChunk), zipRight7(writeChunk(newLeftovers)), as8(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldChunksReader(s, contFn, f))), "foldChunks");
var foldChunksReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
}, "foldChunksReader");
var foldEffect = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldEffectReader(s, contFn, f))), "foldEffect");
var foldEffectReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap17(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover2) => pipe(write(leftover2), as8(nextS))
    })))),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
}, "foldEffectReader");
var foldChunkSplitEffect = /* @__PURE__ */ __name((s, chunk4, contFn, f) => foldChunkSplitEffectInternal(s, chunk4, 0, chunk4.length, contFn, f), "foldChunkSplitEffect");
var foldChunkSplitEffectInternal = /* @__PURE__ */ __name((s, chunk4, index2, length4, contFn, f) => {
  if (index2 === length4) {
    return succeed10([s, none2()]);
  }
  return pipe(f(s, pipe(chunk4, unsafeGet2(index2))), flatMap14((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk4, index2 + 1, length4, contFn, f) : succeed10([s1, some3(pipe(chunk4, drop2(index2 + 1)))])));
}, "foldChunkSplitEffectInternal");
var foldLeftChunks = /* @__PURE__ */ __name((s, f) => foldChunks(s, constTrue, f), "foldLeftChunks");
var flatMap18 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
  onFailure: fail15,
  onSuccess: f
}));
var forEach11 = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach10(input, (v) => f(v), {
      discard: true
    })), flatMap17(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, "forEach");
var forEachChunk = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap17(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, "forEachChunk");
var forEachWhile = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, "forEachWhile");
var forEachWhileReader = /* @__PURE__ */ __name((f, input, index2, length4, cont) => {
  if (index2 === length4) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet2(index2)))), flatMap17((bool) => bool ? forEachWhileReader(f, input, index2 + 1, length4, cont) : write(pipe(input, drop2(index2)))), catchAll5((error3) => pipe(write(pipe(input, drop2(index2))), zipRight7(fail14(error3)))));
}, "forEachWhileReader");
var fromChannel = /* @__PURE__ */ __name((channel) => new SinkImpl(channel), "fromChannel");
var fromEffect7 = /* @__PURE__ */ __name((effect4) => new SinkImpl(fromEffect5(effect4)), "fromEffect");
var head6 = /* @__PURE__ */ __name(() => fold(none2(), isNone2, (option7, input) => match2(option7, {
  onNone: () => some3(input),
  onSome: () => option7
})), "head");
var last4 = /* @__PURE__ */ __name(() => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s)), "last");
var map27 = /* @__PURE__ */ dual(2, (self2, f) => {
  return new SinkImpl(pipe(toChannel(self2), map26(f)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self2, options4) => {
  function race6(scope5) {
    return gen3(function* () {
      const pubsub = yield* bounded4(options4?.capacity ?? 16);
      const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft7(fromEffect5(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options4.other)), zipLeft7(fromEffect5(shutdown4(subscription2)))),
        onSelfDone: options4.onSelfDone,
        onOtherDone: options4.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  __name(race6, "race");
  return unwrapScopedWith2(race6);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + reduce2(chunk4, 0, (s, a) => s + a));
var toChannel = /* @__PURE__ */ __name((self2) => isEffect2(self2) ? toChannel(fromEffect7(self2)) : self2.channel, "toChannel");
var unwrapScopedWith2 = /* @__PURE__ */ __name((f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map20((sink) => toChannel(sink))))), "unwrapScopedWith");
var zipRight8 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options4) => zipWith11(self2, that, (_, z2) => z2, options4));
var zipWith11 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options4) => options4?.concurrent ? raceWith3(self2, {
  other: that,
  onSelfDone: match9({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (leftZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: (rightZ) => succeed10(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match9({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (rightZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: (leftZ) => succeed10(f(leftZ, rightZ))
    }))
  })
}) : flatMap18(self2, (z) => map27(that, (z2) => f(z, z2))));
var count = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + chunk4.length);
var mkString = /* @__PURE__ */ suspend9(() => {
  const strings2 = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map5(elems, (elem) => {
    strings2.push(String(elem));
  })), map27(() => strings2.join("")));
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MergeDecision.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Done4 = Done3;
var Await2 = Await;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RcRef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/rcRef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance6 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class2 {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId21] = variance6;
  [TypeId11] = TypeId11;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context11, scope5, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context11;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get15(this);
  }
  get;
  commit() {
    return this.get;
  }
};
__name(RcRefImpl, "RcRefImpl");
var make51 = /* @__PURE__ */ __name((options4) => withFiberRuntime((fiber) => {
  const context11 = fiber.getFiberRef(currentContext);
  const scope5 = get6(context11, scopeTag);
  const ref = new RcRefImpl(options4.acquire, context11, scope5, options4.idleTimeToLive ? decode(options4.idleTimeToLive) : void 0);
  return as3(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_2;
    ref.state = stateClosed;
    return close2;
  }))), ref);
}), "make");
var get15 = /* @__PURE__ */ __name((self_) => {
  const self2 = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self2.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self2.state.refCount++;
        return self2.state.fiber ? as3(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo3("scope"), bind3("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self2.acquire, currentContext, add4(self2.context, scopeTag, scope5)))), map11(({
          scope: scope5,
          value: value6
        }) => {
          const state = {
            _tag: "Acquired",
            value: value6,
            scope: scope5,
            fiber: void 0,
            refCount: 1
          };
          self2.state = state;
          return state;
        }));
      }
    }
  })).pipe(self2.semaphore.withPermits(1), bindTo3("state"), bind3("scope", () => scopeTag), tap2(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_2;
    }
    if (self2.idleTimeToLive === void 0) {
      self2.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
        self2.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_2;
    })), ensuring(sync(() => {
      state.fiber = void 0;
    })), forkIn(self2.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self2.semaphore.withPermits(1));
  }))), map11(({
    state
  }) => state.value));
}, "get");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RcRef.js
var make52 = make51;
var get16 = get15;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Runtime.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var runFork3 = unsafeFork3;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var make53 = make40;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Schedule.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ScheduleTypeId2 = ScheduleTypeId;
var addDelay2 = addDelay;
var driver2 = driver;
var forever4 = forever2;
var passthrough4 = passthrough2;
var spaced2 = spaced;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/StreamHaltStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either2 = {
  _tag: OP_EITHER
};
var fromInput2 = /* @__PURE__ */ __name((input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either2;
    default:
      return input;
  }
}, "fromInput");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/TPubSub.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tPubSub.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/core.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/journal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/entry.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/versioned.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Versioned = class {
  value;
  constructor(value6) {
    this.value = value6;
  }
};
__name(Versioned, "Versioned");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/entry.js
var make54 = /* @__PURE__ */ __name((ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
}), "make");
var unsafeGet7 = /* @__PURE__ */ __name((self2) => {
  return self2.newValue;
}, "unsafeGet");
var unsafeSet = /* @__PURE__ */ __name((self2, value6) => {
  self2.isChanged = true;
  self2.newValue = value6;
}, "unsafeSet");
var commit = /* @__PURE__ */ __name((self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
}, "commit");
var isInvalid = /* @__PURE__ */ __name((self2) => {
  return self2.ref.versioned !== self2.expected;
}, "isInvalid");
var isChanged = /* @__PURE__ */ __name((self2) => {
  return self2.isChanged;
}, "isChanged");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = /* @__PURE__ */ __name((journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
}, "commitJournal");
var analyzeJournal = /* @__PURE__ */ __name((journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
}, "analyzeJournal");
var collectTodos = /* @__PURE__ */ __name((journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
}, "collectTodos");
var execTodos = /* @__PURE__ */ __name((todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
}, "execTodos");
var addTodo = /* @__PURE__ */ __name((txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
}, "addTodo");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/stmState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = /* @__PURE__ */ __name((u) => hasProperty(u, STMStateTypeId), "isSTMState");
var isRunning3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_RUNNING2;
}, "isRunning");
var isDone6 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_DONE6;
}, "isDone");
var done9 = /* @__PURE__ */ __name((exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit4)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
}, "done");
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = /* @__PURE__ */ __name((tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail3(tExit.error));
    }
    case OP_DIE3: {
      return done9(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt3(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
}, "fromTExit");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tExit.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var isExit2 = /* @__PURE__ */ __name((u) => hasProperty(u, TExitTypeId), "isExit");
var isSuccess4 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_SUCCEED3;
}, "isSuccess");
var isRetry = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_RETRY2;
}, "isRetry");
var fail16 = /* @__PURE__ */ __name((error3) => ({
  [TExitTypeId]: variance7,
  _tag: OP_FAIL5,
  error: error3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error3, that.error);
  }
}), "fail");
var die9 = /* @__PURE__ */ __name((defect) => ({
  [TExitTypeId]: variance7,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
}), "die");
var interrupt8 = /* @__PURE__ */ __name((fiberId3) => ({
  [TExitTypeId]: variance7,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
}), "interrupt");
var succeed16 = /* @__PURE__ */ __name((value6) => ({
  [TExitTypeId]: variance7,
  _tag: OP_SUCCEED3,
  value: value6,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value6)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value6, that.value);
  }
}), "succeed");
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance7,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tryCommit.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var done10 = /* @__PURE__ */ __name((exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
}, "done");
var suspend10 = /* @__PURE__ */ __name((journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
}, "suspend");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/txnId.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var txnCounter = {
  ref: 0
};
var make55 = /* @__PURE__ */ __name(() => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
}, "make");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var STMPrimitive = class {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(STMPrimitive, "STMPrimitive");
var unsafeAtomically = /* @__PURE__ */ __name((self2, onDone3, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler2 = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make55();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler2, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause9(cause3);
      })));
    }
  }
}), "unsafeAtomically");
var tryCommit = /* @__PURE__ */ __name((fiberId3, stm, state, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt4(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
}, "tryCommit");
var tryCommitSync = /* @__PURE__ */ __name((fiberId3, stm, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt4(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
}, "tryCommitSync");
var tryCommitAsync = /* @__PURE__ */ __name((fiberId3, self2, txnId, state, context11, scheduler2, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context11, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context11, scheduler2, priority, k));
        break;
      }
    }
  }
}, "tryCommitAsync");
var completeTodos = /* @__PURE__ */ __name((exit4, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit4);
}, "completeTodos");
var completeTryCommit = /* @__PURE__ */ __name((exit4, k) => {
  k(exit4);
}, "completeTryCommit");
var STMDriver = class {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet5(env, current2));
              break;
            }
            case "Left": {
              curr = fail17(current2.left);
              break;
            }
            case "None": {
              curr = fail17(new NoSuchElementException2());
              break;
            }
            case "Right": {
              curr = succeed17(current2.right);
              break;
            }
            case "Some": {
              curr = succeed17(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die9(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail16(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env));
                  curr = pipe(current2.effect_instruction_i1, ensuring5(sync11(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value6 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed16(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value6 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed16(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die10(e);
      }
    }
    return exit4;
  }
};
__name(STMDriver, "STMDriver");
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die10 = /* @__PURE__ */ __name((defect) => dieSync6(() => defect), "die");
var dieSync6 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "dieSync");
var effect3 = /* @__PURE__ */ __name((f) => withSTMRuntime((_) => succeed17(f(_.journal, _.fiberId, _.getEnv()))), "effect");
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer3) => matchSTM(self2, {
  onFailure: (e) => zipRight10(finalizer3, fail17(e)),
  onSuccess: (a) => zipRight10(finalizer3, succeed17(a))
}));
var fail17 = /* @__PURE__ */ __name((error3) => failSync7(() => error3), "fail");
var failSync7 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "failSync");
var flatMap19 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map28(right2), catchAll6((e) => pipe(onFailure(e), map28(left2))), flatMap19((either9) => {
  switch (either9._tag) {
    case "Left": {
      return succeed17(either9.left);
    }
    case "Right": {
      return onSuccess(either9.right);
    }
  }
})));
var withSTMRuntime = /* @__PURE__ */ __name((f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
}, "withSTMRuntime");
var interruptAs2 = /* @__PURE__ */ __name((fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
}, "interruptAs");
var map28 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap19((a) => sync11(() => f(a)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed17 = /* @__PURE__ */ __name((value6) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value6;
  return stm;
}, "succeed");
var sync11 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "sync");
var zipRight10 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap19(() => that)));
var zipWith13 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap19((a) => pipe(that, map28((b) => f(a, b))))));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/stm.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var as10 = /* @__PURE__ */ dual(2, (self2, value6) => pipe(self2, map28(() => value6)));
var flatten14 = /* @__PURE__ */ __name((self2) => flatMap19(self2, identity), "flatten");
var forEach12 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options4) => {
  if (options4?.discard) {
    return pipe(sync11(() => iterable[Symbol.iterator]()), flatMap19((iterator) => {
      const loop3 = suspend11(() => {
        const next = iterator.next();
        if (next.done) {
          return void_8;
        }
        return pipe(f(next.value), flatMap19(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend11(() => fromIterable2(iterable).reduce((acc, curr) => zipWith13(acc, f(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed17([])));
});
var all10 = /* @__PURE__ */ __name((input, options4) => {
  if (Symbol.iterator in input) {
    return forEach12(input, identity, options4);
  } else if (options4?.discard) {
    return forEach12(Object.values(input), identity, options4);
  }
  return map28(forEach12(Object.entries(input), ([_, e]) => map28(e, (a) => [_, a])), (values6) => {
    const res = {};
    for (const [k, v] of values6) {
      ;
      res[k] = v;
    }
    return res;
  });
}, "all");
var suspend11 = /* @__PURE__ */ __name((evaluate3) => flatten14(sync11(evaluate3)), "suspend");
var tap6 = /* @__PURE__ */ dual(2, (self2, f) => flatMap19(self2, (a) => as10(f(a), a)));
var void_8 = /* @__PURE__ */ succeed17(void 0);

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tQueue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tRef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TRefImpl = class {
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value6) {
    this.versioned = new Versioned(value6);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(TRefImpl, "TRefImpl");
var make56 = /* @__PURE__ */ __name((value6) => effect3((journal) => {
  const ref = new TRefImpl(value6);
  journal.set(ref, make54(ref, true));
  return ref;
}), "make");
var get17 = /* @__PURE__ */ __name((self2) => self2.modify((a) => [a, a]), "get");
var set9 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [void 0, value6]));
var getOrMakeEntry = /* @__PURE__ */ __name((self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make54(self2, false);
  journal.set(self2, entry);
  return entry;
}, "getOrMakeEntry");
var unsafeGet8 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet7(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value6, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value6);
  return void 0;
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var TQueueImpl = class {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const queue = unsafeGet8(this.ref, runtime6.journal);
    if (queue === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    return succeed17(queue.length);
  });
  isFull = /* @__PURE__ */ map28(this.size, (size18) => size18 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map28(this.size, (size18) => size18 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    unsafeSet2(this.ref, void 0, runtime6.journal);
    return void_8;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap19(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5);
  offer(value6) {
    return withSTMRuntime((runtime6) => {
      const queue = pipe(this.ref, unsafeGet8(runtime6.journal));
      if (queue === void 0) {
        return interruptAs2(runtime6.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value6);
        unsafeSet2(this.ref, queue, runtime6.journal);
        return succeed17(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed17(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed17(true);
          }
          queue.shift();
          queue.push(value6);
          unsafeSet2(this.ref, queue, runtime6.journal);
          return succeed17(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime6) => {
      const as14 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime6.journal);
      if (queue === void 0) {
        return interruptAs2(runtime6.fiberId);
      }
      if (queue.length + as14.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as14], runtime6.journal);
        return succeed17(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as14.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime6.journal);
          return succeed17(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as14.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime6.journal);
          return succeed17(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const queue = unsafeGet8(this.ref, runtime6.journal);
    if (queue === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    return succeed17(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const queue = unsafeGet8(this.ref, runtime6.journal);
    if (queue === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    return succeed17(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const queue = unsafeGet8(this.ref, runtime6.journal);
    if (queue === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime6.journal);
    return succeed17(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const queue = unsafeGet8(this.ref, runtime6.journal);
    if (queue === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    unsafeSet2(this.ref, [], runtime6.journal);
    return succeed17(queue);
  });
  takeUpTo(max8) {
    return withSTMRuntime((runtime6) => {
      const queue = unsafeGet8(this.ref, runtime6.journal);
      if (queue === void 0) {
        return interruptAs2(runtime6.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max8);
      unsafeSet2(this.ref, Array.from(remaining), runtime6.journal);
      return succeed17(Array.from(toTake));
    });
  }
};
__name(TQueueImpl, "TQueueImpl");
var isShutdown4 = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
var shutdown5 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var take4 = /* @__PURE__ */ __name((self2) => self2.take, "take");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = /* @__PURE__ */ __name((head10, subscribers, tail2) => ({
  head: head10,
  subscribers,
  tail: tail2
}), "makeNode");
var TPubSubImpl = class {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap19(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime6.journal);
    if (currentPublisherTail === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    return succeed17(unsafeGet8(this.pubsubSize, runtime6.journal));
  });
  isEmpty = /* @__PURE__ */ map28(this.size, (size18) => size18 === 0);
  isFull = /* @__PURE__ */ map28(this.size, (size18) => size18 === this.capacity());
  offer(value6) {
    return withSTMRuntime((runtime6) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime6.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime6.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime6.journal);
      if (currentSubscriberCount === 0) {
        return succeed17(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime6.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime6.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime6.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime6.journal);
        return succeed17(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed17(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime6.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet8(currentPublisherHead, runtime6.journal);
              if (node === void 0) {
                return retry5;
              }
              const head10 = node.head;
              const tail2 = node.tail;
              if (head10 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime6.journal);
                unsafeSet2(this.publisherHead, tail2, runtime6.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail2;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime6.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime6.journal);
          return succeed17(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map28(forEach12(iterable, (a) => this.offer(a)), every2(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== void 0) {
      unsafeSet2(this.publisherTail, void 0, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach4(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, void 0, journal);
      });
      unsafeSet2(this.subscribers, empty6(), journal);
    }
  });
};
__name(TPubSubImpl, "TPubSubImpl");
var TPubSubSubscriptionImpl = class {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap19(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime6.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    let loop3 = true;
    let size18 = 0;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime6.journal);
      if (node === void 0) {
        loop3 = false;
      } else {
        const head10 = node.head;
        const tail2 = node.tail;
        if (head10 !== AbsentValue2) {
          size18 = size18 + 1;
          if (size18 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail2;
      }
    }
    return succeed17(size18);
  });
  isEmpty = /* @__PURE__ */ map28(this.size, (size18) => size18 === 0);
  isFull = /* @__PURE__ */ map28(this.size, (size18) => size18 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime6.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    let value6 = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime6.journal);
      if (node === void 0) {
        return retry5;
      }
      const head10 = node.head;
      const tail2 = node.tail;
      if (head10 !== AbsentValue2) {
        value6 = head10;
        loop3 = false;
      } else {
        currentSubscriberHead = tail2;
      }
    }
    return succeed17(value6);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime6.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    let value6 = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime6.journal);
      if (node === void 0) {
        value6 = none2();
        loop3 = false;
      } else {
        const head10 = node.head;
        const tail2 = node.tail;
        if (head10 !== AbsentValue2) {
          value6 = some3(head10);
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
    }
    return succeed17(value6);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== void 0) {
      unsafeSet2(this.subscriberHead, void 0, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === void 0) {
          loop3 = false;
        } else {
          const head10 = node.head;
          const tail2 = node.tail;
          if (head10 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size18 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail2, journal);
              unsafeSet2(this.pubsubSize, size18 - 1, journal);
            } else {
              const updatedNode = makeNode2(head10, subscribers - 1, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail2;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove5(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime6) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime6.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime6.fiberId);
    }
    let value6 = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime6.journal);
      if (node === void 0) {
        return retry5;
      }
      const head10 = node.head;
      const tail2 = node.tail;
      if (head10 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size18 = unsafeGet8(this.pubsubSize, runtime6.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail2);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime6.journal);
          unsafeSet2(this.publisherHead, tail2, runtime6.journal);
          unsafeSet2(this.pubsubSize, size18 - 1, runtime6.journal);
        } else {
          const updatedNode = makeNode2(head10, subscribers - 1, tail2);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime6.journal);
        }
        unsafeSet2(this.subscriberHead, tail2, runtime6.journal);
        value6 = head10;
        loop3 = false;
      } else {
        currentSubscriberHead = tail2;
      }
    }
    return succeed17(value6);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max8) {
    return withSTMRuntime((runtime6) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime6.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime6.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max8) {
        const node = unsafeGet8(currentSubscriberHead, runtime6.journal);
        if (node === void 0) {
          n = max8;
        } else {
          const head10 = node.head;
          const tail2 = node.tail;
          if (head10 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size18 = unsafeGet8(this.pubsubSize, runtime6.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime6.journal);
              unsafeSet2(this.publisherHead, tail2, runtime6.journal);
              unsafeSet2(this.pubsubSize, size18 - 1, runtime6.journal);
            } else {
              const updatedNode = makeNode2(head10, subscribers - 1, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime6.journal);
            }
            builder.push(head10);
            n = n + 1;
          }
          currentSubscriberHead = tail2;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime6.journal);
      return succeed17(builder);
    });
  }
};
__name(TPubSubSubscriptionImpl, "TPubSubSubscriptionImpl");
var makeSubscription2 = /* @__PURE__ */ __name((pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get17(publisherTail), flatMap19((currentPublisherTail) => pipe(all10([make56(currentPublisherTail), get17(subscriberCount), get17(subscribers)]), tap6(([_, currentSubscriberCount]) => pipe(subscriberCount, set9(currentSubscriberCount + 1))), tap6(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set9(pipe(currentSubscribers, add2(subscriberHead))))), map28(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers))))), "makeSubscription");
var subscribe3 = /* @__PURE__ */ __name((self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers), "subscribe");
var subscribeScoped = /* @__PURE__ */ __name((self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue)), "subscribeScoped");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/TQueue.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isShutdown6 = isShutdown4;
var take5 = take4;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/ringBuffer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var RingBuffer = class {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity7) {
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index2 = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index2] ?? void 0;
  }
  put(value6) {
    this.array[this.current] = value6;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};
__name(RingBuffer, "RingBuffer");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/debounceState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = /* @__PURE__ */ __name((fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
}), "previous");
var current = /* @__PURE__ */ __name((fiber) => ({
  _tag: OP_CURRENT,
  fiber
}), "current");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/emit.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make57 = /* @__PURE__ */ __name((emit2) => {
  const ops = {
    chunk(as14) {
      return this(succeed10(as14));
    },
    die(defect) {
      return this(die7(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth3(exit4, {
        onFailure: some3,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail10(none2()));
    },
    fail(e) {
      return this(fail10(some3(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth4(effect4, {
        onFailure: some3,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError4(some3)));
    },
    halt(cause3) {
      return this(failCause9(pipe(cause3, map16(some3))));
    },
    single(value6) {
      return this(succeed10(of2(value6)));
    }
  };
  return Object.assign(emit2, ops);
}, "make");
var makePush = /* @__PURE__ */ __name((queue, scheduler2) => {
  let finished = false;
  let buffer4 = [];
  let running4 = false;
  function array6(items) {
    if (finished)
      return false;
    if (items.length <= 5e4) {
      buffer4.push.apply(buffer4, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer4.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler2.scheduleTask(flush, 0);
    }
    return true;
  }
  __name(array6, "array");
  function flush() {
    running4 = false;
    if (buffer4.length > 0) {
      queue.unsafeOffer(buffer4);
      buffer4 = [];
    }
  }
  __name(flush, "flush");
  function done12(exit4) {
    if (finished)
      return;
    finished = true;
    if (exit4._tag === "Success") {
      buffer4.push(exit4.value);
    }
    flush();
    queue.unsafeOffer(exit4._tag === "Success" ? void_4 : exit4);
  }
  __name(done12, "done");
  return {
    single(value6) {
      if (finished)
        return false;
      buffer4.push(value6);
      if (!running4) {
        running4 = true;
        scheduler2.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array6,
    chunk(chunk4) {
      return array6(toReadonlyArray(chunk4));
    },
    done: done12,
    end() {
      if (finished)
        return;
      finished = true;
      flush();
      queue.unsafeOffer(void_4);
    },
    halt(cause3) {
      return done12(failCause3(cause3));
    },
    fail(error3) {
      return done12(fail3(error3));
    },
    die(defect) {
      return done12(die3(defect));
    },
    dieMessage(message) {
      return done12(die3(new Error(message)));
    }
  };
}, "makePush");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/handoff.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = /* @__PURE__ */ __name((notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
}), "handoffStateEmpty");
var handoffStateFull = /* @__PURE__ */ __name((value6, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value6,
  notifyProducer
}), "handoffStateFull");
var handoffStateMatch = /* @__PURE__ */ __name((onEmpty, onFull) => {
  return (self2) => {
    switch (self2._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self2.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self2.value, self2.notifyProducer);
      }
    }
  };
}, "handoffStateMatch");
var handoffVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var make58 = /* @__PURE__ */ __name(() => pipe(make41(), flatMap14((deferred) => make25(handoffStateEmpty(deferred))), map20((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
}))), "make");
var offer5 = /* @__PURE__ */ dual(2, (self2, value6) => {
  return flatMap14(make41(), (deferred) => flatten10(modify6(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight6(succeed8(notifyConsumer, void 0), _await3(deferred)), handoffStateFull(value6, deferred)], (_, notifyProducer) => [flatMap14(_await3(notifyProducer), () => pipe(self2, offer5(value6))), state])))));
});
var take6 = /* @__PURE__ */ __name((self2) => flatMap14(make41(), (deferred) => flatten10(modify6(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap14(_await3(notifyConsumer), () => take6(self2)), state], (value6, notifyProducer) => [as7(succeed8(notifyProducer, void 0), value6), handoffStateEmpty(deferred)]))))), "take");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/handoffSignal.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = /* @__PURE__ */ __name((elements) => ({
  _tag: OP_EMIT4,
  elements
}), "emit");
var halt = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_HALT,
  cause: cause3
}), "halt");
var end3 = /* @__PURE__ */ __name((reason) => ({
  _tag: OP_END,
  reason
}), "end");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/pull.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/take.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(TakeImpl, "TakeImpl");
var chunk3 = /* @__PURE__ */ __name((chunk4) => new TakeImpl(succeed3(chunk4)), "chunk");
var done11 = /* @__PURE__ */ __name((self2) => suspend4(() => self2.exit), "done");
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail3(/* @__PURE__ */ none2()));
var failCause12 = /* @__PURE__ */ __name((cause3) => new TakeImpl(failCause3(pipe(cause3, map16(some3)))), "failCause");
var fromPull = /* @__PURE__ */ __name((pull) => matchCause4(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause12
  }),
  onSuccess: chunk3
}), "fromPull");
var match20 = /* @__PURE__ */ dual(2, (self2, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match9(self2.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var of5 = /* @__PURE__ */ __name((value6) => new TakeImpl(succeed3(of2(value6))), "of");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = /* @__PURE__ */ __name(() => fail10(none2()), "end");
var failCause13 = /* @__PURE__ */ __name((cause3) => mapError4(failCause9(cause3), some3), "failCause");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/zipAllState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = /* @__PURE__ */ __name((rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
}), "PullLeft");
var PullRight = /* @__PURE__ */ __name((leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
}), "PullRight");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream/zipChunksState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = /* @__PURE__ */ __name((rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
}), "PullLeft");
var PullRight2 = /* @__PURE__ */ __name((leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
}), "PullRight");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var StreamImpl = class {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
__name(StreamImpl, "StreamImpl");
var isStream = /* @__PURE__ */ __name((u) => hasProperty(u, StreamTypeId2) || isEffect2(u), "isStream");
var DefaultChunkSize = 4096;
var accumulate = /* @__PURE__ */ __name((self2) => chunks(accumulateChunks(self2)), "accumulate");
var accumulateChunks = /* @__PURE__ */ __name((self2) => {
  const accumulator = /* @__PURE__ */ __name((s) => readWith({
    onInput: (input) => {
      const next = appendAll2(s, input);
      return flatMap17(write(next), () => accumulator(next));
    },
    onFailure: fail14,
    onDone: () => void_7
  }), "accumulator");
  return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty3())));
}, "accumulateChunks");
var acquireRelease3 = /* @__PURE__ */ __name((acquire, release) => scoped6(acquireRelease2(acquire, release)), "acquireRelease");
var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => filterMap8(aggregateWithinEither(self2, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => {
  const layer13 = all7([make58(), make25(ScheduleEnd), make25(empty3()), driver2(schedule4), make25(false), make25(false)]);
  return fromEffect8(layer13).pipe(flatMap20(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap17(fromEffect5(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty3()), flatMap14((leftovers) => {
      if (isNonEmpty(leftovers)) {
        return pipe(set5(consumed, true), zipRight6(succeed10(pipe(write(leftovers), flatMap17(() => handoffConsumer)))));
      }
      return pipe(take6(handoff), map20((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set5(consumed, true)), zipRight7(write(signal.elements)), zipRight7(fromEffect5(get12(endAfterEmit))), flatMap17((bool) => bool ? void_7 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause11(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get12(consumed), map20((bool) => bool ? fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight6(set5(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight6(set5(endAfterEmit, true)))), flatMap17(() => handoffConsumer))), unwrap2);
            }
            return pipe(set5(sinkEndReason, signal.reason), zipRight6(set5(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap2);
    const timeout5 = /* @__PURE__ */ __name((lastB) => scheduleDriver.next(lastB), "timeout");
    const scheduledAggregator = /* @__PURE__ */ __name((sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set5(consumed, false), zipRight6(set5(endAfterEmit, false)), zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run, forkIn2(scope5))));
      const handleSide = /* @__PURE__ */ __name((leftovers, b, c) => pipe(set5(sinkLeftovers, flatten3(leftovers)), zipRight6(map20(get12(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all7([get12(consumed), forkSink, pipe(timeout5(some3(b)), forkIn2(scope5))]), map20(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b)),
                onSome: (c2) => make4(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap17(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap2);
          }
          case OP_UPSTREAM_END: {
            return pipe(get12(consumed), map20((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_7), unwrap2);
          }
        }
      })), unwrap2), "handleSide");
      return unwrap2(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt5(scheduleFiber), zipRight6(pipe(suspend4(() => sinkExit), map20(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map20(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map20(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map20(([leftovers, b]) => handleSide(leftovers, b, some3(c))))))
        })
      }));
    }, "scheduledAggregator");
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run, forkIn2(scope5), zipRight6(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run, forkIn2(scope5), flatMap14((sinkFiber) => timeout5(none2()).pipe(forkIn2(scope5), map20((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as11 = /* @__PURE__ */ dual(2, (self2, value6) => map29(self2, () => value6));
var queueFromBufferOptions = /* @__PURE__ */ __name((bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
}, "queueFromBufferOptions");
var _async = /* @__PURE__ */ __name((register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap14((output) => runtime4().pipe(flatMap14((runtime6) => sync6(() => {
  const runPromiseExit3 = runPromiseExit2(runtime6);
  const canceler = register(make57((resume2) => fromPull(resume2).pipe(flatMap14((take10) => offer3(output, take10)), asVoid5, runPromiseExit3).then((exit4) => {
    if (isFailure3(exit4)) {
      if (!isInterrupted3(exit4.cause)) {
        throw squash(exit4.cause);
      }
    }
  })));
  return canceler;
})), map20((value6) => {
  const loop3 = take3(output).pipe(flatMap14((take10) => done11(take10)), match14({
    onFailure: (maybeError) => fromEffect5(shutdown4(output)).pipe(zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: (error3) => fail14(error3)
    }))),
    onSuccess: (chunk4) => write(chunk4).pipe(flatMap17(() => loop3))
  }), unwrap2);
  return fromChannel2(loop3).pipe(ensuring6(value6 ?? _void));
}))), unwrapScoped4), "_async");
var asyncEffect3 = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap14((output) => pipe(runtime4(), flatMap14((runtime6) => pipe(register(make57((k) => pipe(fromPull(k), flatMap14((take10) => offer3(output, take10)), asVoid5, runPromiseExit2(runtime6)).then((exit4) => {
  if (isFailure3(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), map20(() => {
  const loop3 = pipe(take3(output), flatMap14(done11), match14({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown4(output)), zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: fail14
    }))),
    onSuccess: (chunk4) => pipe(write(chunk4), flatMap17(() => loop3))
  }), unwrap2);
  return loop3;
}))))), unwrapScoped3, fromChannel2), "asyncEffect");
var queueFromBufferOptionsPush = /* @__PURE__ */ __name((options4) => {
  if (options4?.bufferSize === "unbounded" || options4?.bufferSize === void 0 && options4?.strategy === void 0) {
    return unbounded5();
  }
  switch (options4?.strategy) {
    case "sliding":
      return sliding4(options4.bufferSize ?? 16);
    default:
      return dropping4(options4?.bufferSize ?? 16);
  }
}, "queueFromBufferOptionsPush");
var asyncPush = /* @__PURE__ */ __name((register, options4) => acquireRelease2(queueFromBufferOptionsPush(options4), shutdown4).pipe(tap4((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map20((queue) => {
  const loop3 = flatMap17(take3(queue), (item) => isExit(item) ? isSuccess2(item) ? void_7 : failCause11(item.cause) : zipRight7(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped3, fromChannel2), "asyncPush");
var asyncScoped = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap14((output) => pipe(runtime4(), flatMap14((runtime6) => pipe(register(make57((k) => pipe(fromPull(k), flatMap14((take10) => offer3(output, take10)), asVoid5, runPromiseExit2(runtime6)).then((exit4) => {
  if (isFailure3(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight6(make25(false)), flatMap14((ref) => pipe(get12(ref), map20((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap14(done11), onError2(() => pipe(set5(ref, true), zipRight6(shutdown4(output)))))))))))), scoped6, flatMap20(repeatEffectChunkOption)), "asyncScoped");
var branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend12(() => {
  const buffering = /* @__PURE__ */ __name((acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    },
    onFailure: fail14,
    onDone: () => running4(acc, empty3())
  }), "buffering");
  const running4 = /* @__PURE__ */ __name((prefix3, leftover2) => pipeTo(zipRight7(write(leftover2), identityChannel()), toChannel2(f(prefix3))), "running");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty3()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map20((tuple4) => tuple4.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map20(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self2, options4) => map20(make52({
  acquire: broadcastDynamic(self2, options4),
  idleTimeToLive: options4.idleTimeToLive
}), (rcRef) => unwrapScoped4(get16(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap14(pubsubFromOptions(maximumLag), (pubsub) => pipe(all7(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap4(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map20(toPubSub2(self2, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.capacity === "unbounded") {
    return bufferUnbounded(self2);
  } else if (options4.strategy === "dropping") {
    return bufferDropping(self2, options4.capacity);
  } else if (options4.strategy === "sliding") {
    return bufferSliding(self2, options4.capacity);
  }
  const queue = toQueueOfElements(self2, options4);
  return new StreamImpl(unwrapScoped3(map20(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap17(match9({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_7,
        onSome: failCause11
      })),
      onSuccess: (value6) => flatMap17(write(of2(value6)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.strategy === "dropping") {
    return bufferChunksDropping(self2, options4.capacity);
  } else if (options4.strategy === "sliding") {
    return bufferChunksSliding(self2, options4.capacity);
  }
  const queue = toQueue2(self2, options4);
  return new StreamImpl(unwrapScoped3(map20(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap17(match20({
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value6) => pipe(write(value6), flatMap17(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
});
var bufferUnbounded = /* @__PURE__ */ __name((self2) => {
  const queue = toQueue2(self2, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map20(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap17(match20({
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value6) => flatMap17(write(value6), () => process2)
    })));
    return process2;
  })));
}, "bufferUnbounded");
var bufferSignal = /* @__PURE__ */ __name((scoped9, bufferChannel) => {
  const producer = /* @__PURE__ */ __name((queue, ref) => {
    const terminate = /* @__PURE__ */ __name((take10) => pipe(get12(ref), tap4(_await3), zipRight6(make41()), flatMap14((deferred) => pipe(offer3(queue, [take10, deferred]), zipRight6(set5(ref, deferred)), zipRight6(_await3(deferred)))), asVoid5, fromEffect5), "terminate");
    return readWithCause({
      onInput: (input) => pipe(make41(), flatMap14((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap14((added) => pipe(set5(ref, deferred), when2(() => added))))), asVoid5, fromEffect5, flatMap17(() => producer(queue, ref))),
      onFailure: (error3) => terminate(failCause12(error3)),
      onDone: () => terminate(end4)
    });
  }, "producer");
  const consumer = /* @__PURE__ */ __name((queue) => {
    const process2 = pipe(fromEffect5(take3(queue)), flatMap17(([take10, deferred]) => zipRight7(fromEffect5(succeed8(deferred, void 0)), match20(take10, {
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value6) => pipe(write(value6), flatMap17(() => process2))
    }))));
    return process2;
  }, "consumer");
  return unwrapScoped3(pipe(scoped9, flatMap14((queue) => pipe(make41(), tap4((start3) => succeed8(start3, void 0)), flatMap14((start3) => pipe(make25(start3), flatMap14((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as7(consumer(queue))))))));
}, "bufferSignal");
var catchAll7 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause14
})));
var catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f(cause3))))));
var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error3) => pipe(pf(error3), getOrElse(() => fail18(error3))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause14(cause3))))));
var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll7(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail18(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
  const keys6 = Object.keys(cases);
  if ("_tag" in e && keys6.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail18(e);
}));
var changes = /* @__PURE__ */ __name((self2) => pipe(self2, changesWith((x, y) => equals(y)(x))), "changes");
var changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce2(input, [last5, empty3()], ([option7, outputs], output) => {
        if (isSome2(option7) && f(option7.value, output)) {
          return [some3(output), outputs];
        }
        return [some3(output), pipe(outputs, append2(output))];
      });
      return flatMap17(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause11,
    onDone: () => void_7
  }), "writer");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: (input) => pipe(input, reduce12([last5, empty3()], ([option7, outputs], output) => {
      if (isSome2(option7)) {
        return pipe(f(option7.value, output), map20((bool) => bool ? [some3(output), outputs] : [some3(output), pipe(outputs, append2(output))]));
      }
      return succeed10([some3(output), pipe(outputs, append2(output))]);
    }), fromEffect5, flatMap17(([newLast, newChunk]) => pipe(write(newChunk), flatMap17(() => writer(newLast))))),
    onFailure: failCause11,
    onDone: () => void_7
  }), "writer");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var chunks = /* @__PURE__ */ __name((self2) => pipe(self2, mapChunks(of2)), "chunks");
var chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
var unsome = /* @__PURE__ */ __name((effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail10(o.value)), "unsome");
var combine9 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect5(take6(latch)).pipe(zipRight7(readWithCause({
      onInput: (input) => flatMap17(fromEffect5(offer5(handoff, succeed3(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect5(offer5(handoff, failCause3(pipe(cause3, map16(some3))))),
      onDone: () => flatMap17(fromEffect5(offer5(handoff, fail3(none2()))), () => producer(handoff, latch))
    })));
  }
  __name(producer, "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make58(), make58(), make58(), make58()]).pipe(tap4(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap4(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map20(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight6(take6(left3).pipe(flatMap14(identity))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight6(take6(right3).pipe(flatMap14(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap14(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  const producer = /* @__PURE__ */ __name((handoff, latch) => zipRight7(fromEffect5(take6(latch)), readWithCause({
    onInput: (input) => flatMap17(fromEffect5(pipe(handoff, offer5(chunk3(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end4))
  })), "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make58(), make58(), make58(), make58()]).pipe(tap4(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap4(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map20(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight6(take6(left3).pipe(flatMap14(done11))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight6(take6(right3).pipe(flatMap14(done11))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap14(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight7(toChannel2(that)))));
var concatAll2 = /* @__PURE__ */ __name((streams) => suspend12(() => pipe(streams, reduce2(empty33, (x, y) => concat2(y)(x)))), "concatAll");
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap20(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap20((a) => pipe(right3, map29((b) => f(a, b))))));
var debounce = /* @__PURE__ */ dual(2, (self2, duration3) => unwrapScopedWith3((scope5) => gen3(function* () {
  const handoff = yield* make58();
  function enqueue(last5) {
    return sleep2(duration3).pipe(as7(last5), forkIn2(scope5), map20((fiber) => consumer(previous(fiber))));
  }
  __name(enqueue, "enqueue");
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect5(offer5(handoff, emit(of2(elem)))).pipe(flatMap17(() => producer))
    }),
    onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap2(take6(handoff).pipe(map20((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap2(take6(handoff).pipe(forkIn2(scope5), flatMap14((handoffFiber) => raceWith2(join4(state.fiber), join4(handoffFiber), {
          onSelfDone: (leftExit, current2) => match9(leftExit, {
            onFailure: (cause3) => interrupt5(current2).pipe(as7(failCause11(cause3))),
            onSuccess: (chunk4) => interrupt5(current2).pipe(zipRight6(succeed10(write(chunk4).pipe(flatMap17(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match9(rightExit, {
            onFailure: (cause3) => interrupt5(previous2).pipe(as7(failCause11(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt5(previous2).pipe(zipRight6(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt5(previous2).pipe(as7(failCause11(signal.cause)));
                }
                case OP_END: {
                  return join4(previous2).pipe(map20((chunk4) => write(chunk4).pipe(zipRight7(void_7))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap2(join4(state.fiber).pipe(map20((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
    }
  }
  __name(consumer, "consumer");
  return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die11 = /* @__PURE__ */ __name((defect) => fromEffect8(die7(defect)), "die");
var dieSync7 = /* @__PURE__ */ __name((evaluate3) => fromEffect8(dieSync4(evaluate3)), "dieSync");
var dieMessage4 = /* @__PURE__ */ __name((message) => fromEffect8(dieMessage2(message)), "dieMessage");
var distributedWith = /* @__PURE__ */ dual(2, (self2, options4) => pipe(make41(), flatMap14((deferred) => pipe(self2, distributedWithDynamic({
  maximumLag: options4.maximumLag,
  decide: (a) => flatMap14(_await3(deferred), (f) => f(a))
}), flatMap14((next) => pipe(all7(map5(range(0, options4.size - 1), (id3) => map20(next, ([key, queue]) => [[key, id3], queue]))), map20(unsafeFromArray), flatMap14((entries3) => {
  const [mappings, queues] = reduceRight2(entries3, [/* @__PURE__ */ new Map(), empty3()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed8(deferred, (a) => map20(options4.decide(a), (f) => (key) => f(mappings.get(key)))), as7(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = /* @__PURE__ */ __name(() => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
}, "newDistributedWithDynamicId");
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options4) => distributedWithDynamicCallback(self2, options4.maximumLag, options4.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done12) => pipe(acquireRelease2(make25(/* @__PURE__ */ new Map()), (ref, _) => pipe(get12(ref), flatMap14((queues) => pipe(queues.values(), forEach10(shutdown4))))), flatMap14((queuesRef) => gen3(function* () {
  const offer6 = /* @__PURE__ */ __name((a) => pipe(decide(a), flatMap14((shouldProcess) => pipe(get12(queuesRef), flatMap14((queues) => pipe(queues.entries(), reduce12(empty3(), (acc, [id3, queue]) => {
    if (shouldProcess(id3)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted3(cause3) ? succeed10(pipe(acc, prepend2(id3))) : failCause9(cause3)
        ),
        onSuccess: () => succeed10(acc)
      }));
    }
    return succeed10(acc);
  }), flatMap14((ids3) => {
    if (isNonEmpty(ids3)) {
      return update3(queuesRef, (map33) => {
        for (const id3 of ids3) {
          map33.delete(id3);
        }
        return map33;
      });
    }
    return _void;
  }))))), asVoid5), "offer");
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make25(pipe(bounded5(maximumLag), flatMap14((queue) => {
    const id3 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map33) => map33.set(id3, queue)), as7([id3, queue]));
  })));
  const finalize = /* @__PURE__ */ __name((endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set5(newQueue, pipe(
      // All newly created queues should end immediately
      bounded5(1),
      tap4((queue) => offer3(queue, endTake)),
      flatMap14((queue) => {
        const id3 = newDistributedWithDynamicId();
        return pipe(update3(queuesRef, (map33) => map33.set(id3, queue)), as7(make3(id3, queue)));
      })
    )), zipRight6(pipe(get12(queuesRef), flatMap14((map33) => pipe(fromIterable3(map33.values()), forEach10((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some3(_void) : none2()))))))), zipRight6(done12(endTake)), asVoid5))
  ), "finalize");
  yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause3(pipe(cause3, map16(some3)))),
    onSuccess: () => finalize(fail3(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten10(get12(newQueue)));
}))));
var drain3 = /* @__PURE__ */ __name((self2) => new StreamImpl(drain(toChannel2(self2))), "drain");
var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect8(make41()).pipe(flatMap20((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause7(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
  const loop3 = /* @__PURE__ */ __name((r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop2(r));
      const leftover2 = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover2 > 0;
      if (more) {
        return loop3(leftover2);
      }
      return pipe(write(dropped), zipRight7(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => void_7
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n))));
});
var dropRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend12(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap3((elem) => {
          const head10 = queue.head();
          queue.put(elem);
          return head10;
        }));
        return pipe(write(outputs), flatMap17(() => reader));
      },
      onFailure: fail14,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile4(self2, (a) => !predicate(a)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map20(unsafeFromArray), map20((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend8(() => loop3);
      }
      return pipe(write(leftover2), zipRight7(identityChannel()));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var dropWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const output = dropWhile(input, predicate);
      if (isEmpty(output)) {
        return suspend8(() => loop3);
      }
      return zipRight7(write(output), identityChannel());
    },
    onFailure: fail14,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropWhile3(input, predicate), map20(unsafeFromArray), map20((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend8(() => loop3);
      }
      return zipRight7(write(leftover2), identityChannel());
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_7
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var either5 = /* @__PURE__ */ __name((self2) => pipe(self2, map29(right2), catchAll7((error3) => make59(left2(error3)))), "either");
var empty33 = /* @__PURE__ */ new StreamImpl(void_7);
var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(pipe(toChannel2(self2), ensuring3(finalizer3))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer3)));
var context6 = /* @__PURE__ */ __name(() => fromEffect8(context3()), "context");
var contextWith3 = /* @__PURE__ */ __name((f) => pipe(context6(), map29(f)), "contextWith");
var contextWithEffect3 = /* @__PURE__ */ __name((f) => pipe(context6(), mapEffectSequential(f)), "contextWithEffect");
var contextWithStream = /* @__PURE__ */ __name((f) => pipe(context6(), flatMap20(f)), "contextWithStream");
var execute = /* @__PURE__ */ __name((effect4) => drain3(fromEffect8(effect4)), "execute");
var fail18 = /* @__PURE__ */ __name((error3) => fromEffectOption(fail10(some3(error3))), "fail");
var failSync8 = /* @__PURE__ */ __name((evaluate3) => fromEffectOption(failSync4(() => some3(evaluate3()))), "failSync");
var failCause14 = /* @__PURE__ */ __name((cause3) => fromEffect8(failCause9(cause3)), "failCause");
var failCauseSync7 = /* @__PURE__ */ __name((evaluate3) => fromEffect8(failCauseSync4(evaluate3)), "failCauseSync");
var filter13 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter3(predicate)));
var filterEffect2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = /* @__PURE__ */ __name((iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return pipe(f(next.value), map20((bool) => bool ? pipe(write(of2(next.value)), flatMap17(() => loop3(iterator))) : loop3(iterator)), unwrap2);
    }
  }, "loop");
  return new StreamImpl(suspend8(() => pipe(toChannel2(self2), pipeTo(loop3(empty3()[Symbol.iterator]())))));
});
var filterMap8 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap3(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop3 = /* @__PURE__ */ __name((iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return pipe(pf(next.value), match2({
        onNone: () => sync6(() => loop3(iterator)),
        onSome: map20((a2) => flatMap17(write(of2(a2)), () => loop3(iterator)))
      }), unwrap2);
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty3()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
  const loop3 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap17(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail14,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop3 = /* @__PURE__ */ __name((iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return unwrap2(match2(pf(next.value), {
        onNone: () => succeed10(void_7),
        onSome: map20((a2) => flatMap17(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty3()[Symbol.iterator]()))));
}));
var finalizer = /* @__PURE__ */ __name((finalizer3) => acquireRelease3(_void, () => finalizer3), "finalizer");
var find3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => match2(findFirst3(input, predicate), {
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail14,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(findFirst8(input, predicate), map20(match2({
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    })), unwrap2),
    onFailure: fail14,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var flatMap20 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options4) => {
  const bufferSize = options4?.bufferSize ?? 16;
  if (options4?.switch) {
    return matchConcurrency(options4?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
  }
  return matchConcurrency(options4?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as14) => pipe(as14, map5((a) => toChannel2(f(a))), reduce2(void_7, (left3, right3) => pipe(left3, zipRight7(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options4))));
});
var matchConcurrency = /* @__PURE__ */ __name((concurrency, sequential5, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
}, "matchConcurrency");
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten15 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => flatMap20(self2, identity, options4));
var flattenChunks = /* @__PURE__ */ __name((self2) => {
  const flatten17 = readWithCause({
    onInput: (chunks3) => flatMap17(writeChunk(chunks3), () => flatten17),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten17)));
}, "flattenChunks");
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => options4?.unordered ? flatMap20(self2, (a) => fromEffect8(a), {
  concurrency: options4.concurrency
}) : matchConcurrency(options4?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = /* @__PURE__ */ __name((self2) => {
  const processChunk = /* @__PURE__ */ __name((chunk4, cont) => {
    const [toEmit, rest] = pipe(chunk4, splitWhere((exit4) => !isSuccess2(exit4)));
    const next = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match9({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_7,
          onSome: failCause11
        }),
        onSuccess: () => void_7
      })
    }));
    return pipe(write(pipe(toEmit, filterMap3((exit4) => isSuccess2(exit4) ? some3(exit4.value) : none2()))), flatMap17(() => next));
  }, "processChunk");
  const process2 = readWithCause({
    onInput: (chunk4) => processChunk(chunk4, process2),
    onFailure: (cause3) => failCause11(cause3),
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}, "flattenExitOption");
var flattenIterables = /* @__PURE__ */ __name((self2) => pipe(self2, map29(fromIterable3), flattenChunks), "flattenIterables");
var flattenTake = /* @__PURE__ */ __name((self2) => flattenChunks(flattenExitOption(pipe(self2, map29((take10) => take10.exit)))), "flattenTake");
var forever5 = /* @__PURE__ */ __name((self2) => new StreamImpl(repeated(toChannel2(self2))), "forever");
var fromAsyncIterable = /* @__PURE__ */ __name((iterable, onError5) => pipe(acquireRelease2(sync6(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map20((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some3(onError5(reason))
}), flatMap14((result) => result.done ? fail10(none2()) : succeed10(result.value))))), unwrapScoped4), "fromAsyncIterable");
var fromChannel2 = /* @__PURE__ */ __name((channel) => new StreamImpl(channel), "fromChannel");
var toChannel2 = /* @__PURE__ */ __name((stream6) => {
  if ("channel" in stream6) {
    return stream6.channel;
  } else if (isEffect2(stream6)) {
    return toChannel2(fromEffect8(stream6));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
}, "toChannel");
var fromChunk = /* @__PURE__ */ __name((chunk4) => new StreamImpl(isEmpty(chunk4) ? void_7 : write(chunk4)), "fromChunk");
var fromChunkPubSub = /* @__PURE__ */ __name((pubsub, options4) => {
  if (options4?.scoped) {
    const effect4 = map20(subscribe2(pubsub), fromChunkQueue);
    return options4.shutdown ? map20(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream6 = flatMap20(scoped6(subscribe2(pubsub)), fromChunkQueue);
  return options4?.shutdown ? ensuring6(stream6, shutdown3(pubsub)) : stream6;
}, "fromChunkPubSub");
var fromChunkQueue = /* @__PURE__ */ __name((queue, options4) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap14((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options4?.shutdown ? ensuring6(shutdown4(queue)) : identity), "fromChunkQueue");
var fromChunks = /* @__PURE__ */ __name((...chunks3) => pipe(fromIterable14(chunks3), flatMap20(fromChunk)), "fromChunks");
var fromEffect8 = /* @__PURE__ */ __name((effect4) => pipe(effect4, mapError4(some3), fromEffectOption), "fromEffect");
var fromEffectOption = /* @__PURE__ */ __name((effect4) => new StreamImpl(unwrap2(match14(effect4, {
  onFailure: match2({
    onNone: () => void_7,
    onSome: fail14
  }),
  onSuccess: (a) => write(of2(a))
}))), "fromEffectOption");
var fromPubSub = /* @__PURE__ */ __name((pubsub, options4) => {
  const maxChunkSize = options4?.maxChunkSize ?? DefaultChunkSize;
  if (options4?.scoped) {
    const effect4 = map20(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options4.shutdown ? map20(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream6 = flatMap20(scoped6(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options4?.shutdown ? ensuring6(stream6, shutdown3(pubsub)) : stream6;
}, "fromPubSub");
var fromTPubSub = /* @__PURE__ */ __name((pubsub) => {
  return unwrapScoped4(map20(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
}, "fromTPubSub");
var fromIterable14 = /* @__PURE__ */ __name((iterable) => suspend12(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]())), "fromIterable");
var fromIterableEffect = /* @__PURE__ */ __name((effect4) => pipe(effect4, map20(fromIterable14), unwrap3), "fromIterableEffect");
var fromIteratorSucceed = /* @__PURE__ */ __name((iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync6(() => {
    let builder = [];
    const loop3 = /* @__PURE__ */ __name((iterator2) => pipe(sync6(() => {
      let next = iterator2.next();
      if (maxChunkSize === 1) {
        if (next.done) {
          return void_7;
        }
        return pipe(write(of2(next.value)), flatMap17(() => loop3(iterator2)));
      }
      builder = [];
      let count4 = 0;
      while (next.done === false) {
        builder.push(next.value);
        count4 = count4 + 1;
        if (count4 >= maxChunkSize) {
          break;
        }
        next = iterator2.next();
      }
      if (count4 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap17(() => loop3(iterator2)));
      }
      return void_7;
    }), unwrap2), "loop");
    return new StreamImpl(loop3(iterator));
  }), unwrap3);
}, "fromIteratorSucceed");
var fromPull2 = /* @__PURE__ */ __name((effect4) => pipe(effect4, map20(repeatEffectChunkOption), unwrapScoped4), "fromPull");
var fromQueue2 = /* @__PURE__ */ __name((queue, options4) => pipe(takeBetween2(queue, 1, options4?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap14((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options4?.shutdown ? ensuring6(shutdown4(queue)) : identity), "fromQueue");
var fromTQueue = /* @__PURE__ */ __name((queue) => pipe(take5(queue), map20(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap14((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption), "fromTQueue");
var fromSchedule = /* @__PURE__ */ __name((schedule4) => pipe(driver2(schedule4), map20((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap3), "fromSchedule");
var fromReadableStream = /* @__PURE__ */ __name((...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map20(acquireRelease2(sync6(() => evaluate3().getReader()), (reader) => releaseLockOnEnd ? sync6(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap14(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some3(onError5(reason))
  }), ({
    done: done12,
    value: value6
  }) => done12 ? fail10(none2()) : succeed10(value6)))));
}, "fromReadableStream");
var fromReadableStreamByob = /* @__PURE__ */ __name((...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map20(acquireRelease2(sync6(() => evaluate3().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync6(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError5, allocSize)), (error3) => error3 === EOF ? empty33 : fail18(error3))));
}, "fromReadableStreamByob");
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = /* @__PURE__ */ __name((reader, onError5, size18) => {
  const buffer4 = new ArrayBuffer(size18);
  return paginateEffect(0, (offset) => flatMap14(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer4, offset, buffer4.byteLength - offset)),
    catch: (reason) => onError5(reason)
  }), ({
    done: done12,
    value: value6
  }) => {
    if (done12) {
      return fail10(EOF);
    }
    const newOffset = offset + value6.byteLength;
    return succeed10([value6, newOffset >= buffer4.byteLength ? none2() : some3(newOffset)]);
  }));
}, "readChunkStreamByobReader");
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const groupAdjacentByChunk = /* @__PURE__ */ __name((state, chunk4) => {
    if (isEmpty(chunk4)) {
      return [state, empty3()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty3();
    switch (state._tag) {
      case "Some": {
        const tuple4 = state.value;
        key = tuple4[0];
        let loop3 = true;
        while (loop3 && until < chunk4.length) {
          const input = unsafeGet2(chunk4, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple4[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk4).slice(from, until));
            const group2 = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group2]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple4[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet2(chunk4, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk4.length) {
      const input = unsafeGet2(chunk4, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk4).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk4).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some3([key, nonEmptyChunk]), output];
  }, "groupAdjacentByChunk");
  const groupAdjacent = /* @__PURE__ */ __name((state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap17(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause11(cause3),
      onSome: (output) => flatMap17(write(of2(output)), () => failCause11(cause3))
    }),
    onDone: (done12) => match2(state, {
      onNone: () => succeedNow(done12),
      onSome: (output) => flatMap17(write(of2(output)), () => succeedNow(done12))
    })
  }), "groupAdjacent");
  return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration3) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration3)));
var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
  const writer = /* @__PURE__ */ __name((fiber) => pipe(poll2(fiber), map20(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap17(write(input), () => writer(fiber)),
      onFailure: fail14,
      onDone: () => void_7
    }),
    onSome: match9({
      onFailure: failCause11,
      onSuccess: () => void_7
    })
  })), unwrap2), "writer");
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map20((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self2, duration3) => pipe(self2, haltWhen(sleep2(duration3))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
  const writer = pipe(poll3(deferred), map20(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap17(() => writer)),
      onFailure: fail14,
      onDone: () => void_7
    }),
    onSome: (effect4) => unwrap2(match14(effect4, {
      onFailure: fail14,
      onSuccess: () => void_7
    }))
  })), unwrap2);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var identityStream = /* @__PURE__ */ __name(() => new StreamImpl(identityChannel()), "identityStream");
var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make59(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
  const producer = /* @__PURE__ */ __name((handoff) => readWithCause({
    onInput: (value6) => flatMap17(fromEffect5(offer5(handoff, of5(value6))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end4))
  }), "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make58(), zip8(make58()), tap4(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap4(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map20(([left3, right3]) => {
    const process2 = /* @__PURE__ */ __name((leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect5(take6(left3)), flatMap17(match20({
            onEnd: () => rightDone ? void_7 : process2(true, rightDone),
            onFailure: failCause11,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap17(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect5(take6(right3)), flatMap17(match20({
            onEnd: () => leftDone ? void_7 : process2(leftDone, true),
            onFailure: failCause11,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap17(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause11,
      onDone: () => void_7
    }), "process");
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse = /* @__PURE__ */ dual(2, (self2, element2) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend8(() => {
  const writer = /* @__PURE__ */ __name((isFirst) => readWithCause({
    onInput: (chunk4) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk4) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element2);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap17(() => writer(flagResult)));
    },
    onFailure: failCause11,
    onDone: () => void_7
  }), "writer");
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
  end: end6,
  middle,
  start: start3
}) => pipe(make59(start3), concat2(pipe(self2, intersperse(middle))), concat2(make59(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration3) => pipe(self2, interruptWhen2(sleep2(duration3))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
var iterate3 = /* @__PURE__ */ __name((value6, next) => unfold3(value6, (a) => some3([a, next(a)])), "iterate");
var make59 = /* @__PURE__ */ __name((...as14) => fromIterable14(as14), "make");
var map29 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map5(f)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const accumulator = /* @__PURE__ */ __name((s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk4] = mapAccum2(input, s2, f);
      return flatMap17(write(chunk4), () => accumulator(nextS));
    },
    onFailure: fail14,
    onDone: () => void_7
  }), "accumulator");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend12(() => {
  const accumulator = /* @__PURE__ */ __name((s2) => readWith({
    onInput: (input) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = /* @__PURE__ */ __name((output) => sync6(() => {
        outputs.push(output);
      }), "emit");
      return pipe(input, reduce12(s2, (s3, a) => pipe(f(s3, a), flatMap14(([s4, a2]) => pipe(emit2(a2), as7(s4))))), match14({
        onFailure: (error3) => {
          if (outputs.length !== 0) {
            return zipRight7(write(unsafeFromArray(outputs)), fail14(error3));
          }
          return fail14(error3);
        },
        onSuccess: (s3) => flatMap17(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_7
  }), "accumulator");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
}));
var mapBoth7 = /* @__PURE__ */ dual(2, (self2, options4) => pipe(self2, mapError8(options4.onFailure), map29(options4.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
var mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable3(f(a)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap3(f))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map20(fromIterable3))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = /* @__PURE__ */ __name((iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      const value6 = next.value;
      return unwrap2(map20(f(value6), (a2) => flatMap17(write(of2(a2)), () => loop3(iterator))));
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend8(() => loop3(empty3()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError8 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError7(f))));
var mapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause4(f))));
var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options4) => mergeWith3(self2, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options4?.haltStrategy
}));
var mergeAll7 = /* @__PURE__ */ dual((args2) => Symbol.iterator in args2[0], (streams, options4) => flatten15(fromIterable14(streams), options4));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options4) => {
  const keys6 = Object.keys(streams);
  const values6 = keys6.map((key) => streams[key].pipe(map29((value6) => ({
    _tag: key,
    value: value6
  }))));
  return mergeAll7(values6, options4);
});
var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options4) => {
  const strategy = options4.haltStrategy ? fromInput2(options4.haltStrategy) : Both2;
  const handler = /* @__PURE__ */ __name((terminate) => (exit4) => terminate || !isSuccess2(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5)), "handler");
  return new StreamImpl(mergeWith2(toChannel2(map29(self2, options4.onSelf)), {
    other: toChannel2(map29(other, options4.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = /* @__PURE__ */ __name((self2) => run3(self2, mkString), "mkString");
var never5 = /* @__PURE__ */ fromEffect8(never4);
var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect8(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect8(pipe(cleanup(cause3), zipRight6(failCause9(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit4) => isSuccess2(exit4) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap3(as7(effect4, self2)));
var orDie5 = /* @__PURE__ */ __name((self2) => pipe(self2, orDieWith4(identity)), "orDie");
var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
var orElse11 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse10(() => toChannel2(that())))));
var orElseEither5 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map29(left2), orElse11(() => pipe(that(), map29(right2)))));
var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error3) => pipe(self2, orElse11(() => failSync8(error3))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element2) => pipe(self2, orElseIfEmptyChunk(() => of2(element2()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk4) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk4())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream6) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend8(() => writer);
      }
      return pipe(write(input), zipRight7(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => suspend8(() => toChannel2(stream6()))
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value6) => pipe(self2, orElse11(() => sync12(value6))));
var paginate = /* @__PURE__ */ __name((s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
}), "paginate");
var paginateChunk = /* @__PURE__ */ __name((s, f) => {
  const loop3 = /* @__PURE__ */ __name((s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight7(write(page[0]), void_7),
      onSome: (s3) => flatMap17(write(page[0]), () => loop3(s3))
    });
  }, "loop");
  return new StreamImpl(suspend8(() => loop3(s)));
}, "paginateChunk");
var paginateChunkEffect = /* @__PURE__ */ __name((s, f) => {
  const loop3 = /* @__PURE__ */ __name((s2) => unwrap2(map20(f(s2), ([chunk4, option7]) => match2(option7, {
    onNone: () => zipRight7(write(chunk4), void_7),
    onSome: (s3) => flatMap17(write(chunk4), () => loop3(s3))
  }))), "loop");
  return new StreamImpl(suspend8(() => loop3(s)));
}, "paginateChunkEffect");
var paginateEffect = /* @__PURE__ */ __name((s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map20(([a, s3]) => [of2(a), s3]))), "paginateEffect");
var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make41(), flatMap14((deferred) => pipe(make58(), map20((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error3) => zipRight8(fromEffect7(fail8(deferred, error3)), fail15(error3)),
      onSuccess: ([z, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap17(fromEffect5(offer5(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause3) => zipRight7(fromEffect5(offer5(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause11(cause3)),
          onDone: (_) => zipRight7(fromEffect5(offer5(handoff, {
            _tag: OP_END2
          })), void_7)
        });
        return fromChannel(pipe(fromEffect5(succeed8(deferred, z)), zipRight7(fromEffect5(pipe(handoff, offer5({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight7(loop3)));
      }
    });
    const producer = pipe(take6(handoff), map20((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap17(() => producer));
        }
        case OP_HALT2: {
          return failCause11(signal.cause);
        }
        case OP_END2: {
          return void_7;
        }
      }
    }), unwrap2);
    return pipe(self2, tapErrorCause5((cause3) => failCause7(deferred, cause3)), run3(consumer), forkScoped2, zipRight6(_await3(deferred)), map20((z) => [z, new StreamImpl(producer)]));
  }))), flatten10);
});
var partition7 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options4) => partitionEither(self2, (a) => succeed10(predicate(a) ? right2(a) : left2(a)), options4));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options4) => pipe(mapEffectSequential(self2, predicate), distributedWith({
  size: 2,
  maximumLag: options4?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed10((n) => n === 0),
    onRight: () => succeed10((n) => n === 1)
  })
}), flatMap14(([queue1, queue2]) => succeed10([filterMap8(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some3,
  onRight: none2
})), filterMap8(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some3
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel) => new StreamImpl(pipeTo(toChannel2(self2), channel)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self2, values6) => new StreamImpl(zipRight7(write(values6), toChannel2(self2))));
var provideContext5 = /* @__PURE__ */ dual(2, (self2, context11) => new StreamImpl(pipe(toChannel2(self2), provideContext3(context11))));
var provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context11) => mapInputContext5(self2, merge3(context11)));
var provideLayer = /* @__PURE__ */ dual(2, (self2, layer13) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer13, scope5).pipe(map20((env) => pipe(toChannel2(self2), provideContext3(env)))))));
var provideService5 = /* @__PURE__ */ dual(3, (self2, tag8, resource) => provideServiceEffect3(self2, tag8, succeed10(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag8, effect4) => provideServiceStream(self2, tag8, fromEffect8(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag8, stream6) => contextWithStream((env) => flatMap20(stream6, (service3) => pipe(self2, provideContext5(add4(env, tag8, service3))))));
var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env) => pipe(self2, provideContext5(f(env)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer13) => (
  // @ts-expect-error
  // @effect-diagnostics-next-line missingEffectContext:off
  pipe(self2, provideLayer(pipe(context4(), merge8(layer13))))
));
var range2 = /* @__PURE__ */ __name((min5, max8, chunkSize = DefaultChunkSize) => suspend12(() => {
  if (min5 > max8) {
    return empty33;
  }
  const go3 = /* @__PURE__ */ __name((min6, max9, chunkSize2) => {
    const remaining = max9 - min6 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min6, min6 + chunkSize2 - 1)), flatMap17(() => go3(min6 + chunkSize2, max9, chunkSize2)));
    }
    return write(range(min6, min6 + remaining - 1));
  }, "go");
  return new StreamImpl(go3(min5, max8, chunkSize));
}), "range");
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = /* @__PURE__ */ __name((...streams) => make41().pipe(map20((halt2) => {
  let winner = null;
  return mergeAll7(streams.map((stream6, index2) => stream6.pipe(takeWhile4(() => {
    if (winner === null) {
      winner = index2;
      unsafeDone(halt2, void_4);
      return true;
    }
    return winner === index2;
  }), interruptWhen2(_await3(halt2).pipe(flatMap14(() => winner === index2 ? never4 : _void))))), {
    concurrency: streams.length
  });
}), unwrap3), "raceAll");
var rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend12(() => {
  const target2 = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target2), target2);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}));
var rechunkProcess = /* @__PURE__ */ __name((rechunker, target2) => readWithCause({
  onInput: (chunk4) => {
    if (chunk4.length === target2 && rechunker.isEmpty()) {
      return flatMap17(write(chunk4), () => rechunkProcess(rechunker, target2));
    }
    if (chunk4.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index2 = 0;
      while (index2 < chunk4.length) {
        while (index2 < chunk4.length && result === void 0) {
          result = rechunker.write(pipe(chunk4, unsafeGet2(index2)));
          index2 = index2 + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap17(writeAll(...chunks3), () => rechunkProcess(rechunker, target2));
    }
    return suspend8(() => rechunkProcess(rechunker, target2));
  },
  onFailure: (cause3) => zipRight7(rechunker.emitIfNotEmpty(), failCause11(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
}), "rechunkProcess");
var StreamRechunker = class {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_7;
  }
};
__name(StreamRechunker, "StreamRechunker");
var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll5(toChannel2(self2), (error3) => match2(pf(error3), {
  onNone: () => failCause11(die4(f(error3))),
  onSome: fail14
}))));
var repeat3 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(repeatEither(self2, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var repeatEffect = /* @__PURE__ */ __name((effect4) => repeatEffectOption(pipe(effect4, mapError4(some3))), "repeatEffect");
var repeatEffectChunk = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, mapError4(some3))), "repeatEffectChunk");
var repeatEffectChunkOption = /* @__PURE__ */ __name((effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map20(effect5, (chunk4) => some3([chunk4, effect5])), catchAll3(match2({
  onNone: () => succeed10(none2()),
  onSome: fail10
})))), "repeatEffectChunkOption");
var repeatEffectOption = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, map20(of2))), "repeatEffectOption");
var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatWith(self2, schedule4, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(repeatElementsWith(self2, schedule4, {
  onElement: (a) => some3(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  const driver3 = pipe(driver2(schedule4), map20((driver4) => {
    const feed = /* @__PURE__ */ __name((input) => match2(head2(input), {
      onNone: () => loop3,
      onSome: (a) => zipRight7(write(of2(options4.onElement(a))), step4(pipe(input, drop2(1)), a))
    }), "feed");
    const step4 = /* @__PURE__ */ __name((input, a) => {
      const advance = pipe(driver4.next(a), as7(pipe(write(of2(options4.onElement(a))), flatMap17(() => step4(input, a)))));
      const reset2 = pipe(driver4.last, orDie3, flatMap14((b) => pipe(driver4.reset, map20(() => pipe(write(of2(options4.onSchedule(b))), zipRight7(feed(input)))))));
      return pipe(advance, orElse6(() => reset2), unwrap2);
    }, "step");
    const loop3 = readWith({
      onInput: feed,
      onFailure: fail14,
      onDone: () => void_7
    });
    return loop3;
  }), unwrap2);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
});
var repeatValue = /* @__PURE__ */ __name((value6) => new StreamImpl(repeated(write(of2(value6)))), "repeatValue");
var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  return pipe(driver2(schedule4), map20((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const process2 = pipe(self2, provideLastIterationInfo, map29(options4.onElement), toChannel2);
    const loop3 = unwrap2(match14(driver3.next(void 0), {
      onFailure: () => void_7,
      onSuccess: (output) => flatMap17(process2, () => zipRight7(write(of2(options4.onSchedule(output))), loop3))
    }));
    return new StreamImpl(zipRight7(process2, loop3));
  }), unwrap3);
});
var repeatWithSchedule = /* @__PURE__ */ __name((value6, schedule4) => repeatEffectWithSchedule(succeed10(value6), schedule4), "repeatWithSchedule");
var repeatEffectWithSchedule = /* @__PURE__ */ __name((effect4, schedule4) => flatMap20(fromEffect8(zip8(effect4, driver2(schedule4))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  return concat2(succeed18(a), unfoldEffect(a, (s) => matchEffect3(driver3.next(s), {
    onFailure: succeed10,
    onSuccess: () => map20(provideLastIterationInfo(effect4), (nextA) => some3([nextA, nextA]))
  })));
}), "repeatEffectWithSchedule");
var retry6 = /* @__PURE__ */ dual(2, (self2, policy2) => driver2(policy2).pipe(map20((driver3) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  const loop3 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as7(driver3.reset, out)), catchAll5((error3) => driver3.next(error3).pipe(match14({
    onFailure: () => fail14(error3),
    onSuccess: () => loop3
  }), unwrap2)));
  return loop3;
}), unwrap2, fromChannel2));
var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy2, options4) => suspend12(() => {
  const preventFallbackOnPartialStream = options4?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop3 = suspend12(() => {
    const step4 = policy2.steps[i++];
    if (!step4) {
      return fail18(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext2(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error3 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend12(() => {
        if (attempted)
          return wrapped;
        attempted = true;
        return fail18(error3);
      });
      nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule4 = scheduleFromStep(step4, true);
      nextStream = schedule4 ? scheduleDefectRefail2(retry6(nextStream, schedule4)) : nextStream;
    }
    return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk4) => {
      receivedElements = true;
      return chunk4;
    }) : nextStream, (error3) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail18(error3);
      }
      lastError = some3(error3);
      return loop3;
    });
  });
  return loop3;
}));
var scheduleDefectRefail2 = /* @__PURE__ */ __name((self2) => catchAllCause6(self2, (cause3) => failCause14(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
var run3 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = /* @__PURE__ */ __name((self2) => run3(self2, collectAll()), "runCollect");
var runCount = /* @__PURE__ */ __name((self2) => run3(self2, count), "runCount");
var runDrain2 = /* @__PURE__ */ __name((self2) => run3(self2, drain2), "runDrain");
var runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, fold(s, cont, f)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, foldEffect(s, cont, f)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
var runForEach = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEach11(f)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachChunk(f)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach11(f))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachWhile(f)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
var runHead = /* @__PURE__ */ __name((self2) => run3(self2, head6()), "runHead");
var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped3));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap17(fromEffect5(offerAll3(queue, map5(input, succeed3))), () => writer),
    onFailure: (cause3) => fromEffect5(offer3(queue, failCause3(map16(cause3, some3)))),
    onDone: () => fromEffect5(offer3(queue, fail3(none2())))
  });
  return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid5);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap17(write(chunk3(input)), () => writer),
    onFailure: (cause3) => write(failCause12(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take10) => offer3(queue, take10)), drain, runScoped, asVoid5);
});
var runLast = /* @__PURE__ */ __name((self2) => run3(self2, last4()), "runLast");
var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = /* @__PURE__ */ __name((self2) => run3(self2, sum2), "runSum");
var scan = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed10(f(s2, a)))));
var scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed10(f(a2, a)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option7, a) => {
  switch (option7._tag) {
    case "None": {
      return succeed10([some3(a), a]);
    }
    case "Some": {
      return pipe(f(option7.value, a), map20((b) => [some3(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(scheduleWith(self2, schedule4, {
  onElement: some3,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  const loop3 = /* @__PURE__ */ __name((driver3, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (chunk4) => loop3(driver3, chunk4[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeedNow
      });
    }
    return unwrap2(matchEffect3(driver3.next(next.value), {
      onFailure: () => pipe(driver3.last, orDie3, map20((b) => pipe(write(make4(options4.onElement(next.value), options4.onSchedule(b))), flatMap17(() => loop3(driver3, iterator)))), zipLeft6(driver3.reset)),
      onSuccess: () => succeed10(pipe(write(of2(options4.onElement(next.value))), flatMap17(() => loop3(driver3, iterator))))
    }));
  }, "loop");
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap17((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty3()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap17(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map20((s3) => [s3, s3])))))))));
var scoped6 = /* @__PURE__ */ __name((effect4) => new StreamImpl(ensuring3(scoped5(pipe(effect4, map20(of2))), _void)), "scoped");
var scopedWith4 = /* @__PURE__ */ __name((f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map20(of2)))), "scopedWith");
var some9 = /* @__PURE__ */ __name((self2) => pipe(self2, mapError8(some3), someOrFail(() => none2())), "some");
var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map29(getOrElse(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self2, error3) => mapEffectSequential(self2, match2({
  onNone: () => failSync4(error3),
  onSome: succeed10
})));
var sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die11(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend8(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = /* @__PURE__ */ __name((queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty3() : of2(items);
        return pipe(write(result2), flatMap17(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
      const result = isEmpty(lastItems) ? empty3() : of2(lastItems);
      return pipe(write(result), flatMap17(() => channelEnd));
    }, "emitOnStreamEnd");
    const reader = /* @__PURE__ */ __name((queueSize) => readWithCause({
      onInput: (input) => flatMap17(write(filterMap3(input, (element2, index2) => {
        queue.put(element2);
        const currentIndex = queueSize + index2 + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some3(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause11(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_7)
    }), "reader");
    return pipe(toChannel2(self2), pipeTo(reader(0)));
  }));
});
var split3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const split5 = /* @__PURE__ */ __name((leftovers, input) => {
    const [chunk4, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
    if (isEmpty(chunk4) || isEmpty(remaining)) {
      return loop3(pipe(chunk4, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk4)), flatMap17(() => split5(empty3(), pipe(remaining, drop2(1)))));
  }, "split");
  const loop3 = /* @__PURE__ */ __name((leftovers) => readWith({
    onInput: (input) => split5(leftovers, input),
    onFailure: fail14,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_7;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight7(write(of2(leftovers)), void_7);
      }
      return zipRight7(split5(empty3(), leftovers), void_7);
    }
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty3()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
  const next = /* @__PURE__ */ __name((leftover2, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer4;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover2, getOrElse(() => empty3())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet2(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer4 === void 0) {
              buffer4 = [];
            }
            buffer4.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
            return [empty3(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet2(0))) ? 1 : 0];
      }));
      const output = buffer4 === void 0 ? empty3() : unsafeFromArray(buffer4);
      return flatMap17(write(output), () => next(isNonEmpty(carry) ? some3(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover2, {
      onNone: () => failCause11(cause3),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), failCause11(cause3))
    }),
    onDone: (done12) => match2(leftover2, {
      onNone: () => succeed14(done12),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), succeed14(done12))
    })
  }), "next");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(next(none2(), 0))));
});
var splitLines2 = /* @__PURE__ */ __name((self2) => pipeThroughChannel(self2, splitLines()), "splitLines");
var succeed18 = /* @__PURE__ */ __name((value6) => fromChunk(of2(value6)), "succeed");
var sync12 = /* @__PURE__ */ __name((evaluate3) => suspend12(() => fromChunk(of2(evaluate3()))), "sync");
var suspend12 = /* @__PURE__ */ __name((stream6) => new StreamImpl(suspend8(() => toChannel2(stream6()))), "suspend");
var take7 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (!Number.isInteger(n)) {
    return die11(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop3 = /* @__PURE__ */ __name((n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover2 = Math.max(0, n2 - taken.length);
      const more = leftover2 > 0;
      if (more) {
        return pipe(write(taken), flatMap17(() => loop3(leftover2)));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed14
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop3(n) : void_7)));
});
var takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return empty33;
  }
  return new StreamImpl(pipe(succeed10(new RingBuffer(n)), map20((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element2 of input) {
          queue.put(element2);
        }
        return reader;
      },
      onFailure: fail14,
      onDone: () => pipe(write(queue.toChunk()), zipRight7(void_7))
    });
    return pipe(toChannel2(self2), pipeTo(reader));
  }), unwrap2));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile((a) => !predicate(a)));
      const last5 = pipe(input, drop2(taken.length), take(1));
      if (isEmpty(last5)) {
        return pipe(write(taken), flatMap17(() => loop3));
      }
      return write(pipe(taken, appendAll2(last5)));
    },
    onFailure: fail14,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = /* @__PURE__ */ __name((iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    }
    return pipe(predicate(next.value), map20((bool) => bool ? write(of2(next.value)) : pipe(write(of2(next.value)), flatMap17(() => loop3(iterator)))), unwrap2);
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty3()[Symbol.iterator]()))));
});
var takeWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap17(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var tap7 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as7(f(a), a)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self2, options4) => pipe(self2, tapError5(options4.onFailure), tap7(options4.onSuccess)));
var tapError5 = /* @__PURE__ */ dual(2, (self2, f) => catchAll7(self2, (error3) => fromEffect8(zipRight6(f(error3), fail10(error3)))));
var tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = readWithCause({
    onInput: (chunk4) => flatMap17(write(chunk4), () => loop3),
    onFailure: (cause3) => fromEffect5(zipRight6(f(cause3), failCause9(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect8(all7([bounded5(1), make41()])), flatMap20(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk4) => pipe(fromEffect5(offer3(queue, chunk3(chunk4))), foldCauseChannel({
      onFailure: () => flatMap17(write(chunk4), () => identityChannel()),
      onSuccess: () => flatMap17(write(chunk4), () => loop3)
    })),
    onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause12(cause3))), foldCauseChannel({
      onFailure: () => failCause11(cause3),
      onSuccess: () => failCause11(cause3)
    })),
    onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_7,
      onSuccess: () => void_7
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring3(zipRight6(forkDaemon2(offer3(queue, end4)), _await3(deferred))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight6(shutdown4(queue), succeed8(deferred, void 0)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self2, options4) => throttleEffect(self2, {
  ...options4,
  cost: (chunk4) => succeed10(options4.cost(chunk4))
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.strategy === "enforce") {
    return throttleEnforceEffect(self2, options4.cost, options4.units, options4.duration, options4.burst ?? 0);
  }
  return throttleShapeEffect(self2, options4.cost, options4.units, options4.duration, options4.burst ?? 0);
});
var throttleEnforceEffect = /* @__PURE__ */ __name((self2, cost, units, duration3, burst) => {
  const loop3 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip8(currentTimeMillis2), map20(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration3);
      const sum3 = tokens + cycles * units;
      const max8 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max8 : Math.min(sum3, max8);
      if (weight <= available) {
        return pipe(write(input), flatMap17(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap2),
    onFailure: failCause11,
    onDone: () => void_7
  }), "loop");
  const throttled = pipe(currentTimeMillis2, map20((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
}, "throttleEnforceEffect");
var throttleShapeEffect = /* @__PURE__ */ __name((self2, costFn, units, duration3, burst) => {
  const loop3 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip8(currentTimeMillis2), map20(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration3);
      const sum3 = tokens + cycles * units;
      const max8 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max8 : Math.min(sum3, max8);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration3)));
      if (greaterThan2(delay3, zero)) {
        return pipe(fromEffect5(sleep2(delay3)), zipRight7(write(input)), flatMap17(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap17(write(input), () => loop3(remaining, currentTimeMillis3));
    }), unwrap2),
    onFailure: failCause11,
    onDone: () => void_7
  }), "loop");
  const throttled = pipe(currentTimeMillis2, map20((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
}, "throttleShapeEffect");
var tick = /* @__PURE__ */ __name((interval) => repeatWithSchedule(void 0, spaced2(interval)), "tick");
var timeout3 = /* @__PURE__ */ dual(2, (self2, duration3) => pipe(toPull2(self2), map20(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration3
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error3, duration3) => pipe(self2, timeoutTo3(duration3, failSync8(error3))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration3) => pipe(toPull2(self2), map20(timeoutFailCause2({
  onTimeout: () => map16(cause3(), some3),
  duration: duration3
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration3, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration3), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some3(that) : none2()));
});
var pubsubFromOptions = /* @__PURE__ */ __name((options4) => {
  if (typeof options4 === "number") {
    return bounded4(options4);
  } else if (options4.capacity === "unbounded") {
    return unbounded4({
      replay: options4.replay
    });
  }
  switch (options4.strategy) {
    case "dropping":
      return dropping3(options4);
    case "sliding":
      return sliding3(options4);
    default:
      return bounded4(options4);
  }
}, "pubsubFromOptions");
var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap4((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = /* @__PURE__ */ __name((self2) => map20(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError4(some3), flatMap14(match({
  onLeft: () => fail10(none2()),
  onRight: succeed10
})))), "toPull");
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap4(acquireRelease2(options4?.strategy === "unbounded" ? unbounded5() : options4?.strategy === "dropping" ? dropping4(options4.capacity ?? 2) : options4?.strategy === "sliding" ? sliding4(options4.capacity ?? 2) : bounded5(options4?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap4(acquireRelease2(bounded5(options4?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => toReadableStreamRuntime(self2, defaultRuntime2, options4));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => map20(runtime4(), (runtime6) => toReadableStreamRuntime(self2, runtime6, options4)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime6, options4) => {
  const runFork4 = runFork3(runtime6);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self2, (chunk4) => {
        if (chunk4.length === 0)
          return _void;
        return latch.whenOpen(sync6(() => {
          latch.unsafeClose();
          for (const item of chunk4) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }));
      }));
      fiber.addObserver((exit4) => {
        try {
          if (exit4._tag === "Failure") {
            controller.error(squash(exit4.cause));
          } else {
            controller.close();
          }
        } catch {
        }
      });
    },
    pull() {
      return new Promise((resolve3) => {
        currentResolve = resolve3;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber)
        return;
      return runPromise(asVoid5(interrupt5(fiber)));
    }
  }, options4?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
  const newChannel = suspend8(() => {
    const leftovers = {
      ref: empty3()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer4 = suspend8(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap17(() => buffer4)),
          onFailure: fail14,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty3();
      return pipe(writeChunk(leftover2), flatMap17(() => buffer4));
    });
    const concatAndGet = /* @__PURE__ */ __name((chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll2(leftover2, filter3(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    }, "concatAndGet");
    const upstreamMarker = readWith({
      onInput: (input) => flatMap17(write(input), () => upstreamMarker),
      onFailure: fail14,
      onDone: (done12) => zipRight7(sync9(() => {
        upstreamDone.ref = true;
      }), succeedNow(done12))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap17(([leftover2, z]) => pipe(succeed14([upstreamDone.ref, concatAndGet(leftover2)]), flatMap17(([done12, newLeftovers]) => {
      const nextChannel = done12 && isEmpty(newLeftovers) ? void_7 : transducer;
      return pipe(write(of2(z)), flatMap17(() => nextChannel));
    }))));
    return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer4), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime6) => {
  const runFork4 = runFork3(runtime6);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      let returned = false;
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self2, (value6) => latch.whenOpen(sync6(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value6
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit4) => {
              if (returned)
                return;
              fiber = runFork2(latch.whenOpen(sync6(() => {
                if (exit4._tag === "Failure") {
                  currentReject(squash(exit4.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve3, reject) => {
            currentResolve = resolve3;
            currentReject = reject;
            latch.unsafeOpen();
          });
        },
        return() {
          returned = true;
          if (!fiber)
            return Promise.resolve({
              done: true,
              value: void 0
            });
          return runPromise(as7(interrupt5(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var toAsyncIterable = /* @__PURE__ */ __name((self2) => toAsyncIterableRuntime(self2, defaultRuntime2), "toAsyncIterable");
var toAsyncIterableEffect = /* @__PURE__ */ __name((self2) => map20(runtime4(), (runtime6) => toAsyncIterableRuntime(self2, runtime6)), "toAsyncIterableEffect");
var unfold3 = /* @__PURE__ */ __name((s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3]))), "unfold");
var unfoldChunk = /* @__PURE__ */ __name((s, f) => {
  const loop3 = /* @__PURE__ */ __name((s2) => match2(f(s2), {
    onNone: () => void_7,
    onSome: ([chunk4, s3]) => flatMap17(write(chunk4), () => loop3(s3))
  }), "loop");
  return new StreamImpl(suspend8(() => loop3(s)));
}, "unfoldChunk");
var unfoldChunkEffect = /* @__PURE__ */ __name((s, f) => suspend12(() => {
  const loop3 = /* @__PURE__ */ __name((s2) => unwrap2(map20(f(s2), match2({
    onNone: () => void_7,
    onSome: ([chunk4, s3]) => flatMap17(write(chunk4), () => loop3(s3))
  }))), "loop");
  return new StreamImpl(loop3(s));
}), "unfoldChunkEffect");
var unfoldEffect = /* @__PURE__ */ __name((s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map20(map2(([a, s3]) => [of2(a), s3])))), "unfoldEffect");
var void_9 = /* @__PURE__ */ succeed18(void 0);
var unwrap3 = /* @__PURE__ */ __name((effect4) => flatten15(fromEffect8(effect4)), "unwrap");
var unwrapScoped4 = /* @__PURE__ */ __name((effect4) => flatten15(scoped6(effect4)), "unwrapScoped");
var unwrapScopedWith3 = /* @__PURE__ */ __name((f) => flatten15(scopedWith4((scope5) => f(scope5))), "unwrapScopedWith");
var updateService4 = /* @__PURE__ */ dual(3, (self2, tag8, f) => pipe(self2, mapInputContext5((context11) => pipe(context11, add4(tag8, f(pipe(context11, unsafeGet5(tag8))))))));
var when3 = /* @__PURE__ */ dual(2, (self2, test3) => pipe(self2, whenEffect3(sync6(test3))));
var whenCase = /* @__PURE__ */ __name((evaluate3, pf) => whenCaseEffect(pf)(sync6(evaluate3)), "whenCase");
var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect8(self2), flatMap20((a) => pipe(pf(a), getOrElse(() => empty33)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect8(effect4), flatMap20((bool) => bool ? self2 : empty33)));
var withSpan6 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self2), name, options4));
  }
  return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options4));
}, "withSpan");
var zip11 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith14(that, (a, a2) => [a, a2])));
var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith14(that, (a, a2) => [...a, a2])));
var zipAll = /* @__PURE__ */ dual(2, (self2, options4) => zipAllWith(self2, {
  other: options4.other,
  onSelf: (a) => [a, options4.defaultOther],
  onOther: (a2) => [options4.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: (a) => [a, options4.defaultOther],
  onOther: (a2) => [options4.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options4.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: identity,
  onOther: () => options4.defaultSelf,
  onBoth: (a) => a,
  order: options4.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: () => options4.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options4.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options4) => {
  const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match14({
          onFailure: fail3,
          onSuccess: (leftChunk) => succeed3([map5(leftChunk, ([k, a]) => [k, options4.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match14({
          onFailure: fail3,
          onSuccess: (rightChunk) => succeed3([map5(rightChunk, ([k, a2]) => [k, options4.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip8(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error3) => succeed10(fail3(some3(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed3(merge13(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed10(succeed3([pipe(leftOption.value, map5(([k, a]) => [k, options4.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed10(succeed3([pipe(rightOption.value, map5(([k, a2]) => [k, options4.onOther(a2)])), DrainRight]));
            }
            return succeed10(fail3(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: () => succeed10(succeed3([pipe(state.rightChunk, map5(([k, a2]) => [k, options4.onOther(a2)])), DrainRight])),
            onSome: (error3) => succeed10(fail3(some3(error3)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed10(succeed3(merge13(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: () => succeed10(succeed3([map5(state.leftChunk, ([k, a]) => [k, options4.onSelf(a)]), DrainLeft])),
            onSome: (error3) => succeed10(fail3(some3(error3)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed10(succeed3(merge13(state.leftChunk, rightChunk)))
        });
      }
    }
  }, "pull");
  const merge13 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
    const hasNext = /* @__PURE__ */ __name((chunk4, index2) => index2 < chunk4.length - 1, "hasNext");
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare3 = options4.order(k1, k2);
      if (compare3 === 0) {
        builder.push([k1, options4.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare3 < 0) {
        builder.push([k1, options4.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options4.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  }, "merge");
  return combineChunks(self2, options4.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self2, options4) => {
  const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: (error3) => succeed10(fail3(error3)),
          onSuccess: (leftChunk) => succeed10(succeed3([map5(leftChunk, options4.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: (error3) => succeed10(fail3(error3)),
          onSuccess: (rightChunk) => succeed10(succeed3([map5(rightChunk, options4.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip8(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error3) => succeed10(fail3(some3(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip16(leftOption.value, rightOption.value, options4.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed10(succeed3([map5(leftOption.value, options4.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed10(succeed3([map5(rightOption.value, options4.onOther), DrainRight]));
            }
            return succeed10(fail3(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: () => succeed10(succeed3([map5(state.rightChunk, options4.onOther), DrainRight])),
            onSome: (error3) => succeed10(fail3(some3(error3)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed10(succeed3(zip16(leftChunk, state.rightChunk, options4.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: () => succeed10(succeed3([map5(state.leftChunk, options4.onSelf), DrainLeft])),
            onSome: (error3) => succeed10(fail3(some3(error3)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed10(succeed3(zip16(state.leftChunk, rightChunk, options4.onBoth)));
          }
        });
      }
    }
  }, "pull");
  const zip16 = /* @__PURE__ */ __name((leftChunk, rightChunk, f) => {
    const [output, either9] = zipChunks(leftChunk, rightChunk, f);
    switch (either9._tag) {
      case "Left": {
        if (isEmpty(either9.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either9.left)];
      }
      case "Right": {
        if (isEmpty(either9.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either9.right)];
      }
    }
  }, "zip");
  return combineChunks(self2, options4.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = /* @__PURE__ */ __name((...streams) => {
  if (streams.length === 0) {
    return empty33;
  } else if (streams.length === 1) {
    return map29(streams[0], (x) => [x]);
  }
  const [head10, ...tail2] = streams;
  return zipLatestWith(head10, zipLatestAll(...tail2), (first2, second) => [first2, ...second]);
}, "zipLatestAll");
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
  const pullNonEmpty = /* @__PURE__ */ __name((pull) => pipe(pull, flatMap14((chunk4) => isEmpty(chunk4) ? pullNonEmpty(pull) : succeed10(chunk4))), "pullNonEmpty");
  return pipe(toPull2(left3), map20(pullNonEmpty), zip8(pipe(toPull2(right3), map20(pullNonEmpty))), flatMap14(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith8(join4(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith8(join4(leftFiber), (l, r) => [r, l, false]))
  })), flatMap20(([l, r, leftFirst]) => pipe(fromEffect8(make25([unsafeLast(l), unsafeLast(r)])), flatMap20((latest) => pipe(fromChunk(leftFirst ? pipe(r, map5((a2) => f(unsafeLast(l), a2))) : pipe(l, map5((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => modify6(latest, ([_, rightLatest]) => [pipe(leftChunk, map5((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
    onRight: (rightChunk) => modify6(latest, ([leftLatest, _]) => [pipe(rightChunk, map5((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
  })), flatMap20(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft9 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight11 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take(right4.length)))];
  }
  return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith14 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip8(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error3) => succeed10(fail3(some3(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip16(leftOption.value, rightOption.value)));
            }
            return succeed10(fail3(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect3(pullLeft, {
          onFailure: (error3) => succeed10(fail3(error3)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed10(succeed3(zip16(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect3(pullRight, {
          onFailure: (error3) => succeed10(fail3(error3)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed10(succeed3(zip16(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  }, "pull");
  const zip16 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
    const [output, either9] = f(leftChunk, rightChunk);
    switch (either9._tag) {
      case "Left": {
        if (isEmpty(either9.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either9.left)];
      }
      case "Right": {
        if (isEmpty(either9.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either9.right)];
      }
    }
  }, "zip");
  return pipe(self2, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(0, (index2, a) => [index2 + 1, [a, index2]])), "zipWithIndex");
var zipWithNext = /* @__PURE__ */ __name((self2) => {
  const process2 = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk4] = mapAccum2(input, last5, (prev, curr) => [some3(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap3(chunk4, (option7) => isSome2(option7) ? some3([option7.value[0], some3(option7.value[1])]) : none2());
      return flatMap17(write(output), () => process2(newLast));
    },
    onFailure: failCause11,
    onDone: () => match2(last5, {
      onNone: () => void_7,
      onSome: (value6) => zipRight7(write(of2([value6, none2()])), void_7)
    })
  }), "process");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
}, "zipWithNext");
var zipWithPrevious = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some3(curr), [prev, curr]])), "zipWithPrevious");
var zipWithPreviousAndNext = /* @__PURE__ */ __name((self2) => pipe(zipWithNext(zipWithPrevious(self2)), map29(([[prev, curr], next]) => [prev, curr, pipe(next, map2((tuple4) => tuple4[1]))])), "zipWithPreviousAndNext");
var zipChunks = /* @__PURE__ */ __name((left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take(right3.length), zipWith3(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith3(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
}, "zipChunks");
var Do4 = /* @__PURE__ */ succeed18({});
var bind5 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag8, f, options4) => flatMap20(self2, (k) => map29(f(k), (a) => ({
  ...k,
  [tag8]: a
})), options4));
var bindTo5 = /* @__PURE__ */ bindTo(map29);
var let_5 = /* @__PURE__ */ let_(map29);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend12(() => {
  const decoder3 = new TextDecoder(encoding);
  return map29(self2, (s) => decoder3.decode(s));
}));
var encodeText = /* @__PURE__ */ __name((self2) => suspend12(() => {
  const encoder3 = new TextEncoder();
  return map29(self2, (s) => encoder3.encode(s));
}), "encodeText");
var fromEventListener = /* @__PURE__ */ __name((target2, type3, options4) => asyncPush((emit2) => acquireRelease2(sync6(() => target2.addEventListener(type3, emit2.single, options4)), () => sync6(() => target2.removeEventListener(type3, emit2.single, options4))), {
  bufferSize: typeof options4 === "object" ? options4.bufferSize : void 0
}), "fromEventListener");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var failCause15 = failCause11;
var flatMap21 = flatMap17;
var pipeTo2 = pipeTo;
var readWithCause2 = readWithCause;
var run4 = run;
var succeed19 = succeed14;
var suspend13 = suspend8;
var sync13 = sync9;
var void_10 = void_7;
var write2 = write;
var zipRight12 = zipRight7;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Sink.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var fail19 = fail15;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do5,
  StreamTypeId: () => StreamTypeId3,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as13,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind6,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo6,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer3,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  context: () => context9,
  contextWith: () => contextWith6,
  contextWithEffect: () => contextWithEffect6,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die13,
  dieMessage: () => dieMessage6,
  dieSync: () => dieSync9,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop5,
  dropRight: () => dropRight3,
  dropUntil: () => dropUntil5,
  dropUntilEffect: () => dropUntilEffect3,
  dropWhile: () => dropWhile6,
  dropWhileEffect: () => dropWhileEffect3,
  either: () => either6,
  empty: () => empty34,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith4,
  execute: () => execute2,
  fail: () => fail20,
  failCause: () => failCause17,
  failCauseSync: () => failCauseSync9,
  failSync: () => failSync10,
  filter: () => filter14,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap9,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect3,
  flatMap: () => flatMap22,
  flatten: () => flatten16,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect9,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub4,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue4,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity4,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_6,
  make: () => make61,
  map: () => map30,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth8,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect6,
  mapError: () => mapError10,
  mapErrorCause: () => mapErrorCause6,
  mapInputContext: () => mapInputContext7,
  merge: () => merge10,
  mergeAll: () => mergeAll8,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never8,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie7,
  orDieWith: () => orDieWith5,
  orElse: () => orElse13,
  orElseEither: () => orElseEither6,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition8,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext7,
  provideLayer: () => provideLayer3,
  provideService: () => provideService7,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext3,
  provideSomeLayer: () => provideSomeLayer4,
  race: () => race5,
  raceAll: () => raceAll4,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  repeat: () => repeat4,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect3,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped7,
  scopedWith: () => scopedWith5,
  share: () => share2,
  sliding: () => sliding8,
  slidingSize: () => slidingSize2,
  some: () => some11,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split4,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed21,
  suspend: () => suspend14,
  sync: () => sync15,
  take: () => take9,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap8,
  tapBoth: () => tapBoth4,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold4,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped6,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService6,
  void: () => void_11,
  when: () => when4,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip13,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft11,
  zipRight: () => zipRight13,
  zipWith: () => zipWith15,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/groupBy.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var isGroupBy = /* @__PURE__ */ __name((u) => hasProperty(u, GroupByTypeId), "isGroupBy");
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options4) => flatMap20(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options4?.bufferSize ?? 16
}));
var make60 = /* @__PURE__ */ __name((grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
}), "make");
var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options4) => make60(unwrapScoped4(gen3(function* () {
  const decider = yield* make41();
  const output = yield* acquireRelease2(bounded5(options4?.bufferSize ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make25(/* @__PURE__ */ new Map());
  const add8 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options4?.bufferSize ?? 16, ([key, value6]) => flatMap14(_await3(decider), (f2) => f2(key, value6)), (exit4) => offer3(output, exit4)));
  yield* succeed8(decider, (key, _) => pipe(get12(ref), map20((map33) => fromNullable(map33.get(key))), flatMap14(match2({
    onNone: () => flatMap14(add8, ([index2, queue]) => zipRight6(update3(ref, (map33) => map33.set(key, index2)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map13((tuple4) => of2(tuple4[1])))))])), as7((n) => n === index2)))),
    onSome: (index2) => succeed10((n) => n === index2)
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options4) => {
  if (options4?.key) {
    return evaluate2(groupByKey(self2, options4.key, {
      bufferSize: options4.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options4?.concurrency, () => mapEffectSequential(self2, f), (n) => options4?.unordered ? flatMap20(self2, (a) => fromEffect8(f(a)), {
    concurrency: n
  }) : mapEffectPar(self2, n, f));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag8, f, options4) => mapEffectOptions(self2, (k) => map20(f(k), (a) => ({
  ...k,
  [tag8]: a
})), options4));
var mapDequeue = /* @__PURE__ */ __name((dequeue, f) => new MapDequeue(dequeue, f), "mapDequeue");
var MapDequeue = class extends Class2 {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_) => _
  };
  constructor(dequeue, f) {
    super();
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity4(this.dequeue);
  }
  get size() {
    return size15(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown3(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown3(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull3(this.dequeue);
  }
  get isEmpty() {
    return isEmpty13(this.dequeue);
  }
  get take() {
    return pipe(take3(this.dequeue), map20((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map20(map5((a) => this.f(a))));
  }
  takeUpTo(max8) {
    return pipe(takeUpTo2(this.dequeue, max8), map20(map5((a) => this.f(a))));
  }
  takeBetween(min5, max8) {
    return pipe(takeBetween2(this.dequeue, min5, max8), map20(map5((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map20(map5((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map20(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
__name(MapDequeue, "MapDequeue");
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options4) => {
  const loop3 = /* @__PURE__ */ __name((map33, outerQueue) => readWithCause({
    onInput: (input) => flatMap17(fromEffect5(forEach10(groupByIterable(input, f), ([key, values6]) => {
      const innerQueue = map33.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded5(options4?.bufferSize ?? 16), flatMap14((innerQueue2) => pipe(sync6(() => {
          map33.set(key, innerQueue2);
        }), zipRight6(offer3(outerQueue, of5([key, innerQueue2]))), zipRight6(pipe(offer3(innerQueue2, chunk3(values6)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk3(values6)), (cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map33, outerQueue)),
    onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause12(cause3))),
    onDone: () => fromEffect5(pipe(forEach10(map33.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2())), {
      discard: true
    }), zipRight6(offer3(outerQueue, end4))))
  }), "loop");
  return make60(unwrapScopedWith3((scope5) => gen3(function* () {
    const map33 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded5();
    yield* addFinalizer2(scope5, shutdown4(queue));
    return yield* toChannel2(self2).pipe(pipeTo(loop3(map33, queue)), drain, runIn(scope5), forkIn2(scope5), as7(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map33 = /* @__PURE__ */ new Map();
  let next;
  while ((next = iterator.next()) && !next.done) {
    const value6 = next.value;
    const key = f(value6);
    if (map33.has(key)) {
      const innerBuilder = map33.get(key);
      innerBuilder.push(value6);
    } else {
      const innerBuilder = [value6];
      builder.push([key, innerBuilder]);
      map33.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
});

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Stream.js
var StreamTypeId3 = StreamTypeId2;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as13 = as11;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer3 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll7;
var catchAllCause7 = catchAllCause6;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine10 = combine9;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die13 = die11;
var dieSync9 = dieSync7;
var dieMessage6 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain4 = drain3;
var drainFork2 = drainFork;
var drop5 = drop3;
var dropRight3 = dropRight2;
var dropUntil5 = dropUntil3;
var dropUntilEffect3 = dropUntilEffect;
var dropWhile6 = dropWhile4;
var dropWhileEffect3 = dropWhileEffect;
var either6 = either5;
var empty34 = empty33;
var ensuring8 = ensuring6;
var ensuringWith4 = ensuringWith2;
var context9 = context6;
var contextWith6 = contextWith3;
var contextWithEffect6 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail20 = fail18;
var failSync10 = failSync8;
var failCause17 = failCause14;
var failCauseSync9 = failCauseSync7;
var filter14 = filter13;
var filterEffect3 = filterEffect2;
var filterMap9 = filterMap8;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find4 = find3;
var findEffect3 = findEffect;
var flatMap22 = flatMap20;
var flatten16 = flatten15;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect9 = fromEffect8;
var fromEffectOption2 = fromEffectOption;
var fromPubSub4 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable15 = fromIterable14;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue4 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy2 = groupBy;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity4 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse2 = intersperse;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make61 = make59;
var map30 = map29;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth8 = mapBoth7;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect6 = mapEffectOptions;
var mapError10 = mapError8;
var mapErrorCause6 = mapErrorCause5;
var merge10 = merge9;
var mergeAll8 = mergeAll7;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never8 = never5;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie7 = orDie5;
var orDieWith5 = orDieWith4;
var orElse13 = orElse11;
var orElseEither6 = orElseEither5;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition8 = partition7;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext7 = provideContext5;
var provideSomeContext3 = provideSomeContext2;
var provideLayer3 = provideLayer;
var provideService7 = provideService5;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext7 = mapInputContext5;
var provideSomeLayer4 = provideSomeLayer2;
var race5 = race3;
var raceAll4 = raceAll3;
var range3 = range2;
var rechunk2 = rechunk;
var refineOrDie3 = refineOrDie;
var refineOrDieWith3 = refineOrDieWith;
var repeat4 = repeat3;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry6;
var withExecutionPlan4 = withExecutionPlan3;
var run5 = run3;
var runCollect3 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan2 = scan;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped7 = scoped6;
var scopedWith5 = scopedWith4;
var sliding8 = sliding7;
var slidingSize2 = slidingSize;
var some11 = some9;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split4 = split3;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed21 = succeed18;
var sync15 = sync12;
var suspend14 = suspend12;
var take9 = take7;
var takeRight3 = takeRight2;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile5 = takeWhile4;
var tap8 = tap7;
var tapBoth4 = tapBoth3;
var tapError6 = tapError5;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold4 = unfold3;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_11 = void_9;
var unwrap5 = unwrap3;
var unwrapScoped6 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService6 = updateService4;
var when4 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan7 = withSpan6;
var zip13 = zip11;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft11 = zipLeft9;
var zipRight13 = zipRight11;
var zipWith15 = zipWith14;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do5 = Do4;
var bind6 = bind5;
var bindEffect2 = bindEffect;
var bindTo6 = bindTo5;
var let_6 = let_5;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = /* @__PURE__ */ __name((bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes), "Size");
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
var notFound = /* @__PURE__ */ __name((method, path) => new SystemError({
  module: "FileSystem",
  method,
  reason: "NotFound",
  description: "No such file or directory",
  pathOrDescriptor: path
}), "notFound");
var makeNoop = /* @__PURE__ */ __name((fileSystem) => {
  return {
    access(path) {
      return fail10(notFound("access", path));
    },
    chmod(path) {
      return fail10(notFound("chmod", path));
    },
    chown(path) {
      return fail10(notFound("chown", path));
    },
    copy(path) {
      return fail10(notFound("copy", path));
    },
    copyFile(path) {
      return fail10(notFound("copyFile", path));
    },
    exists() {
      return succeed10(false);
    },
    link(path) {
      return fail10(notFound("link", path));
    },
    makeDirectory() {
      return die7("not implemented");
    },
    makeTempDirectory() {
      return die7("not implemented");
    },
    makeTempDirectoryScoped() {
      return die7("not implemented");
    },
    makeTempFile() {
      return die7("not implemented");
    },
    makeTempFileScoped() {
      return die7("not implemented");
    },
    open(path) {
      return fail10(notFound("open", path));
    },
    readDirectory(path) {
      return fail10(notFound("readDirectory", path));
    },
    readFile(path) {
      return fail10(notFound("readFile", path));
    },
    readFileString(path) {
      return fail10(notFound("readFileString", path));
    },
    readLink(path) {
      return fail10(notFound("readLink", path));
    },
    realPath(path) {
      return fail10(notFound("realPath", path));
    },
    remove() {
      return _void;
    },
    rename(oldPath) {
      return fail10(notFound("rename", oldPath));
    },
    sink(path) {
      return fail19(notFound("sink", path));
    },
    stat(path) {
      return fail10(notFound("stat", path));
    },
    stream(path) {
      return fail20(notFound("stream", path));
    },
    symlink(fromPath) {
      return fail10(notFound("symlink", fromPath));
    },
    truncate(path) {
      return fail10(notFound("truncate", path));
    },
    utimes(path) {
      return fail10(notFound("utimes", path));
    },
    watch(path) {
      return fail20(notFound("watch", path));
    },
    writeFile(path) {
      return fail10(notFound("writeFile", path));
    },
    writeFileString(path) {
      return fail10(notFound("writeFileString", path));
    },
    ...fileSystem
  };
}, "makeNoop");
var layerNoop = /* @__PURE__ */ __name((fileSystem) => succeed12(tag2, makeNoop(fileSystem)), "layerNoop");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag2;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Path.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/path.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId22 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
__name(normalizeStringPosix, "normalizeStringPosix");
function _format(sep, pathObject) {
  const dir2 = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir2) {
    return base;
  }
  if (dir2 === pathObject.root) {
    return dir2 + base;
  }
  return dir2 + sep + base;
}
__name(_format, "_format");
function fromFileUrl(url2) {
  if (url2.protocol !== "file:") {
    return fail10(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "URL must be of scheme file"
    }));
  } else if (url2.hostname !== "") {
    return fail10(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "Invalid file URL host"
    }));
  }
  const pathname = url2.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail10(new BadArgument({
          module: "Path",
          method: "fromFileUrl",
          description: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed10(decodeURIComponent(pathname));
}
__name(fromFileUrl, "fromFileUrl");
var resolve = /* @__PURE__ */ __name(function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd = void 0;
  for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = arguments[i];
    } else {
      const process2 = globalThis.process;
      if (cwd === void 0 && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
        cwd = process2.cwd();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
}, "resolve");
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed10(outURL);
}
__name(toFileUrl, "toFileUrl");
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
__name(encodePathChars, "encodePathChars");
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId22]: TypeId22,
  resolve,
  normalize(path) {
    if (path.length === 0)
      return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute)
      return "/" + path;
    return path;
  },
  isAbsolute(path) {
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to)
      return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to)
      return "";
    let fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length4 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i <= length4; ++i) {
      if (i === length4) {
        if (toLen > length4) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length4) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path) {
    if (path.length === 0)
      return ".";
    let code = path.charCodeAt(0);
    const hasRoot = code === 47;
    let end6 = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end6 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end6 === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1)
      return "//";
    return path.slice(0, end6);
  },
  basename(path, ext) {
    let start3 = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end6 = i;
              }
            } else {
              extIdx = -1;
              end6 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end6)
        end6 = firstNonSlashEnd;
      else if (end6 === -1)
        end6 = path.length;
      return path.slice(start3, end6);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
      }
      if (end6 === -1)
        return "";
      return path.slice(start3, end6);
    }
  },
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end6);
  },
  format: /* @__PURE__ */ __name(function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  }, "format"),
  parse(path) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0)
      return ret;
    let code = path.charCodeAt(0);
    const isAbsolute = code === 47;
    let start3;
    if (isAbsolute) {
      ret.root = "/";
      start3 = 1;
    } else {
      start3 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start3; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path.slice(1, end6);
        else
          ret.base = ret.name = path.slice(startPart, end6);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end6);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end6);
      }
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});
var layer = /* @__PURE__ */ succeed12(Path, posixImpl);

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Path.js
var Path2 = Path;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/keyValueStore.js
var TypeId23 = /* @__PURE__ */ Symbol.for("@effect/platform/KeyValueStore");
var keyValueStoreTag = /* @__PURE__ */ GenericTag("@effect/platform/KeyValueStore");
var make63 = /* @__PURE__ */ __name((impl) => keyValueStoreTag.of({
  [TypeId23]: TypeId23,
  has: (key) => map20(impl.get(key), isSome2),
  isEmpty: map20(impl.size, (size18) => size18 === 0),
  modify: (key, f) => flatMap14(impl.get(key), (o) => {
    if (isNone2(o)) {
      return succeedNone2;
    }
    const newValue = f(o.value);
    return as7(impl.set(key, newValue), some3(newValue));
  }),
  modifyUint8Array: (key, f) => flatMap14(impl.getUint8Array(key), (o) => {
    if (isNone2(o)) {
      return succeedNone2;
    }
    const newValue = f(o.value);
    return as7(impl.set(key, newValue), some3(newValue));
  }),
  forSchema(schema3) {
    return makeSchemaStore(this, schema3);
  },
  ...impl
}), "make");
var makeStringOnly = /* @__PURE__ */ __name((impl) => {
  const encoder3 = new TextEncoder();
  return make63({
    ...impl,
    getUint8Array: (key) => impl.get(key).pipe(map20(map2((value6) => match(decodeBase64(value6), {
      onLeft: () => encoder3.encode(value6),
      onRight: identity
    })))),
    set: (key, value6) => typeof value6 === "string" ? impl.set(key, value6) : suspend4(() => impl.set(key, encodeBase64(value6)))
  });
}, "makeStringOnly");
var prefix = /* @__PURE__ */ dual(2, (self2, prefix3) => ({
  ...self2,
  get: (key) => self2.get(`${prefix3}${key}`),
  set: (key, value6) => self2.set(`${prefix3}${key}`, value6),
  remove: (key) => self2.remove(`${prefix3}${key}`),
  has: (key) => self2.has(`${prefix3}${key}`),
  modify: (key, f) => self2.modify(`${prefix3}${key}`, f)
}));
var SchemaStoreTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/KeyValueStore/SchemaStore");
var makeSchemaStore = /* @__PURE__ */ __name((store, schema3) => {
  const jsonSchema2 = parseJson(schema3);
  const parse4 = decodeUnknown3(jsonSchema2);
  const encode7 = encode5(jsonSchema2);
  const get23 = /* @__PURE__ */ __name((key) => flatMap14(store.get(key), match2({
    onNone: () => succeedNone2,
    onSome: (value6) => asSome2(parse4(value6))
  })), "get");
  const set15 = /* @__PURE__ */ __name((key, value6) => flatMap14(encode7(value6), (json8) => store.set(key, json8)), "set");
  const modify10 = /* @__PURE__ */ __name((key, f) => flatMap14(get23(key), (o) => {
    if (isNone2(o)) {
      return succeedNone2;
    }
    const newValue = f(o.value);
    return as7(set15(key, newValue), some3(newValue));
  }), "modify");
  return {
    [SchemaStoreTypeId]: SchemaStoreTypeId,
    get: get23,
    set: set15,
    modify: modify10,
    remove: store.remove,
    clear: store.clear,
    size: store.size,
    has: store.has,
    isEmpty: store.isEmpty
  };
}, "makeSchemaStore");
var layerMemory = /* @__PURE__ */ sync8(keyValueStoreTag, () => {
  const store = /* @__PURE__ */ new Map();
  const encoder3 = new TextEncoder();
  return make63({
    get: (key) => sync6(() => fromNullable(store.get(key)).pipe(map2((value6) => typeof value6 === "string" ? value6 : encodeBase64(value6)))),
    getUint8Array: (key) => sync6(() => fromNullable(store.get(key)).pipe(map2((value6) => typeof value6 === "string" ? encoder3.encode(value6) : value6))),
    set: (key, value6) => sync6(() => store.set(key, value6)),
    remove: (key) => sync6(() => store.delete(key)),
    clear: sync6(() => store.clear()),
    size: sync6(() => store.size)
  });
});
var layerFileSystem = /* @__PURE__ */ __name((directory) => effect(keyValueStoreTag, gen3(function* () {
  const fs = yield* FileSystem;
  const path = yield* Path2;
  const keyPath = /* @__PURE__ */ __name((key) => path.join(directory, encodeURIComponent(key)), "keyPath");
  if (!(yield* fs.exists(directory))) {
    yield* fs.makeDirectory(directory, {
      recursive: true
    });
  }
  return make63({
    get: (key) => pipe(map20(fs.readFileString(keyPath(key)), some3), catchTag2("SystemError", (sysError) => sysError.reason === "NotFound" ? succeed10(none2()) : fail10(sysError))),
    getUint8Array: (key) => pipe(map20(fs.readFile(keyPath(key)), some3), catchTag2("SystemError", (sysError) => sysError.reason === "NotFound" ? succeed10(none2()) : fail10(sysError))),
    set: (key, value6) => typeof value6 === "string" ? fs.writeFileString(keyPath(key), value6) : fs.writeFile(keyPath(key), value6),
    remove: (key) => fs.remove(keyPath(key)),
    has: (key) => fs.exists(keyPath(key)),
    clear: zipRight6(fs.remove(directory, {
      recursive: true
    }), fs.makeDirectory(directory, {
      recursive: true
    })),
    size: map20(fs.readDirectory(directory), (files) => files.length)
  });
})), "layerFileSystem");
var layerSchema = /* @__PURE__ */ __name((schema3, tagIdentifier) => {
  const tag8 = GenericTag(tagIdentifier);
  const layer13 = effect(tag8, map20(keyValueStoreTag, (store) => store.forSchema(schema3)));
  return {
    tag: tag8,
    layer: layer13
  };
}, "layerSchema");
var storageError = /* @__PURE__ */ __name((props) => new SystemError({
  reason: "PermissionDenied",
  module: "KeyValueStore",
  ...props
}), "storageError");
var layerStorage = /* @__PURE__ */ __name((evaluate3) => sync8(keyValueStoreTag, () => {
  const storage = evaluate3();
  return makeStringOnly({
    get: (key) => try_3({
      try: () => fromNullable(storage.getItem(key)),
      catch: () => storageError({
        pathOrDescriptor: key,
        method: "get",
        description: `Unable to get item with key ${key}`
      })
    }),
    set: (key, value6) => try_3({
      try: () => storage.setItem(key, value6),
      catch: () => storageError({
        pathOrDescriptor: key,
        method: "set",
        description: `Unable to set item with key ${key}`
      })
    }),
    remove: (key) => try_3({
      try: () => storage.removeItem(key),
      catch: () => storageError({
        pathOrDescriptor: key,
        method: "remove",
        description: `Unable to remove item with key ${key}`
      })
    }),
    clear: try_3({
      try: () => storage.clear(),
      catch: () => storageError({
        pathOrDescriptor: "clear",
        method: "clear",
        description: `Unable to clear storage`
      })
    }),
    size: try_3({
      try: () => storage.length,
      catch: () => storageError({
        pathOrDescriptor: "size",
        method: "size",
        description: `Unable to get size`
      })
    })
  });
}), "layerStorage");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/KeyValueStore.js
var TypeId24 = TypeId23;
var KeyValueStore = keyValueStoreTag;
var make64 = make63;
var makeStringOnly2 = makeStringOnly;
var prefix2 = prefix;
var layerMemory2 = layerMemory;
var layerFileSystem2 = layerFileSystem;
var SchemaStoreTypeId2 = SchemaStoreTypeId;
var layerSchema2 = layerSchema;
var layerStorage2 = layerStorage;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/PrimaryKey.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var symbol3 = /* @__PURE__ */ Symbol.for("effect/PrimaryKey");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Console.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var log4 = log2;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberSet.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId25 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId25), "isFiberSet");
var Proto3 = {
  [TypeId25]: TypeId25,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake14 = /* @__PURE__ */ __name((backing, deferred) => {
  const self2 = Object.create(Proto3);
  self2.state = {
    _tag: "Open",
    backing
  };
  self2.deferred = deferred;
  return self2;
}, "unsafeMake");
var make65 = /* @__PURE__ */ __name(() => acquireRelease2(map20(make41(), (deferred) => unsafeMake14(/* @__PURE__ */ new Set(), deferred)), (set15) => withFiberRuntime2((parent) => {
  const state = set15.state;
  if (state._tag === "Closed")
    return _void;
  set15.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set15.deferred));
})), "make");
var makeRuntime = /* @__PURE__ */ __name(() => flatMap14(make65(), (self2) => runtime5(self2)()), "makeRuntime");
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make14(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId3) => has4(ids2(fiberId3), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self2, fiber, options4) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self2.state.backing.has(fiber)) {
    return;
  }
  self2.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self2.state._tag === "Closed") {
      return;
    }
    self2.state.backing.delete(fiber);
    if (isFailure3(exit4) && (options4?.propagateInterruption === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self2.deferred, exit4);
    }
  });
});
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
}();
var runtime5 = /* @__PURE__ */ __name((self2) => () => map20(runtime4(), (runtime6) => {
  const runFork4 = runFork3(runtime6);
  return (effect4, options4) => {
    if (self2.state._tag === "Closed") {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options4);
    unsafeAdd(self2, fiber);
    return fiber;
  };
}), "runtime");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add7,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json2,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make66,
  map: () => map31,
  mapInput: () => mapInput8,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none10,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  remove: () => remove10,
  replace: () => replace2,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed22,
  sync: () => sync16,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip14,
  zipLeft: () => zipLeft12,
  zipRight: () => zipRight14
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/logger-circular.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var test = /* @__PURE__ */ dual(2, (self2, input) => self2.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty26,
  context: empty19(),
  spans: empty11(),
  annotations: empty10(),
  date: /* @__PURE__ */ new Date()
}));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Logger.js
var LoggerTypeId2 = LoggerTypeId;
var make66 = makeLogger;
var add7 = addLogger;
var addEffect = addLoggerEffect;
var addScoped = addLoggerScoped;
var mapInput8 = mapInput4;
var mapInputOptions2 = mapInputOptions;
var filterLogLevel2 = filterLogLevel;
var map31 = map15;
var batched = batchedLogger;
var withConsoleLog = loggerWithConsoleLog;
var withLeveledConsole = loggerWithLeveledLog;
var withConsoleError = loggerWithConsoleError;
var none10 = none7;
var remove10 = removeLogger;
var replace2 = replaceLogger;
var replaceEffect = replaceLoggerEffect;
var replaceScoped = replaceLoggerScoped;
var simple2 = simple;
var succeed22 = succeed5;
var sync16 = sync3;
var test2 = test;
var withMinimumLogLevel2 = withMinimumLogLevel;
var withSpanAnnotations = loggerWithSpanAnnotations;
var zip14 = zip5;
var zipLeft12 = zipLeft4;
var zipRight14 = zipRight4;
var defaultLogger2 = defaultLogger;
var jsonLogger3 = jsonLogger;
var logfmtLogger2 = logfmtLogger;
var stringLogger2 = stringLogger;
var prettyLogger3 = prettyLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;
var structuredLogger3 = structuredLogger;
var tracerLogger2 = tracerLogger;
var json2 = /* @__PURE__ */ replace2(defaultLogger, jsonLogger2);
var logFmt = /* @__PURE__ */ replace2(defaultLogger, logFmtLogger);
var pretty5 = /* @__PURE__ */ replace2(defaultLogger, prettyLogger2);
var structured = /* @__PURE__ */ replace2(defaultLogger, structuredLogger2);
var minimumLogLevel2 = minimumLogLevel;
var isLogger2 = isLogger;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Mailbox.js
var Mailbox_exports = {};
__export(Mailbox_exports, {
  ReadonlyTypeId: () => ReadonlyTypeId2,
  TypeId: () => TypeId27,
  fromStream: () => fromStream2,
  into: () => into2,
  isMailbox: () => isMailbox,
  isReadonlyMailbox: () => isReadonlyMailbox,
  make: () => make68,
  toChannel: () => toChannel5,
  toStream: () => toStream2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/mailbox.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId26 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty35 = /* @__PURE__ */ empty3();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty35);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty35, true];
var MailboxImpl = class extends Class2 {
  scheduler;
  capacity;
  strategy;
  [TypeId26] = TypeId26;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty3();
  constructor(scheduler2, capacity7, strategy) {
    super();
    this.scheduler = scheduler2;
    this.capacity = capacity7;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable3(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable2(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable3(messages)), takeRight(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable2(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable2(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error3) {
    return this.done(exitFail(error3));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty35;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty35);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight2(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty35, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight2(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight2(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size18 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some3(size18);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0)
        return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0)
            return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty35;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty35;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
__name(MailboxImpl, "MailboxImpl");
var make67 = /* @__PURE__ */ __name((capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend"))), "make");
var into = /* @__PURE__ */ dual(2, (effect4, self2) => uninterruptibleMask((restore) => matchCauseEffect(restore(effect4), {
  onFailure: (cause3) => self2.failCause(cause3),
  onSuccess: (_) => self2.end
})));
var toChannel4 = /* @__PURE__ */ __name((self2) => {
  const loop3 = flatMap17(self2.takeAll, ([messages, done12]) => done12 ? messages.length === 0 ? void_7 : write(messages) : zipRight7(write(messages), loop3));
  return loop3;
}, "toChannel");
var toStream = /* @__PURE__ */ __name((self2) => fromChannel2(toChannel4(self2)), "toStream");
var fromStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap2(acquireRelease(make67(options4), (mailbox) => mailbox.shutdown), (mailbox) => {
  const writer = readWithCause({
    onInput: (input) => flatMap17(mailbox.offerAll(input), () => writer),
    onFailure: (cause3) => mailbox.failCause(cause3),
    onDone: () => mailbox.end
  });
  return scopeWith((scope5) => toChannel2(self2).pipe(pipeTo(writer), runIn(scope5), forkIn(scope5)));
}));

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Mailbox.js
var TypeId27 = TypeId26;
var ReadonlyTypeId2 = ReadonlyTypeId;
var isMailbox = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId27), "isMailbox");
var isReadonlyMailbox = /* @__PURE__ */ __name((u) => hasProperty(u, ReadonlyTypeId2), "isReadonlyMailbox");
var make68 = make67;
var into2 = into;
var toChannel5 = toChannel4;
var toStream2 = toStream;
var fromStream2 = fromStream;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date3,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either8,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf3,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is3,
  nonEmptyString: () => nonEmptyString4,
  not: () => not4,
  null: () => _null,
  number: () => number5,
  option: () => option6,
  orElse: () => orElse15,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record3,
  string: () => string6,
  symbol: () => symbol4,
  tag: () => tag4,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value4,
  valueTags: () => valueTags2,
  when: () => when6,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2,
  withReturnType: () => withReturnType2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/matcher.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId28 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId28]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
__name(makeTypeMatcher, "makeTypeMatcher");
var ValueMatcherProto = {
  [TypeId28]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value6) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value6;
  return matcher;
}
__name(makeValueMatcher, "makeValueMatcher");
var makeWhen = /* @__PURE__ */ __name((guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
}), "makeWhen");
var makeNot = /* @__PURE__ */ __name((guard, evaluate3) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate3
}), "makeNot");
var makePredicate = /* @__PURE__ */ __name((pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
}, "makePredicate");
var makeOrPredicate = /* @__PURE__ */ __name((patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
}, "makeOrPredicate");
var makeAndPredicate = /* @__PURE__ */ __name((patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
}, "makeAndPredicate");
var type = /* @__PURE__ */ __name(() => makeTypeMatcher([]), "type");
var value3 = /* @__PURE__ */ __name((i) => makeValueMatcher(i, left2(i)), "value");
var valueTags = /* @__PURE__ */ dual(2, (input, fields) => {
  const match21 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match21(input);
});
var typeTags = /* @__PURE__ */ __name(() => (fields) => {
  const match21 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match21(input);
}, "typeTags");
var withReturnType = /* @__PURE__ */ __name(() => (self2) => self2, "withReturnType");
var when5 = /* @__PURE__ */ __name((pattern2, f) => (self2) => self2.add(makeWhen(makePredicate(pattern2), f)), "when");
var whenOr = /* @__PURE__ */ __name((...args2) => (self2) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self2.add(makeWhen(makeOrPredicate(patterns), onMatch));
}, "whenOr");
var whenAnd = /* @__PURE__ */ __name((...args2) => (self2) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self2.add(makeWhen(makeAndPredicate(patterns), onMatch));
}, "whenAnd");
var discriminator = /* @__PURE__ */ __name((field) => (...pattern2) => {
  const f = pattern2[pattern2.length - 1];
  const values6 = pattern2.slice(0, -1);
  const pred = values6.length === 1 ? (_) => _[field] === values6[0] : (_) => values6.includes(_[field]);
  return (self2) => self2.add(makeWhen(pred, f));
}, "discriminator");
var discriminatorStartsWith = /* @__PURE__ */ __name((field) => (pattern2, f) => {
  const pred = /* @__PURE__ */ __name((_) => typeof _[field] === "string" && _[field].startsWith(pattern2), "pred");
  return (self2) => self2.add(makeWhen(pred, f));
}, "discriminatorStartsWith");
var discriminators = /* @__PURE__ */ __name((field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self2) => self2.add(predicate);
}, "discriminators");
var discriminatorsExhaustive = /* @__PURE__ */ __name((field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
}, "discriminatorsExhaustive");
var tag3 = /* @__PURE__ */ discriminator("_tag");
var tagStartsWith = /* @__PURE__ */ discriminatorStartsWith("_tag");
var tags = /* @__PURE__ */ discriminators("_tag");
var tagsExhaustive = /* @__PURE__ */ discriminatorsExhaustive("_tag");
var not3 = /* @__PURE__ */ __name((pattern2, f) => (self2) => self2.add(makeNot(makePredicate(pattern2), f)), "not");
var nonEmptyString3 = /* @__PURE__ */ __name((u) => typeof u === "string" && u.length > 0, "nonEmptyString");
var is2 = /* @__PURE__ */ __name((...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
}, "is");
var any = /* @__PURE__ */ __name(() => true, "any");
var defined = /* @__PURE__ */ __name((u) => u !== void 0 && u !== null, "defined");
var instanceOf2 = /* @__PURE__ */ __name((constructor) => (u) => u instanceof constructor, "instanceOf");
var orElse14 = /* @__PURE__ */ __name((f) => (self2) => {
  const result = either7(self2);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
}, "orElse");
var orElseAbsurd = /* @__PURE__ */ __name((self2) => orElse14(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self2), "orElseAbsurd");
var either7 = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "ValueMatcher") {
    return self2.value;
  }
  const len = self2.cases.length;
  if (len === 1) {
    const _case = self2.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case = self2.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
}, "either");
var option5 = /* @__PURE__ */ __name((self2) => {
  const toEither = either7(self2);
  if (isEither2(toEither)) {
    return match(toEither, {
      onLeft: () => none2(),
      onRight: some3
    });
  }
  return (input) => match(toEither(input), {
    onLeft: () => none2(),
    onRight: some3
  });
}, "option");
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = /* @__PURE__ */ __name((self2) => {
  const toEither = either7(self2);
  if (isEither2(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
}, "exhaustive");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId28;
var type2 = type;
var value4 = value3;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var withReturnType2 = withReturnType;
var when6 = when5;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag4 = tag3;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not4 = not3;
var nonEmptyString4 = nonEmptyString3;
var is3 = is2;
var string6 = isString;
var number5 = isNumber;
var any2 = any;
var defined2 = defined;
var boolean3 = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint2 = isBigInt;
var symbol4 = isSymbol;
var date3 = isDate;
var record3 = isRecord;
var instanceOf3 = instanceOf2;
var instanceOfUnsafe = instanceOf2;
var orElse15 = orElse14;
var orElseAbsurd2 = orElseAbsurd;
var either8 = either7;
var option6 = option5;
var exhaustive2 = exhaustive;
var SafeRefinementId = /* @__PURE__ */ Symbol.for("effect/SafeRefinement");

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Metric.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var unsafeSnapshot2 = unsafeSnapshot;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MetricState.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RuntimeFlags.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Interruption2 = Interruption;
var disable4 = disable2;

// node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Unify.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var unify2 = identity;

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/Rpc.js
var Rpc_exports = {};
__export(Rpc_exports, {
  TypeId: () => TypeId29,
  WrapperTypeId: () => WrapperTypeId,
  exitSchema: () => exitSchema2,
  fork: () => fork4,
  fromTaggedRequest: () => fromTaggedRequest,
  isRpc: () => isRpc,
  isWrapper: () => isWrapper,
  make: () => make69,
  uninterruptible: () => uninterruptible3,
  wrap: () => wrap
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  Stream: () => Stream2,
  StreamSchemaId: () => StreamSchemaId,
  getStreamSchemas: () => getStreamSchemas,
  isStreamSchema: () => isStreamSchema,
  isStreamSerializable: () => isStreamSerializable
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var StreamSchemaId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcSchema/Stream");
var isStreamSchema = /* @__PURE__ */ __name((schema3) => schema3.ast.annotations[SchemaIdAnnotationId] === StreamSchemaId, "isStreamSchema");
var isStreamSerializable = /* @__PURE__ */ __name((schema3) => isStreamSchema(successSchema(schema3)), "isStreamSerializable");
var getStreamSchemas = /* @__PURE__ */ __name((ast) => ast.annotations[StreamSchemaId] ? some3(ast.annotations[StreamSchemaId]) : none2(), "getStreamSchemas");
var Stream2 = /* @__PURE__ */ __name(({
  failure,
  success
}) => Object.assign(declare([success, failure], {
  decode: (success2, failure2) => parseStream(decodeUnknown2(ChunkFromSelf(success2)), decodeUnknown2(failure2)),
  encode: (success2, failure2) => parseStream(encodeUnknown(ChunkFromSelf(success2)), encodeUnknown(failure2))
}, {
  schemaId: StreamSchemaId,
  [StreamSchemaId]: {
    success,
    failure
  }
}), {
  success,
  failure
}), "Stream");
var isStream2 = /* @__PURE__ */ __name((u) => hasProperty(u, StreamTypeId3), "isStream");
var parseStream = /* @__PURE__ */ __name((decodeSuccess, decodeFailure) => (u, options4, ast) => flatMap14(context3(), (context11) => {
  if (!isStream2(u))
    return fail10(new Type2(ast, u));
  return succeed10(u.pipe(mapChunksEffect2((value6) => decodeSuccess(value6, options4)), catchAll8((error3) => {
    if (isParseError(error3))
      return die13(error3);
    return matchEffect3(decodeFailure(error3, options4), {
      onFailure: die7,
      onSuccess: fail10
    });
  }), provideContext7(context11)));
}), "parseStream");

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/Rpc.js
var TypeId29 = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc");
var isRpc = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId29), "isRpc");
var Proto4 = {
  [TypeId29]: TypeId29,
  pipe() {
    return pipeArguments(this, arguments);
  },
  setSuccess(successSchema2) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: successSchema2,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  setError(errorSchema) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  setPayload(payloadSchema) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: isSchema(payloadSchema) ? payloadSchema : Struct(payloadSchema),
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  middleware(middleware2) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: /* @__PURE__ */ new Set([...this.middlewares, middleware2])
    });
  },
  prefix(prefix3) {
    return makeProto({
      _tag: `${prefix3}${this._tag}`,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  annotate(tag8, value6) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      middlewares: this.middlewares,
      annotations: add4(this.annotations, tag8, value6)
    });
  },
  annotateContext(context11) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      middlewares: this.middlewares,
      annotations: merge3(this.annotations, context11)
    });
  }
};
var makeProto = /* @__PURE__ */ __name((options4) => {
  function Rpc() {
  }
  __name(Rpc, "Rpc");
  Object.setPrototypeOf(Rpc, Proto4);
  Object.assign(Rpc, options4);
  Rpc.key = `@effect/rpc/Rpc/${options4._tag}`;
  return Rpc;
}, "makeProto");
var make69 = /* @__PURE__ */ __name((tag8, options4) => {
  const successSchema2 = options4?.success ?? Void;
  const errorSchema = options4?.error ?? Never;
  let payloadSchema;
  if (options4?.primaryKey) {
    payloadSchema = /* @__PURE__ */ __name(class Payload extends Class6(`@effect/rpc/Rpc/${tag8}`)(options4.payload) {
      [symbol3]() {
        return options4.primaryKey(this);
      }
    }, "Payload");
  } else {
    payloadSchema = isSchema(options4?.payload) ? options4?.payload : options4?.payload ? Struct(options4?.payload) : Void;
  }
  return makeProto({
    _tag: tag8,
    payloadSchema,
    successSchema: options4?.stream ? Stream2({
      success: successSchema2,
      failure: errorSchema
    }) : successSchema2,
    errorSchema: options4?.stream ? Never : errorSchema,
    annotations: empty9(),
    middlewares: /* @__PURE__ */ new Set()
  });
}, "make");
var fromTaggedRequest = /* @__PURE__ */ __name((schema3) => makeProto({
  _tag: schema3._tag,
  payloadSchema: schema3,
  successSchema: schema3.success,
  errorSchema: schema3.failure,
  annotations: empty9(),
  middlewares: /* @__PURE__ */ new Set()
}), "fromTaggedRequest");
var exitSchemaCache2 = /* @__PURE__ */ globalValue("@effect/rpc/Rpc/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema2 = /* @__PURE__ */ __name((self2) => {
  if (exitSchemaCache2.has(self2)) {
    return exitSchemaCache2.get(self2);
  }
  const rpc = self2;
  const failures3 = /* @__PURE__ */ new Set([rpc.errorSchema]);
  const streamSchemas = getStreamSchemas(rpc.successSchema.ast);
  if (isSome2(streamSchemas)) {
    failures3.add(streamSchemas.value.failure);
  }
  for (const middleware2 of rpc.middlewares) {
    failures3.add(middleware2.failure);
  }
  const schema3 = Exit({
    success: isSome2(streamSchemas) ? Void : rpc.successSchema,
    failure: Union2(...failures3),
    defect: Defect
  });
  exitSchemaCache2.set(self2, schema3);
  return schema3;
}, "exitSchema");
var WrapperTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc/Wrapper");
var isWrapper = /* @__PURE__ */ __name((u) => WrapperTypeId in u, "isWrapper");
var wrap = /* @__PURE__ */ __name((options4) => (value6) => isWrapper(value6) ? {
  [WrapperTypeId]: WrapperTypeId,
  value: value6.value,
  fork: options4.fork ?? value6.fork,
  uninterruptible: options4.uninterruptible ?? value6.uninterruptible
} : {
  [WrapperTypeId]: WrapperTypeId,
  value: value6,
  fork: options4.fork ?? false,
  uninterruptible: options4.uninterruptible ?? false
}, "wrap");
var fork4 = /* @__PURE__ */ wrap({
  fork: true
});
var uninterruptible3 = /* @__PURE__ */ wrap({
  uninterruptible: true
});

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcGroup.js
var RpcGroup_exports = {};
__export(RpcGroup_exports, {
  TypeId: () => TypeId30,
  make: () => make70
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId30 = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcGroup");
var RpcGroupProto = {
  add(...rpcs) {
    return makeProto2({
      requests: resolveInput(...this.requests.values(), ...rpcs),
      annotations: this.annotations
    });
  },
  merge(...groups) {
    const requests = new Map(this.requests);
    const annotations3 = new Map(this.annotations.unsafeMap);
    for (const group2 of groups) {
      for (const [tag8, rpc] of group2.requests) {
        requests.set(tag8, rpc);
      }
      for (const [key, value6] of group2.annotations.unsafeMap) {
        annotations3.set(key, value6);
      }
    }
    return makeProto2({
      requests,
      annotations: unsafeMake(annotations3)
    });
  },
  middleware(middleware2) {
    const requests = /* @__PURE__ */ new Map();
    for (const [tag8, rpc] of this.requests) {
      requests.set(tag8, rpc.middleware(middleware2));
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  },
  toHandlersContext(build3) {
    return gen3(this, function* () {
      const context11 = yield* context3();
      const handlers = isEffect2(build3) ? yield* build3 : build3;
      const contextMap = /* @__PURE__ */ new Map();
      for (const [tag8, handler] of Object.entries(handlers)) {
        const rpc = this.requests.get(tag8);
        contextMap.set(rpc.key, {
          handler,
          context: context11
        });
      }
      return unsafeMake(contextMap);
    });
  },
  prefix(prefix3) {
    const requests = /* @__PURE__ */ new Map();
    for (const rpc of this.requests.values()) {
      const newRpc = rpc.prefix(prefix3);
      requests.set(newRpc._tag, newRpc);
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  },
  toLayer(build3) {
    return scopedContext2(this.toHandlersContext(build3));
  },
  of: identity,
  toLayerHandler(tag8, build3) {
    return scopedContext2(gen3(this, function* () {
      const context11 = yield* context3();
      const handler = isEffect2(build3) ? yield* build3 : build3;
      const contextMap = /* @__PURE__ */ new Map();
      const rpc = this.requests.get(tag8);
      contextMap.set(rpc.key, {
        handler,
        context: context11
      });
      return unsafeMake(contextMap);
    }));
  },
  accessHandler(tag8) {
    return contextWith2((parentContext) => {
      const rpc = this.requests.get(tag8);
      const {
        context: context11,
        handler
      } = parentContext.unsafeMap.get(rpc.key);
      return (payload, options4) => {
        const result = handler(payload, options4);
        const effectOrStream = isWrapper(result) ? result.value : result;
        return isEffect2(effectOrStream) ? provide2(effectOrStream, context11) : provideContext7(effectOrStream, context11);
      };
    });
  },
  annotate(tag8, value6) {
    return makeProto2({
      requests: this.requests,
      annotations: add4(this.annotations, tag8, value6)
    });
  },
  annotateRpcs(tag8, value6) {
    return this.annotateRpcsContext(make10(tag8, value6));
  },
  annotateContext(context11) {
    return makeProto2({
      requests: this.requests,
      annotations: merge3(this.annotations, context11)
    });
  },
  annotateRpcsContext(context11) {
    const requests = /* @__PURE__ */ new Map();
    for (const [tag8, rpc] of this.requests) {
      requests.set(tag8, rpc.annotateContext(merge3(context11, rpc.annotations)));
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  }
};
var makeProto2 = /* @__PURE__ */ __name((options4) => Object.assign(function() {
}, RpcGroupProto, {
  requests: options4.requests,
  annotations: options4.annotations
}), "makeProto");
var resolveInput = /* @__PURE__ */ __name((...rpcs) => {
  const requests = /* @__PURE__ */ new Map();
  for (const rpc of rpcs) {
    requests.set(rpc._tag, isSchema(rpc) ? fromTaggedRequest(rpc) : rpc);
  }
  return requests;
}, "resolveInput");
var make70 = /* @__PURE__ */ __name((...rpcs) => makeProto2({
  requests: resolveInput(...rpcs),
  annotations: empty9()
}), "make");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Headers.js
var Headers_exports = {};
__export(Headers_exports, {
  HeadersTypeId: () => HeadersTypeId,
  currentRedactedNames: () => currentRedactedNames,
  empty: () => empty36,
  fromInput: () => fromInput3,
  get: () => get18,
  has: () => has10,
  isHeaders: () => isHeaders,
  merge: () => merge11,
  redact: () => redact2,
  remove: () => remove11,
  schema: () => schema,
  schemaFromSelf: () => schemaFromSelf,
  set: () => set11,
  setAll: () => setAll3,
  unsafeFromRecord: () => unsafeFromRecord
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var HeadersTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Headers");
var isHeaders = /* @__PURE__ */ __name((u) => hasProperty(u, HeadersTypeId), "isHeaders");
var Proto5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  [HeadersTypeId]: HeadersTypeId,
  [symbolRedactable](fiberRefs3) {
    return redact2(this, getOrDefault2(fiberRefs3, currentRedactedNames));
  }
});
var make71 = /* @__PURE__ */ __name((input) => Object.assign(Object.create(Proto5), input), "make");
var schemaFromSelf = /* @__PURE__ */ declare(isHeaders, {
  identifier: "Headers",
  equivalence: () => getEquivalence3(Equivalence3)
});
var schema = /* @__PURE__ */ transform2(/* @__PURE__ */ Record({
  key: String$,
  value: String$
}), schemaFromSelf, {
  strict: true,
  decode: (record4) => fromInput3(record4),
  encode: identity
});
var empty36 = /* @__PURE__ */ Object.create(Proto5);
var fromInput3 = /* @__PURE__ */ __name((input) => {
  if (input === void 0) {
    return empty36;
  } else if (Symbol.iterator in input) {
    const out2 = Object.create(Proto5);
    for (const [k, v] of input) {
      out2[k.toLowerCase()] = v;
    }
    return out2;
  }
  const out = Object.create(Proto5);
  for (const [k, v] of Object.entries(input)) {
    if (Array.isArray(v)) {
      out[k.toLowerCase()] = v.join(", ");
    } else if (v !== void 0) {
      out[k.toLowerCase()] = v;
    }
  }
  return out;
}, "fromInput");
var unsafeFromRecord = /* @__PURE__ */ __name((input) => Object.setPrototypeOf(input, Proto5), "unsafeFromRecord");
var has10 = /* @__PURE__ */ dual(2, (self2, key) => key.toLowerCase() in self2);
var get18 = /* @__PURE__ */ dual(2, (self2, key) => get(self2, key.toLowerCase()));
var set11 = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  const out = make71(self2);
  out[key.toLowerCase()] = value6;
  return out;
});
var setAll3 = /* @__PURE__ */ dual(2, (self2, headers) => make71({
  ...self2,
  ...fromInput3(headers)
}));
var merge11 = /* @__PURE__ */ dual(2, (self2, headers) => {
  const out = make71(self2);
  Object.assign(out, headers);
  return out;
});
var remove11 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = make71(self2);
  const modify10 = /* @__PURE__ */ __name((key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        delete out[k];
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          delete out[name];
        }
      }
    }
  }, "modify");
  if (Array.isArray(key)) {
    for (let i = 0; i < key.length; i++) {
      modify10(key[i]);
    }
  } else {
    modify10(key);
  }
  return out;
});
var redact2 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = {
    ...self2
  };
  const modify10 = /* @__PURE__ */ __name((key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        out[k] = make46(self2[k]);
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          out[name] = make46(self2[name]);
        }
      }
    }
  }, "modify");
  if (Array.isArray(key)) {
    for (let i = 0; i < key.length; i++) {
      modify10(key[i]);
    }
  } else {
    modify10(key);
  }
  return out;
});
var currentRedactedNames = /* @__PURE__ */ globalValue("@effect/platform/Headers/currentRedactedNames", () => unsafeMake12(["authorization", "cookie", "set-cookie", "x-api-key"]));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpBody.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpBody.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/UrlParams.js
var UrlParams_exports = {};
__export(UrlParams_exports, {
  append: () => append4,
  appendAll: () => appendAll4,
  empty: () => empty37,
  fromInput: () => fromInput4,
  getAll: () => getAll,
  getFirst: () => getFirst,
  getLast: () => getLast,
  makeUrl: () => makeUrl,
  remove: () => remove12,
  schemaFromSelf: () => schemaFromSelf2,
  schemaFromString: () => schemaFromString,
  schemaJson: () => schemaJson,
  schemaParse: () => schemaParse,
  schemaRecord: () => schemaRecord,
  schemaStruct: () => schemaStruct,
  set: () => set12,
  setAll: () => setAll4,
  toRecord: () => toRecord,
  toString: () => toString
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var fromInput4 = /* @__PURE__ */ __name((input) => {
  const parsed = fromInputNested(input);
  const out = [];
  for (let i = 0; i < parsed.length; i++) {
    if (Array.isArray(parsed[i][0])) {
      const [keys6, value6] = parsed[i];
      out.push([`${keys6[0]}[${keys6.slice(1).join("][")}]`, value6]);
    } else {
      out.push(parsed[i]);
    }
  }
  return out;
}, "fromInput");
var fromInputNested = /* @__PURE__ */ __name((input) => {
  const entries3 = Symbol.iterator in input ? fromIterable2(input) : Object.entries(input);
  const out = [];
  for (const [key, value6] of entries3) {
    if (Array.isArray(value6)) {
      for (let i = 0; i < value6.length; i++) {
        if (value6[i] !== void 0) {
          out.push([key, String(value6[i])]);
        }
      }
    } else if (typeof value6 === "object") {
      const nested3 = fromInputNested(value6);
      for (const [k, v] of nested3) {
        out.push([[key, ...typeof k === "string" ? [k] : k], v]);
      }
    } else if (value6 !== void 0) {
      out.push([key, String(value6)]);
    }
  }
  return out;
}, "fromInputNested");
var schemaFromSelf2 = /* @__PURE__ */ Array$(Tuple(String$, String$)).annotations({
  identifier: "UrlParams"
});
var empty37 = [];
var getAll = /* @__PURE__ */ dual(2, (self2, key) => reduce(self2, [], (acc, [k, value6]) => {
  if (k === key) {
    acc.push(value6);
  }
  return acc;
}));
var getFirst = /* @__PURE__ */ dual(2, (self2, key) => map2(findFirst2(self2, ([k]) => k === key), ([, value6]) => value6));
var getLast = /* @__PURE__ */ dual(2, (self2, key) => map2(findLast(self2, ([k]) => k === key), ([, value6]) => value6));
var set12 = /* @__PURE__ */ dual(3, (self2, key, value6) => append(filter2(self2, ([k]) => k !== key), [key, String(value6)]));
var setAll4 = /* @__PURE__ */ dual(2, (self2, input) => {
  const toSet4 = fromInput4(input);
  const keys6 = toSet4.map(([k]) => k);
  return appendAll(filter2(self2, ([k]) => keys6.includes(k)), toSet4);
});
var append4 = /* @__PURE__ */ dual(3, (self2, key, value6) => append(self2, [key, String(value6)]));
var appendAll4 = /* @__PURE__ */ dual(2, (self2, input) => appendAll(self2, fromInput4(input)));
var remove12 = /* @__PURE__ */ dual(2, (self2, key) => filter2(self2, ([k]) => k !== key));
var makeUrl = /* @__PURE__ */ __name((url2, params2, hash5) => {
  try {
    const urlInstance = new URL(url2, baseUrl());
    for (let i = 0; i < params2.length; i++) {
      const [key, value6] = params2[i];
      if (value6 !== void 0) {
        urlInstance.searchParams.append(key, value6);
      }
    }
    if (hash5._tag === "Some") {
      urlInstance.hash = hash5.value;
    }
    return right2(urlInstance);
  } catch (e) {
    return left2(e);
  }
}, "makeUrl");
var toString = /* @__PURE__ */ __name((self2) => new URLSearchParams(self2).toString(), "toString");
var baseUrl = /* @__PURE__ */ __name(() => {
  if ("location" in globalThis && globalThis.location !== void 0 && globalThis.location.origin !== void 0 && globalThis.location.pathname !== void 0) {
    return location.origin + location.pathname;
  }
  return void 0;
}, "baseUrl");
var toRecord = /* @__PURE__ */ __name((self2) => {
  const out = /* @__PURE__ */ Object.create(null);
  for (const [k, value6] of self2) {
    const curr = out[k];
    if (curr === void 0) {
      out[k] = value6;
    } else if (typeof curr === "string") {
      out[k] = [curr, value6];
    } else {
      curr.push(value6);
    }
  }
  return {
    ...out
  };
}, "toRecord");
var schemaJson = /* @__PURE__ */ __name((schema3, options4) => {
  const parse4 = decodeUnknown3(parseJson(schema3), options4);
  return dual(2, (self2, field) => parse4(getOrElse(getLast(self2, field), () => "")));
}, "schemaJson");
var schemaStruct = /* @__PURE__ */ __name((schema3, options4) => (self2) => {
  const parse4 = decodeUnknown3(schema3, options4);
  return parse4(toRecord(self2));
}, "schemaStruct");
var schemaFromString = /* @__PURE__ */ transform2(String$, schemaFromSelf2, {
  decode(fromA) {
    return fromInput4(new URLSearchParams(fromA));
  },
  encode(toI) {
    return toString(toI);
  }
});
var schemaRecord = /* @__PURE__ */ __name((schema3) => transform2(schemaFromSelf2, schema3, {
  decode(fromA) {
    return toRecord(fromA);
  },
  encode(toI) {
    return fromInput4(toI);
  }
}), "schemaRecord");
var schemaParse = /* @__PURE__ */ __name((schema3) => compose3(schemaFromString, schemaRecord(schema3)), "schemaParse");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpBody.js
var TypeId31 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpBody");
var BodyBase = class {
  [TypeId31];
  constructor() {
    this[TypeId31] = TypeId31;
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  toString() {
    return format(this);
  }
};
__name(BodyBase, "BodyBase");
var EmptyImpl = class extends BodyBase {
  _tag = "Empty";
  toJSON() {
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Empty"
    };
  }
};
__name(EmptyImpl, "EmptyImpl");
var empty38 = /* @__PURE__ */ new EmptyImpl();
var Uint8ArrayImpl = class extends BodyBase {
  body;
  contentType;
  _tag = "Uint8Array";
  constructor(body, contentType) {
    super();
    this.body = body;
    this.contentType = contentType;
  }
  get contentLength() {
    return this.body.length;
  }
  toJSON() {
    const toString5 = this.contentType.startsWith("text/") || this.contentType.endsWith("json");
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Uint8Array",
      body: toString5 ? new TextDecoder().decode(this.body) : `Uint8Array(${this.body.length})`,
      contentType: this.contentType,
      contentLength: this.contentLength
    };
  }
};
__name(Uint8ArrayImpl, "Uint8ArrayImpl");
var uint8Array2 = /* @__PURE__ */ __name((body, contentType) => new Uint8ArrayImpl(body, contentType ?? "application/octet-stream"), "uint8Array");
var encoder2 = /* @__PURE__ */ new TextEncoder();
var text = /* @__PURE__ */ __name((body, contentType) => uint8Array2(encoder2.encode(body), contentType ?? "text/plain"), "text");
var unsafeJson = /* @__PURE__ */ __name((body) => text(JSON.stringify(body), "application/json"), "unsafeJson");
var StreamImpl2 = class extends BodyBase {
  stream;
  contentType;
  contentLength;
  _tag = "Stream";
  constructor(stream6, contentType, contentLength) {
    super();
    this.stream = stream6;
    this.contentType = contentType;
    this.contentLength = contentLength;
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Stream",
      contentType: this.contentType,
      contentLength: this.contentLength
    };
  }
};
__name(StreamImpl2, "StreamImpl");
var stream2 = /* @__PURE__ */ __name((body, contentType, contentLength) => new StreamImpl2(body, contentType ?? "application/octet-stream", contentLength), "stream");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpBody.js
var stream3 = stream2;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpClient.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpClient.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Cookies.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId32 = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies");
var CookieTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies/Cookie");
var Proto6 = {
  [TypeId32]: TypeId32,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies",
      cookies: map3(this.cookies, (cookie) => cookie.toJSON())
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromReadonlyRecord = /* @__PURE__ */ __name((cookies) => {
  const self2 = Object.create(Proto6);
  self2.cookies = cookies;
  return self2;
}, "fromReadonlyRecord");
var fromIterable16 = /* @__PURE__ */ __name((cookies) => {
  const record4 = {};
  for (const cookie of cookies) {
    record4[cookie.name] = cookie;
  }
  return fromReadonlyRecord(record4);
}, "fromIterable");
var fromSetCookie = /* @__PURE__ */ __name((headers) => {
  const arrayHeaders = typeof headers === "string" ? [headers] : headers;
  const cookies = [];
  for (const header of arrayHeaders) {
    const cookie = parseSetCookie(header.trim());
    if (isSome2(cookie)) {
      cookies.push(cookie.value);
    }
  }
  return fromIterable16(cookies);
}, "fromSetCookie");
function parseSetCookie(header) {
  const parts2 = header.split(";").map((_) => _.trim()).filter((_) => _ !== "");
  if (parts2.length === 0) {
    return none2();
  }
  const firstEqual = parts2[0].indexOf("=");
  if (firstEqual === -1) {
    return none2();
  }
  const name = parts2[0].slice(0, firstEqual);
  if (!fieldContentRegExp.test(name)) {
    return none2();
  }
  const valueEncoded = parts2[0].slice(firstEqual + 1);
  const value6 = tryDecodeURIComponent(valueEncoded);
  if (parts2.length === 1) {
    return some3(Object.assign(Object.create(CookieProto), {
      name,
      value: value6,
      valueEncoded
    }));
  }
  const options4 = {};
  for (let i = 1; i < parts2.length; i++) {
    const part = parts2[i];
    const equalIndex = part.indexOf("=");
    const key = equalIndex === -1 ? part : part.slice(0, equalIndex).trim();
    const value7 = equalIndex === -1 ? void 0 : part.slice(equalIndex + 1).trim();
    switch (key.toLowerCase()) {
      case "domain": {
        if (value7 === void 0) {
          break;
        }
        const domain2 = value7.trim().replace(/^\./, "");
        if (domain2) {
          options4.domain = domain2;
        }
        break;
      }
      case "expires": {
        if (value7 === void 0) {
          break;
        }
        const date4 = new Date(value7);
        if (!isNaN(date4.getTime())) {
          options4.expires = date4;
        }
        break;
      }
      case "max-age": {
        if (value7 === void 0) {
          break;
        }
        const maxAge = parseInt(value7, 10);
        if (!isNaN(maxAge)) {
          options4.maxAge = seconds(maxAge);
        }
        break;
      }
      case "path": {
        if (value7 === void 0) {
          break;
        }
        if (value7[0] === "/") {
          options4.path = value7;
        }
        break;
      }
      case "priority": {
        if (value7 === void 0) {
          break;
        }
        switch (value7.toLowerCase()) {
          case "low":
            options4.priority = "low";
            break;
          case "medium":
            options4.priority = "medium";
            break;
          case "high":
            options4.priority = "high";
            break;
        }
        break;
      }
      case "httponly": {
        options4.httpOnly = true;
        break;
      }
      case "secure": {
        options4.secure = true;
        break;
      }
      case "partitioned": {
        options4.partitioned = true;
        break;
      }
      case "samesite": {
        if (value7 === void 0) {
          break;
        }
        switch (value7.toLowerCase()) {
          case "lax":
            options4.sameSite = "lax";
            break;
          case "strict":
            options4.sameSite = "strict";
            break;
          case "none":
            options4.sameSite = "none";
            break;
        }
        break;
      }
    }
  }
  return some3(Object.assign(Object.create(CookieProto), {
    name,
    value: value6,
    valueEncoded,
    options: Object.keys(options4).length > 0 ? options4 : void 0
  }));
}
__name(parseSetCookie, "parseSetCookie");
var empty39 = /* @__PURE__ */ fromIterable16([]);
var isEmpty16 = /* @__PURE__ */ __name((self2) => isEmptyRecord(self2.cookies), "isEmpty");
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var CookieProto = {
  [CookieTypeId]: CookieTypeId,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies/Cookie",
      name: this.name,
      value: this.value,
      options: this.options
    };
  }
};
function serializeCookie(self2) {
  let str = self2.name + "=" + self2.valueEncoded;
  if (self2.options === void 0) {
    return str;
  }
  const options4 = self2.options;
  if (options4.maxAge !== void 0) {
    const maxAge = toSeconds(options4.maxAge);
    str += "; Max-Age=" + Math.trunc(maxAge);
  }
  if (options4.domain !== void 0) {
    str += "; Domain=" + options4.domain;
  }
  if (options4.path !== void 0) {
    str += "; Path=" + options4.path;
  }
  if (options4.priority !== void 0) {
    switch (options4.priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
    }
  }
  if (options4.expires !== void 0) {
    str += "; Expires=" + options4.expires.toUTCString();
  }
  if (options4.httpOnly) {
    str += "; HttpOnly";
  }
  if (options4.secure) {
    str += "; Secure";
  }
  if (options4.partitioned) {
    str += "; Partitioned";
  }
  if (options4.sameSite !== void 0) {
    switch (options4.sameSite) {
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
    }
  }
  return str;
}
__name(serializeCookie, "serializeCookie");
var toSetCookieHeaders = /* @__PURE__ */ __name((self2) => Object.values(self2.cookies).map(serializeCookie), "toSetCookieHeaders");
function parseHeader(header) {
  const result = {};
  const strLen = header.length;
  let pos = 0;
  let terminatorPos = 0;
  while (true) {
    if (terminatorPos === strLen)
      break;
    terminatorPos = header.indexOf(";", pos);
    if (terminatorPos === -1)
      terminatorPos = strLen;
    let eqIdx = header.indexOf("=", pos);
    if (eqIdx === -1)
      break;
    if (eqIdx > terminatorPos) {
      pos = terminatorPos + 1;
      continue;
    }
    const key = header.substring(pos, eqIdx++).trim();
    if (result[key] === void 0) {
      const val = header.charCodeAt(eqIdx) === 34 ? header.substring(eqIdx + 1, terminatorPos - 1).trim() : header.substring(eqIdx, terminatorPos).trim();
      result[key] = !(val.indexOf("%") === -1) ? tryDecodeURIComponent(val) : val;
    }
    pos = terminatorPos + 1;
  }
  return result;
}
__name(parseHeader, "parseHeader");
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => {
  try {
    return decodeURIComponent(str);
  } catch {
    return str;
  }
}, "tryDecodeURIComponent");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpClientError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpClientError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId33 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientError");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpClientError.js
var TypeId34 = TypeId33;
var isHttpClientError = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId34), "isHttpClientError");
var RequestError = class extends (/* @__PURE__ */ TypeIdError(TypeId34, "RequestError")) {
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    return this.description ? `${this.reason}: ${this.description} (${this.methodAndUrl})` : `${this.reason} error (${this.methodAndUrl})`;
  }
};
__name(RequestError, "RequestError");
var ResponseError = class extends (/* @__PURE__ */ TypeIdError(TypeId34, "ResponseError")) {
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    const info2 = `${this.response.status} ${this.methodAndUrl}`;
    return this.description ? `${this.reason}: ${this.description} (${info2})` : `${this.reason} error (${info2})`;
  }
};
__name(ResponseError, "ResponseError");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpIncomingMessage.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId35 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpIncomingMessage");
var MaxBodySize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/HttpIncomingMessage/MaxBodySize", {
  defaultValue: none2
})) {
};
__name(MaxBodySize, "MaxBodySize");
var inspect = /* @__PURE__ */ __name((self2, that) => {
  const contentType = self2.headers["content-type"] ?? "";
  let body;
  if (contentType.includes("application/json")) {
    try {
      body = runSync(self2.json);
    } catch {
    }
  } else if (contentType.includes("text/") || contentType.includes("urlencoded")) {
    try {
      body = runSync(self2.text);
    } catch {
    }
  }
  const obj = {
    ...that,
    headers: redact(self2.headers),
    remoteAddress: self2.remoteAddress.toJSON()
  };
  if (body !== void 0) {
    obj.body = body;
  }
  return obj;
}, "inspect");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpTraceContext.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var toHeaders = /* @__PURE__ */ __name((span4) => unsafeFromRecord({
  b3: `${span4.traceId}-${span4.spanId}-${span4.sampled ? "1" : "0"}${span4.parent._tag === "Some" ? `-${span4.parent.value.spanId}` : ""}`,
  traceparent: `00-${span4.traceId}-${span4.spanId}-${span4.sampled ? "01" : "00"}`
}), "toHeaders");
var fromHeaders = /* @__PURE__ */ __name((headers) => {
  let span4 = w3c(headers);
  if (span4._tag === "Some") {
    return span4;
  }
  span4 = b3(headers);
  if (span4._tag === "Some") {
    return span4;
  }
  return xb3(headers);
}, "fromHeaders");
var b3 = /* @__PURE__ */ __name((headers) => {
  if (!("b3" in headers)) {
    return none2();
  }
  const parts2 = headers["b3"].split("-");
  if (parts2.length < 2) {
    return none2();
  }
  return some3(externalSpan2({
    traceId: parts2[0],
    spanId: parts2[1],
    sampled: parts2[2] ? parts2[2] === "1" : true
  }));
}, "b3");
var xb3 = /* @__PURE__ */ __name((headers) => {
  if (!headers["x-b3-traceid"] || !headers["x-b3-spanid"]) {
    return none2();
  }
  return some3(externalSpan2({
    traceId: headers["x-b3-traceid"],
    spanId: headers["x-b3-spanid"],
    sampled: headers["x-b3-sampled"] ? headers["x-b3-sampled"] === "1" : true
  }));
}, "xb3");
var w3cTraceId = /^[0-9a-f]{32}$/i;
var w3cSpanId = /^[0-9a-f]{16}$/i;
var w3c = /* @__PURE__ */ __name((headers) => {
  if (!headers["traceparent"]) {
    return none2();
  }
  const parts2 = headers["traceparent"].split("-");
  if (parts2.length !== 4) {
    return none2();
  }
  const [version, traceId, spanId, flags] = parts2;
  switch (version) {
    case "00": {
      if (w3cTraceId.test(traceId) === false || w3cSpanId.test(spanId) === false) {
        return none2();
      }
      return some3(externalSpan2({
        traceId,
        spanId,
        sampled: (parseInt(flags, 16) & 1) === 1
      }));
    }
    default: {
      return none2();
    }
  }
}, "w3c");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpClientRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId36 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientRequest");
var Proto7 = {
  [TypeId36]: TypeId36,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClientRequest",
      method: this.method,
      url: this.url,
      urlParams: this.urlParams,
      hash: this.hash,
      headers: redact(this.headers),
      body: this.body.toJSON()
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeInternal(method, url2, urlParams3, hash5, headers, body) {
  const self2 = Object.create(Proto7);
  self2.method = method;
  self2.url = url2;
  self2.urlParams = urlParams3;
  self2.hash = hash5;
  self2.headers = headers;
  self2.body = body;
  return self2;
}
__name(makeInternal, "makeInternal");
var empty40 = /* @__PURE__ */ makeInternal("GET", "", empty37, /* @__PURE__ */ none2(), empty36, empty38);
var make72 = /* @__PURE__ */ __name((method) => (url2, options4) => modify9(empty40, {
  method,
  url: url2,
  ...options4 ?? void 0
}), "make");
var get19 = /* @__PURE__ */ make72("GET");
var post = /* @__PURE__ */ make72("POST");
var put = /* @__PURE__ */ make72("PUT");
var patch9 = /* @__PURE__ */ make72("PATCH");
var del = /* @__PURE__ */ make72("DELETE");
var head7 = /* @__PURE__ */ make72("HEAD");
var options = /* @__PURE__ */ make72("OPTIONS");
var modify9 = /* @__PURE__ */ dual(2, (self2, options4) => {
  let result = self2;
  if (options4.method) {
    result = setMethod(result, options4.method);
  }
  if (options4.url) {
    result = setUrl(result, options4.url);
  }
  if (options4.headers) {
    result = setHeaders(result, options4.headers);
  }
  if (options4.urlParams) {
    result = setUrlParams(result, options4.urlParams);
  }
  if (options4.hash) {
    result = setHash(result, options4.hash);
  }
  if (options4.body) {
    result = setBody(result, options4.body);
  }
  if (options4.accept) {
    result = accept(result, options4.accept);
  }
  if (options4.acceptJson) {
    result = acceptJson(result);
  }
  return result;
});
var setHeader = /* @__PURE__ */ dual(3, (self2, key, value6) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, set11(self2.headers, key, value6), self2.body));
var setHeaders = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, setAll3(self2.headers, input), self2.body));
var accept = /* @__PURE__ */ dual(2, (self2, mediaType) => setHeader(self2, "Accept", mediaType));
var acceptJson = /* @__PURE__ */ accept("application/json");
var setMethod = /* @__PURE__ */ dual(2, (self2, method) => makeInternal(method, self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
var setUrl = /* @__PURE__ */ dual(2, (self2, url2) => {
  if (typeof url2 === "string") {
    return makeInternal(self2.method, url2, self2.urlParams, self2.hash, self2.headers, self2.body);
  }
  const clone3 = new URL(url2.toString());
  const urlParams3 = fromInput4(clone3.searchParams);
  const hash5 = clone3.hash ? some3(clone3.hash.slice(1)) : none2();
  clone3.search = "";
  clone3.hash = "";
  return makeInternal(self2.method, clone3.toString(), urlParams3, hash5, self2.headers, self2.body);
});
var appendUrl = /* @__PURE__ */ dual(2, (self2, url2) => makeInternal(self2.method, self2.url.endsWith("/") && url2.startsWith("/") ? self2.url + url2.slice(1) : self2.url + url2, self2.urlParams, self2.hash, self2.headers, self2.body));
var prependUrl = /* @__PURE__ */ dual(2, (self2, url2) => makeInternal(self2.method, url2.endsWith("/") && self2.url.startsWith("/") ? url2 + self2.url.slice(1) : url2 + self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
var setUrlParams = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, setAll4(self2.urlParams, input), self2.hash, self2.headers, self2.body));
var setHash = /* @__PURE__ */ dual(2, (self2, hash5) => makeInternal(self2.method, self2.url, self2.urlParams, some3(hash5), self2.headers, self2.body));
var setBody = /* @__PURE__ */ dual(2, (self2, body) => {
  let headers = self2.headers;
  if (body._tag === "Empty" || body._tag === "FormData") {
    headers = remove11(headers, ["Content-type", "Content-length"]);
  } else {
    const contentType = body.contentType;
    if (contentType) {
      headers = set11(headers, "content-type", contentType);
    }
    const contentLength = body.contentLength;
    if (contentLength) {
      headers = set11(headers, "content-length", contentLength.toString());
    }
  }
  return makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, headers, body);
});
var bodyUnsafeJson = /* @__PURE__ */ dual(2, (self2, body) => setBody(self2, unsafeJson(body)));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpClientResponse.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId37 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientResponse");
var fromWeb = /* @__PURE__ */ __name((request2, source) => new ClientResponseImpl(request2, source), "fromWeb");
var ClientResponseImpl = class extends Class {
  request;
  source;
  [TypeId35];
  [TypeId37];
  constructor(request2, source) {
    super();
    this.request = request2;
    this.source = source;
    this[TypeId35] = TypeId35;
    this[TypeId37] = TypeId37;
  }
  toJSON() {
    return inspect(this, {
      _id: "@effect/platform/HttpClientResponse",
      request: this.request.toJSON(),
      status: this.status
    });
  }
  get status() {
    return this.source.status;
  }
  get headers() {
    return fromInput3(this.source.headers);
  }
  cachedCookies;
  get cookies() {
    if (this.cachedCookies) {
      return this.cachedCookies;
    }
    return this.cachedCookies = fromSetCookie(this.source.headers.getSetCookie());
  }
  get remoteAddress() {
    return none2();
  }
  get stream() {
    return this.source.body ? fromReadableStream2(() => this.source.body, (cause3) => new ResponseError({
      request: this.request,
      response: this,
      reason: "Decode",
      cause: cause3
    })) : fail20(new ResponseError({
      request: this.request,
      response: this,
      reason: "EmptyBody",
      description: "can not create stream from empty body"
    }));
  }
  get json() {
    return tryMap2(this.text, {
      try: (text6) => text6 === "" ? null : JSON.parse(text6),
      catch: (cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      })
    });
  }
  textBody;
  get text() {
    return this.textBody ??= tryPromise2({
      try: () => this.source.text(),
      catch: (cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      })
    }).pipe(cached3, runSync);
  }
  get urlParamsBody() {
    return flatMap14(this.text, (_) => try_3({
      try: () => fromInput4(new URLSearchParams(_)),
      catch: (cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      })
    }));
  }
  formDataBody;
  get formData() {
    return this.formDataBody ??= tryPromise2({
      try: () => this.source.formData(),
      catch: (cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      })
    }).pipe(cached3, runSync);
  }
  arrayBufferBody;
  get arrayBuffer() {
    return this.arrayBufferBody ??= tryPromise2({
      try: () => this.source.arrayBuffer(),
      catch: (cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      })
    }).pipe(cached3, runSync);
  }
};
__name(ClientResponseImpl, "ClientResponseImpl");
var filterStatusOk = /* @__PURE__ */ __name((self2) => self2.status >= 200 && self2.status < 300 ? succeed10(self2) : fail10(new ResponseError({
  response: self2,
  request: self2.request,
  reason: "StatusCode",
  description: "non 2xx status code"
})), "filterStatusOk");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpClient.js
var ATTR_HTTP_REQUEST_HEADER = /* @__PURE__ */ __name((key) => `http.request.header.${key}`, "ATTR_HTTP_REQUEST_HEADER");
var ATTR_HTTP_REQUEST_METHOD = "http.request.method";
var ATTR_HTTP_RESPONSE_HEADER = /* @__PURE__ */ __name((key) => `http.response.header.${key}`, "ATTR_HTTP_RESPONSE_HEADER");
var ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
var ATTR_SERVER_ADDRESS = "server.address";
var ATTR_SERVER_PORT = "server.port";
var ATTR_URL_FULL = "url.full";
var ATTR_URL_PATH = "url.path";
var ATTR_URL_SCHEME = "url.scheme";
var ATTR_URL_QUERY = "url.query";
var TypeId38 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClient");
var tag5 = /* @__PURE__ */ GenericTag("@effect/platform/HttpClient");
var currentTracerDisabledWhen = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/tracerDisabledWhen"), () => unsafeMake12(constFalse));
var currentTracerPropagation = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/currentTracerPropagation"), () => unsafeMake12(true));
var SpanNameGenerator = /* @__PURE__ */ Reference2()("@effect/platform/HttpClient/SpanNameGenerator", {
  defaultValue: () => (request2) => `http.client ${request2.method}`
});
var ClientProto = {
  [TypeId38]: TypeId38,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClient"
    };
  },
  get(url2, options4) {
    return this.execute(get19(url2, options4));
  },
  head(url2, options4) {
    return this.execute(head7(url2, options4));
  },
  post(url2, options4) {
    return this.execute(post(url2, options4));
  },
  put(url2, options4) {
    return this.execute(put(url2, options4));
  },
  patch(url2, options4) {
    return this.execute(patch9(url2, options4));
  },
  del(url2, options4) {
    return this.execute(del(url2, options4));
  },
  options(url2, options4) {
    return this.execute(options(url2, options4));
  }
};
var makeWith2 = /* @__PURE__ */ __name((postprocess, preprocess) => {
  const self2 = Object.create(ClientProto);
  self2.preprocess = preprocess;
  self2.postprocess = postprocess;
  self2.execute = function(request2) {
    return postprocess(preprocess(request2));
  };
  return self2;
}, "makeWith");
var responseRegistry = /* @__PURE__ */ globalValue("@effect/platform/HttpClient/responseRegistry", () => {
  if ("FinalizationRegistry" in globalThis && globalThis.FinalizationRegistry) {
    const registry = new FinalizationRegistry((controller) => {
      controller.abort();
    });
    return {
      register(response, controller) {
        registry.register(response, controller, response);
      },
      unregister(response) {
        registry.unregister(response);
      }
    };
  }
  const timers = /* @__PURE__ */ new Map();
  return {
    register(response, controller) {
      timers.set(response, setTimeout(() => controller.abort(), 5e3));
    },
    unregister(response) {
      const timer2 = timers.get(response);
      if (timer2 === void 0)
        return;
      clearTimeout(timer2);
      timers.delete(response);
    }
  };
});
var scopedRequests = /* @__PURE__ */ globalValue("@effect/platform/HttpClient/scopedRequests", () => /* @__PURE__ */ new WeakMap());
var make73 = /* @__PURE__ */ __name((f) => makeWith2((effect4) => flatMap14(effect4, (request2) => withFiberRuntime2((fiber) => {
  const scopedController = scopedRequests.get(request2);
  const controller = scopedController ?? new AbortController();
  const urlResult = makeUrl(request2.url, request2.urlParams, request2.hash);
  if (urlResult._tag === "Left") {
    return fail10(new RequestError({
      request: request2,
      reason: "InvalidUrl",
      cause: urlResult.left
    }));
  }
  const url2 = urlResult.right;
  const tracerDisabled = !fiber.getFiberRef(currentTracerEnabled2) || fiber.getFiberRef(currentTracerDisabledWhen)(request2);
  if (tracerDisabled) {
    const effect5 = f(request2, url2, controller.signal, fiber);
    if (scopedController)
      return effect5;
    return uninterruptibleMask3((restore) => matchCauseEffect3(restore(effect5), {
      onSuccess(response) {
        responseRegistry.register(response, controller);
        return succeed10(new InterruptibleResponse(response, controller));
      },
      onFailure(cause3) {
        if (isInterrupted3(cause3)) {
          controller.abort();
        }
        return failCause9(cause3);
      }
    }));
  }
  const nameGenerator = get6(fiber.currentContext, SpanNameGenerator);
  return useSpan2(nameGenerator(request2), {
    kind: "client",
    captureStackTrace: false
  }, (span4) => {
    span4.attribute(ATTR_HTTP_REQUEST_METHOD, request2.method);
    span4.attribute(ATTR_SERVER_ADDRESS, url2.origin);
    if (url2.port !== "") {
      span4.attribute(ATTR_SERVER_PORT, +url2.port);
    }
    span4.attribute(ATTR_URL_FULL, url2.toString());
    span4.attribute(ATTR_URL_PATH, url2.pathname);
    span4.attribute(ATTR_URL_SCHEME, url2.protocol.slice(0, -1));
    const query = url2.search.slice(1);
    if (query !== "") {
      span4.attribute(ATTR_URL_QUERY, query);
    }
    const redactedHeaderNames = fiber.getFiberRef(currentRedactedNames);
    const redactedHeaders = redact2(request2.headers, redactedHeaderNames);
    for (const name in redactedHeaders) {
      span4.attribute(ATTR_HTTP_REQUEST_HEADER(name), String(redactedHeaders[name]));
    }
    request2 = fiber.getFiberRef(currentTracerPropagation) ? setHeaders(request2, toHeaders(span4)) : request2;
    return uninterruptibleMask3((restore) => restore(f(request2, url2, controller.signal, fiber)).pipe(withParentSpan3(span4), matchCauseEffect3({
      onSuccess: (response) => {
        span4.attribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);
        const redactedHeaders2 = redact2(response.headers, redactedHeaderNames);
        for (const name in redactedHeaders2) {
          span4.attribute(ATTR_HTTP_RESPONSE_HEADER(name), String(redactedHeaders2[name]));
        }
        if (scopedController)
          return succeed10(response);
        responseRegistry.register(response, controller);
        return succeed10(new InterruptibleResponse(response, controller));
      },
      onFailure(cause3) {
        if (!scopedController && isInterrupted3(cause3)) {
          controller.abort();
        }
        return failCause9(cause3);
      }
    })));
  });
})), succeed10), "make");
var InterruptibleResponse = class {
  original;
  controller;
  constructor(original, controller) {
    this.original = original;
    this.controller = controller;
  }
  [TypeId37] = TypeId37;
  [TypeId35] = TypeId35;
  applyInterrupt(effect4) {
    return suspend4(() => {
      responseRegistry.unregister(this.original);
      return onInterrupt2(effect4, () => sync6(() => {
        this.controller.abort();
      }));
    });
  }
  get request() {
    return this.original.request;
  }
  get status() {
    return this.original.status;
  }
  get headers() {
    return this.original.headers;
  }
  get cookies() {
    return this.original.cookies;
  }
  get remoteAddress() {
    return this.original.remoteAddress;
  }
  get formData() {
    return this.applyInterrupt(this.original.formData);
  }
  get text() {
    return this.applyInterrupt(this.original.text);
  }
  get json() {
    return this.applyInterrupt(this.original.json);
  }
  get urlParamsBody() {
    return this.applyInterrupt(this.original.urlParamsBody);
  }
  get arrayBuffer() {
    return this.applyInterrupt(this.original.arrayBuffer);
  }
  get stream() {
    return suspend14(() => {
      responseRegistry.unregister(this.original);
      return ensuring8(this.original.stream, sync6(() => {
        this.controller.abort();
      }));
    });
  }
  toJSON() {
    return this.original.toJSON();
  }
  [NodeInspectSymbol]() {
    return this.original[NodeInspectSymbol]();
  }
};
__name(InterruptibleResponse, "InterruptibleResponse");
var {
  /** @internal */
  del: del2,
  /** @internal */
  execute: execute3,
  /** @internal */
  get: get20,
  /** @internal */
  head: head8,
  /** @internal */
  options: options2,
  /** @internal */
  patch: patch10,
  /** @internal */
  post: post2,
  /** @internal */
  put: put2
} = /* @__PURE__ */ serviceFunctions2(tag5);
var filterStatusOk2 = /* @__PURE__ */ __name((self2) => transformResponse(self2, flatMap14(filterStatusOk)), "filterStatusOk");
var transformResponse = /* @__PURE__ */ dual(2, (self2, f) => {
  const client = self2;
  return makeWith2((request2) => f(client.postprocess(request2)), client.preprocess);
});
var mapRequest = /* @__PURE__ */ dual(2, (self2, f) => {
  const client = self2;
  return makeWith2(client.postprocess, (request2) => map20(client.preprocess(request2), f));
});
var retryTransient = /* @__PURE__ */ dual(2, (self2, options4) => transformResponse(self2, retry2({
  while: ScheduleTypeId2 in options4 || options4.while === void 0 ? isTransientError : or(isTransientError, options4.while),
  schedule: ScheduleTypeId2 in options4 ? options4 : options4.schedule,
  times: ScheduleTypeId2 in options4 ? void 0 : options4.times
})));
var isTransientError = /* @__PURE__ */ __name((error3) => hasProperty(error3, TimeoutExceptionTypeId2) || isTransientHttpError(error3), "isTransientError");
var isTransientHttpError = /* @__PURE__ */ __name((error3) => isHttpClientError(error3) && (error3._tag === "RequestError" && error3.reason === "Transport" || error3._tag === "ResponseError" && error3.response.status >= 429), "isTransientHttpError");
var layerMergedContext = /* @__PURE__ */ __name((effect4) => effect(tag5, flatMap14(context3(), (context11) => map20(effect4, (client) => transformResponse(client, mapInputContext2((input) => merge3(context11, input)))))), "layerMergedContext");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpClient.js
var HttpClient = tag5;
var filterStatusOk3 = filterStatusOk2;
var mapRequest2 = mapRequest;
var retryTransient2 = retryTransient;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpClientRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var get21 = get19;
var post3 = post;
var prependUrl2 = prependUrl;
var appendUrl2 = appendUrl;
var bodyUnsafeJson2 = bodyUnsafeJson;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Transferable.js
var Transferable_exports = {};
__export(Transferable_exports, {
  Collector: () => Collector,
  ImageData: () => ImageData,
  MessagePort: () => MessagePort,
  Uint8Array: () => Uint8Array2,
  addAll: () => addAll,
  makeCollector: () => makeCollector,
  schema: () => schema2,
  unsafeMakeCollector: () => unsafeMakeCollector
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var Collector = class extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
};
__name(Collector, "Collector");
var unsafeMakeCollector = /* @__PURE__ */ __name(() => {
  let tranferables = [];
  const unsafeAddAll = /* @__PURE__ */ __name((transfers) => {
    tranferables.push(...transfers);
  }, "unsafeAddAll");
  const unsafeRead = /* @__PURE__ */ __name(() => tranferables, "unsafeRead");
  const unsafeClear = /* @__PURE__ */ __name(() => {
    const prev = tranferables;
    tranferables = [];
    return prev;
  }, "unsafeClear");
  return Collector.of({
    unsafeAddAll,
    addAll: (transferables) => sync6(() => unsafeAddAll(transferables)),
    unsafeRead,
    read: sync6(unsafeRead),
    unsafeClear,
    clear: sync6(unsafeClear)
  });
}, "unsafeMakeCollector");
var makeCollector = /* @__PURE__ */ sync6(unsafeMakeCollector);
var addAll = /* @__PURE__ */ __name((tranferables) => flatMap14(serviceOption2(Collector), match2({
  onNone: () => _void,
  onSome: (_) => _.addAll(tranferables)
})), "addAll");
var schema2 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(encodedSchema(self2), self2, {
  strict: true,
  decode: succeed13,
  encode: (i) => as7(addAll(f(i)), i)
}));
var ImageData = /* @__PURE__ */ schema2(Any, (_) => [_.data.buffer]);
var MessagePort = /* @__PURE__ */ schema2(Any, (_) => [_]);
var Uint8Array2 = /* @__PURE__ */ schema2(Uint8ArrayFromSelf, (_) => [_.buffer]);

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/internal/utils.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var withRun = /* @__PURE__ */ __name(() => (f) => suspend4(() => {
  const semaphore = unsafeMakeSemaphore2(1);
  let buffer4 = [];
  let write3 = /* @__PURE__ */ __name((...args2) => contextWith2((context11) => {
    buffer4.push([args2, context11]);
  }), "write");
  return map20(f((...args2) => write3(...args2)), (a) => ({
    ...a,
    run(f2) {
      return semaphore.withPermits(1)(gen3(function* () {
        const prev = write3;
        write3 = f2;
        for (const [args2, context11] of buffer4) {
          yield* provide2(write3(...args2), context11);
        }
        buffer4 = [];
        return yield* onExit3(never4, () => {
          write3 = prev;
          return _void;
        });
      }));
    }
  }));
}), "withRun");

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcMessage.js
var RpcMessage_exports = {};
__export(RpcMessage_exports, {
  RequestId: () => RequestId,
  RequestIdTypeId: () => RequestIdTypeId,
  ResponseDefectEncoded: () => ResponseDefectEncoded,
  ResponseIdTypeId: () => ResponseIdTypeId,
  constEof: () => constEof,
  constPing: () => constPing,
  constPong: () => constPong
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var RequestIdTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcServer/RequestId");
var RequestId = /* @__PURE__ */ __name((id3) => typeof id3 === "bigint" ? id3 : BigInt(id3), "RequestId");
var constEof = {
  _tag: "Eof"
};
var constPing = {
  _tag: "Ping"
};
var ResponseIdTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcServer/ResponseId");
var encodeDefect = /* @__PURE__ */ encodeSync(Defect);
var ResponseDefectEncoded = /* @__PURE__ */ __name((input) => ({
  _tag: "Defect",
  defect: encodeDefect(input)
}), "ResponseDefectEncoded");
var constPong = {
  _tag: "Pong"
};

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcSerialization.js
var RpcSerialization_exports = {};
__export(RpcSerialization_exports, {
  RpcSerialization: () => RpcSerialization,
  json: () => json4,
  jsonRpc: () => jsonRpc,
  layerJson: () => layerJson,
  layerJsonRpc: () => layerJsonRpc,
  layerMsgPack: () => layerMsgPack,
  layerNdJsonRpc: () => layerNdJsonRpc,
  layerNdjson: () => layerNdjson,
  msgPack: () => msgPack,
  ndJsonRpc: () => ndJsonRpc,
  ndjson: () => ndjson
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var decoder2;
try {
  decoder2 = new TextDecoder();
} catch (error3) {
}
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentUnpackr = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var dataView;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var C1Type = class {
};
__name(C1Type, "C1Type");
var C1 = new C1Type();
C1.name = "MessagePack 0xC1";
var sequentialMode = false;
var inlineObjectReadThreshold = 2;
var readStruct;
var onLoadedStructures;
var onSaveState;
try {
  new Function("");
} catch (error3) {
  inlineObjectReadThreshold = Infinity;
}
var Unpackr = class {
  constructor(options4) {
    if (options4) {
      if (options4.useRecords === false && options4.mapsAsObjects === void 0)
        options4.mapsAsObjects = true;
      if (options4.sequential && options4.trusted !== false) {
        options4.trusted = true;
        if (!options4.structures && options4.useRecords != false) {
          options4.structures = [];
          if (!options4.maxSharedStructures)
            options4.maxSharedStructures = 0;
        }
      }
      if (options4.structures)
        options4.structures.sharedLength = options4.structures.length;
      else if (options4.getStructures) {
        (options4.structures = []).uninitialized = true;
        options4.structures.sharedLength = 0;
      }
      if (options4.int64AsNumber) {
        options4.int64AsType = "number";
      }
    }
    Object.assign(this, options4);
  }
  unpack(source, options4) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.unpack(source, options4) : Unpackr.prototype.unpack.call(defaultOptions, source, options4);
      });
    }
    if (!source.buffer && source.constructor === ArrayBuffer)
      source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
    if (typeof options4 === "object") {
      srcEnd = options4.end || source.length;
      position = options4.start || 0;
    } else {
      position = 0;
      srcEnd = options4 > -1 ? options4 : source.length;
    }
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error3) {
      src = null;
      if (source instanceof Uint8Array)
        throw error3;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Unpackr) {
      currentUnpackr = this;
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead(options4);
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentUnpackr = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
    }
    return checkedRead(options4);
  }
  unpackMultiple(source, forEach14) {
    let values6, lastPosition = 0;
    try {
      sequentialMode = true;
      let size18 = source.length;
      let value6 = this ? this.unpack(source, size18) : defaultUnpackr.unpack(source, size18);
      if (forEach14) {
        if (forEach14(value6, lastPosition, position) === false)
          return;
        while (position < size18) {
          lastPosition = position;
          if (forEach14(checkedRead(), lastPosition, position) === false) {
            return;
          }
        }
      } else {
        values6 = [value6];
        while (position < size18) {
          lastPosition = position;
          values6.push(checkedRead());
        }
        return values6;
      }
    } catch (error3) {
      error3.lastPosition = lastPosition;
      error3.values = values6;
      throw error3;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
  _mergeStructures(loadedStructures, existingStructures) {
    if (onLoadedStructures)
      loadedStructures = onLoadedStructures.call(this, loadedStructures);
    loadedStructures = loadedStructures || [];
    if (Object.isFrozen(loadedStructures))
      loadedStructures = loadedStructures.map((structure2) => structure2.slice(0));
    for (let i = 0, l = loadedStructures.length; i < l; i++) {
      let structure2 = loadedStructures[i];
      if (structure2) {
        structure2.isShared = true;
        if (i >= 32)
          structure2.highByte = i - 32 >> 5;
      }
    }
    loadedStructures.sharedLength = loadedStructures.length;
    for (let id3 in existingStructures || []) {
      if (id3 >= 0) {
        let structure2 = loadedStructures[id3];
        let existing = existingStructures[id3];
        if (existing) {
          if (structure2)
            (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id3] = structure2;
          loadedStructures[id3] = existing;
        }
      }
    }
    return this.structures = loadedStructures;
  }
  decode(source, options4) {
    return this.unpack(source, options4);
  }
};
__name(Unpackr, "Unpackr");
function checkedRead(options4) {
  try {
    if (!currentUnpackr.trusted && !sequentialMode) {
      let sharedLength = currentStructures.sharedLength || 0;
      if (sharedLength < currentStructures.length)
        currentStructures.length = sharedLength;
    }
    let result;
    if (currentUnpackr.randomAccessStructure && src[position] < 64 && src[position] >= 32 && readStruct) {
      result = readStruct(src, position, srcEnd, currentUnpackr);
      src = null;
      if (!(options4 && options4.lazy) && result)
        result = result.toJSON();
      position = srcEnd;
    } else
      result = read2();
    if (bundledStrings) {
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (sequentialMode)
      currentStructures.restoreStructures = null;
    if (position == srcEnd) {
      if (currentStructures && currentStructures.restoreStructures)
        restoreStructures();
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      throw new Error("Unexpected end of MessagePack data");
    } else if (!sequentialMode) {
      let jsonView;
      try {
        jsonView = JSON.stringify(result, (_, value6) => typeof value6 === "bigint" ? `${value6}n` : value6).slice(0, 100);
      } catch (error3) {
        jsonView = "(JSON view not available " + error3 + ")";
      }
      throw new Error("Data read, but end of buffer not reached " + jsonView);
    }
    return result;
  } catch (error3) {
    if (currentStructures && currentStructures.restoreStructures)
      restoreStructures();
    clearSource();
    if (error3 instanceof RangeError || error3.message.startsWith("Unexpected end of buffer") || position > srcEnd) {
      error3.incomplete = true;
    }
    throw error3;
  }
}
__name(checkedRead, "checkedRead");
function restoreStructures() {
  for (let id3 in currentStructures.restoreStructures) {
    currentStructures[id3] = currentStructures.restoreStructures[id3];
  }
  currentStructures.restoreStructures = null;
}
__name(restoreStructures, "restoreStructures");
function read2() {
  let token = src[position++];
  if (token < 160) {
    if (token < 128) {
      if (token < 64)
        return token;
      else {
        let structure2 = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
        if (structure2) {
          if (!structure2.read) {
            structure2.read = createStructureReader(structure2, token & 63);
          }
          return structure2.read();
        } else
          return token;
      }
    } else if (token < 144) {
      token -= 128;
      if (currentUnpackr.mapsAsObjects) {
        let object2 = {};
        for (let i = 0; i < token; i++) {
          let key = readKey();
          if (key === "__proto__")
            key = "__proto_";
          object2[key] = read2();
        }
        return object2;
      } else {
        let map33 = /* @__PURE__ */ new Map();
        for (let i = 0; i < token; i++) {
          map33.set(read2(), read2());
        }
        return map33;
      }
    } else {
      token -= 144;
      let array6 = new Array(token);
      for (let i = 0; i < token; i++) {
        array6[i] = read2();
      }
      if (currentUnpackr.freezeData)
        return Object.freeze(array6);
      return array6;
    }
  } else if (token < 192) {
    let length4 = token - 160;
    if (srcStringEnd >= position) {
      return srcString.slice(position - srcStringStart, (position += length4) - srcStringStart);
    }
    if (srcStringEnd == 0 && srcEnd < 140) {
      let string7 = length4 < 16 ? shortStringInJS(length4) : longStringInJS(length4);
      if (string7 != null)
        return string7;
    }
    return readFixedString(length4);
  } else {
    let value6;
    switch (token) {
      case 192:
        return null;
      case 193:
        if (bundledStrings) {
          value6 = read2();
          if (value6 > 0)
            return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value6);
          else
            return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value6);
        }
        return C1;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        value6 = src[position++];
        if (value6 === void 0)
          throw new Error("Unexpected end of buffer");
        return readBin(value6);
      case 197:
        value6 = dataView.getUint16(position);
        position += 2;
        return readBin(value6);
      case 198:
        value6 = dataView.getUint32(position);
        position += 4;
        return readBin(value6);
      case 199:
        return readExt(src[position++]);
      case 200:
        value6 = dataView.getUint16(position);
        position += 2;
        return readExt(value6);
      case 201:
        value6 = dataView.getUint32(position);
        position += 4;
        return readExt(value6);
      case 202:
        value6 = dataView.getFloat32(position);
        if (currentUnpackr.useFloat32 > 2) {
          let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
          position += 4;
          return (multiplier * value6 + (value6 > 0 ? 0.5 : -0.5) >> 0) / multiplier;
        }
        position += 4;
        return value6;
      case 203:
        value6 = dataView.getFloat64(position);
        position += 8;
        return value6;
      case 204:
        return src[position++];
      case 205:
        value6 = dataView.getUint16(position);
        position += 2;
        return value6;
      case 206:
        value6 = dataView.getUint32(position);
        position += 4;
        return value6;
      case 207:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getUint32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigUint64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigUint64(position);
          if (value6 <= BigInt(2) << BigInt(52))
            value6 = Number(value6);
        } else
          value6 = dataView.getBigUint64(position);
        position += 8;
        return value6;
      case 208:
        return dataView.getInt8(position++);
      case 209:
        value6 = dataView.getInt16(position);
        position += 2;
        return value6;
      case 210:
        value6 = dataView.getInt32(position);
        position += 4;
        return value6;
      case 211:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getInt32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigInt64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigInt64(position);
          if (value6 >= BigInt(-2) << BigInt(52) && value6 <= BigInt(2) << BigInt(52))
            value6 = Number(value6);
        } else
          value6 = dataView.getBigInt64(position);
        position += 8;
        return value6;
      case 212:
        value6 = src[position++];
        if (value6 == 114) {
          return recordDefinition(src[position++] & 63);
        } else {
          let extension = currentExtensions[value6];
          if (extension) {
            if (extension.read) {
              position++;
              return extension.read(read2());
            } else if (extension.noBuffer) {
              position++;
              return extension();
            } else
              return extension(src.subarray(position, ++position));
          } else
            throw new Error("Unknown extension " + value6);
        }
      case 213:
        value6 = src[position];
        if (value6 == 114) {
          position++;
          return recordDefinition(src[position++] & 63, src[position++]);
        } else
          return readExt(2);
      case 214:
        return readExt(4);
      case 215:
        return readExt(8);
      case 216:
        return readExt(16);
      case 217:
        value6 = src[position++];
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString8(value6);
      case 218:
        value6 = dataView.getUint16(position);
        position += 2;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString16(value6);
      case 219:
        value6 = dataView.getUint32(position);
        position += 4;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString32(value6);
      case 220:
        value6 = dataView.getUint16(position);
        position += 2;
        return readArray(value6);
      case 221:
        value6 = dataView.getUint32(position);
        position += 4;
        return readArray(value6);
      case 222:
        value6 = dataView.getUint16(position);
        position += 2;
        return readMap(value6);
      case 223:
        value6 = dataView.getUint32(position);
        position += 4;
        return readMap(value6);
      default:
        if (token >= 224)
          return token - 256;
        if (token === void 0) {
          let error3 = new Error("Unexpected end of MessagePack data");
          error3.incomplete = true;
          throw error3;
        }
        throw new Error("Unknown MessagePack token " + token);
    }
  }
}
__name(read2, "read");
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure2, firstId) {
  function readObject() {
    if (readObject.count++ > inlineObjectReadThreshold) {
      let readObject2 = structure2.read = new Function("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure2.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read2);
      if (structure2.highByte === 0)
        structure2.read = createSecondByteReader(firstId, structure2.read);
      return readObject2();
    }
    let object2 = {};
    for (let i = 0, l = structure2.length; i < l; i++) {
      let key = structure2[i];
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read2();
    }
    if (currentUnpackr.freezeData)
      return Object.freeze(object2);
    return object2;
  }
  __name(readObject, "readObject");
  readObject.count = 0;
  if (structure2.highByte === 0) {
    return createSecondByteReader(firstId, readObject);
  }
  return readObject;
}
__name(createStructureReader, "createStructureReader");
var createSecondByteReader = /* @__PURE__ */ __name((firstId, read0) => {
  return function() {
    let highByte = src[position++];
    if (highByte === 0)
      return read0();
    let id3 = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
    let structure2 = currentStructures[id3] || loadStructures()[id3];
    if (!structure2) {
      throw new Error("Record id is not defined for " + id3);
    }
    if (!structure2.read)
      structure2.read = createStructureReader(structure2, firstId);
    return structure2.read();
  };
}, "createSecondByteReader");
function loadStructures() {
  let loadedStructures = saveState(() => {
    src = null;
    return currentUnpackr.getStructures();
  });
  return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
}
__name(loadStructures, "loadStructures");
var readFixedString = readStringJS;
var readString8 = readStringJS;
var readString16 = readStringJS;
var readString32 = readStringJS;
function readStringJS(length4) {
  let result;
  if (length4 < 16) {
    if (result = shortStringInJS(length4))
      return result;
  }
  if (length4 > 64 && decoder2)
    return decoder2.decode(src.subarray(position, position += length4));
  const end6 = position + length4;
  const units = [];
  result = "";
  while (position < end6) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
__name(readStringJS, "readStringJS");
function readArray(length4) {
  let array6 = new Array(length4);
  for (let i = 0; i < length4; i++) {
    array6[i] = read2();
  }
  if (currentUnpackr.freezeData)
    return Object.freeze(array6);
  return array6;
}
__name(readArray, "readArray");
function readMap(length4) {
  if (currentUnpackr.mapsAsObjects) {
    let object2 = {};
    for (let i = 0; i < length4; i++) {
      let key = readKey();
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read2();
    }
    return object2;
  } else {
    let map33 = /* @__PURE__ */ new Map();
    for (let i = 0; i < length4; i++) {
      map33.set(read2(), read2());
    }
    return map33;
  }
}
__name(readMap, "readMap");
var fromCharCode = String.fromCharCode;
function longStringInJS(length4) {
  let start3 = position;
  let bytes = new Array(length4);
  for (let i = 0; i < length4; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start3;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
__name(longStringInJS, "longStringInJS");
function shortStringInJS(length4) {
  if (length4 < 4) {
    if (length4 < 2) {
      if (length4 === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length4 < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length4 < 6) {
      if (length4 === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length4 < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length4 < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length4 < 10) {
        if (length4 === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length4 < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length4 < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length4 < 14) {
          if (length4 === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length4 < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
__name(shortStringInJS, "shortStringInJS");
function readOnlyJSString() {
  let token = src[position++];
  let length4;
  if (token < 192) {
    length4 = token - 160;
  } else {
    switch (token) {
      case 217:
        length4 = src[position++];
        break;
      case 218:
        length4 = dataView.getUint16(position);
        position += 2;
        break;
      case 219:
        length4 = dataView.getUint32(position);
        position += 4;
        break;
      default:
        throw new Error("Expected string");
    }
  }
  return readStringJS(length4);
}
__name(readOnlyJSString, "readOnlyJSString");
function readBin(length4) {
  return currentUnpackr.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length4)
  ) : src.subarray(position, position += length4);
}
__name(readBin, "readBin");
function readExt(length4) {
  let type3 = src[position++];
  if (currentExtensions[type3]) {
    let end6;
    return currentExtensions[type3](src.subarray(position, end6 = position += length4), (readPosition) => {
      position = readPosition;
      try {
        return read2();
      } finally {
        position = end6;
      }
    });
  } else
    throw new Error("Unknown extension type " + type3);
}
__name(readExt, "readExt");
var keyCache = new Array(4096);
function readKey() {
  let length4 = src[position++];
  if (length4 >= 160 && length4 < 192) {
    length4 = length4 - 160;
    if (srcStringEnd >= position)
      return srcString.slice(position - srcStringStart, (position += length4) - srcStringStart);
    else if (!(srcStringEnd == 0 && srcEnd < 180))
      return readFixedString(length4);
  } else {
    position--;
    return asSafeString(read2());
  }
  let key = (length4 << 5 ^ (length4 > 1 ? dataView.getUint16(position) : length4 > 0 ? src[position] : 0)) & 4095;
  let entry = keyCache[key];
  let checkPosition = position;
  let end6 = position + length4 - 3;
  let chunk4;
  let i = 0;
  if (entry && entry.bytes == length4) {
    while (checkPosition < end6) {
      chunk4 = dataView.getUint32(checkPosition);
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
      checkPosition += 4;
    }
    end6 += 3;
    while (checkPosition < end6) {
      chunk4 = src[checkPosition++];
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
    }
    if (checkPosition === end6) {
      position = checkPosition;
      return entry.string;
    }
    end6 -= 3;
    checkPosition = position;
  }
  entry = [];
  keyCache[key] = entry;
  entry.bytes = length4;
  while (checkPosition < end6) {
    chunk4 = dataView.getUint32(checkPosition);
    entry.push(chunk4);
    checkPosition += 4;
  }
  end6 += 3;
  while (checkPosition < end6) {
    chunk4 = src[checkPosition++];
    entry.push(chunk4);
  }
  let string7 = length4 < 16 ? shortStringInJS(length4) : longStringInJS(length4);
  if (string7 != null)
    return entry.string = string7;
  return entry.string = readFixedString(length4);
}
__name(readKey, "readKey");
function asSafeString(property2) {
  if (typeof property2 === "string")
    return property2;
  if (typeof property2 === "number" || typeof property2 === "boolean" || typeof property2 === "bigint")
    return property2.toString();
  if (property2 == null)
    return property2 + "";
  if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property2) && property2.flat().every((item) => ["string", "number", "boolean", "bigint"].includes(typeof item))) {
    return property2.flat().toString();
  }
  throw new Error(`Invalid property type for record: ${typeof property2}`);
}
__name(asSafeString, "asSafeString");
var recordDefinition = /* @__PURE__ */ __name((id3, highByte) => {
  let structure2 = read2().map(asSafeString);
  let firstByte = id3;
  if (highByte !== void 0) {
    id3 = id3 < 32 ? -((highByte << 5) + id3) : (highByte << 5) + id3;
    structure2.highByte = highByte;
  }
  let existingStructure = currentStructures[id3];
  if (existingStructure && (existingStructure.isShared || sequentialMode)) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id3] = existingStructure;
  }
  currentStructures[id3] = structure2;
  structure2.read = createStructureReader(structure2, firstByte);
  return structure2.read();
}, "recordDefinition");
currentExtensions[0] = () => {
};
currentExtensions[0].noBuffer = true;
currentExtensions[66] = (data) => {
  let headLength = data.byteLength % 8 || 8;
  let head10 = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
  for (let i = 1; i < headLength; i++) {
    head10 <<= BigInt(8);
    head10 += BigInt(data[i]);
  }
  if (data.byteLength !== headLength) {
    let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let decode8 = /* @__PURE__ */ __name((start3, end6) => {
      let length4 = end6 - start3;
      if (length4 <= 40) {
        let out = view.getBigUint64(start3);
        for (let i = start3 + 8; i < end6; i += 8) {
          out <<= BigInt(64n);
          out |= view.getBigUint64(i);
        }
        return out;
      }
      let middle = start3 + (length4 >> 4 << 3);
      let left3 = decode8(start3, middle);
      let right3 = decode8(middle, end6);
      return left3 << BigInt((end6 - middle) * 8) | right3;
    }, "decode");
    head10 = head10 << BigInt((view.byteLength - headLength) * 8) | decode8(headLength, view.byteLength);
  }
  return head10;
};
var errors2 = {
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError: typeof AggregateError === "function" ? AggregateError : null
};
currentExtensions[101] = () => {
  let data = read2();
  if (!errors2[data[0]]) {
    let error3 = Error(data[1], { cause: data[2] });
    error3.name = data[0];
    return error3;
  }
  return errors2[data[0]](data[1], { cause: data[2] });
};
currentExtensions[105] = (data) => {
  if (currentUnpackr.structuredClone === false)
    throw new Error("Structured clone extension is disabled");
  let id3 = dataView.getUint32(position - 4);
  if (!referenceMap)
    referenceMap = /* @__PURE__ */ new Map();
  let token = src[position];
  let target2;
  if (token >= 144 && token < 160 || token == 220 || token == 221)
    target2 = [];
  else if (token >= 128 && token < 144 || token == 222 || token == 223)
    target2 = /* @__PURE__ */ new Map();
  else if ((token >= 199 && token <= 201 || token >= 212 && token <= 216) && src[position + 1] === 115)
    target2 = /* @__PURE__ */ new Set();
  else
    target2 = {};
  let refEntry = { target: target2 };
  referenceMap.set(id3, refEntry);
  let targetProperties = read2();
  if (!refEntry.used) {
    return refEntry.target = targetProperties;
  } else {
    Object.assign(target2, targetProperties);
  }
  if (target2 instanceof Map)
    for (let [k, v] of targetProperties.entries())
      target2.set(k, v);
  if (target2 instanceof Set)
    for (let i of Array.from(targetProperties))
      target2.add(i);
  return target2;
};
currentExtensions[112] = (data) => {
  if (currentUnpackr.structuredClone === false)
    throw new Error("Structured clone extension is disabled");
  let id3 = dataView.getUint32(position - 4);
  let refEntry = referenceMap.get(id3);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[115] = () => new Set(read2());
var typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type3) => type3 + "Array");
var glbl = typeof globalThis === "object" ? globalThis : window;
currentExtensions[116] = (data) => {
  let typeCode = data[0];
  let buffer4 = Uint8Array.prototype.slice.call(data, 1).buffer;
  let typedArrayName = typedArrays[typeCode];
  if (!typedArrayName) {
    if (typeCode === 16)
      return buffer4;
    if (typeCode === 17)
      return new DataView(buffer4);
    throw new Error("Could not find typed array for code " + typeCode);
  }
  return new glbl[typedArrayName](buffer4);
};
currentExtensions[120] = () => {
  let data = read2();
  return new RegExp(data[0], data[1]);
};
var TEMP_BUNDLE = [];
currentExtensions[98] = (data) => {
  let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
  let dataPosition = position;
  position += dataSize - data.length;
  bundledStrings = TEMP_BUNDLE;
  bundledStrings = [readOnlyJSString(), readOnlyJSString()];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read2();
};
currentExtensions[255] = (data) => {
  if (data.length == 4)
    return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1e3);
  else if (data.length == 8)
    return new Date(
      ((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1e3
    );
  else if (data.length == 12)
    return new Date(
      ((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1e3
    );
  else
    return /* @__PURE__ */ new Date("invalid");
};
function saveState(callback) {
  if (onSaveState)
    onSaveState();
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
  let savedPackr = currentUnpackr;
  let savedSequentialMode = sequentialMode;
  let value6 = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
  currentUnpackr = savedPackr;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value6;
}
__name(saveState, "saveState");
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
__name(clearSource, "clearSource");
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultUnpackr = new Unpackr({ useRecords: false });
var unpack = defaultUnpackr.unpack;
var unpackMultiple = defaultUnpackr.unpackMultiple;
var decode7 = defaultUnpackr.unpack;
var FLOAT32_OPTIONS = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js
var textEncoder;
try {
  textEncoder = new TextEncoder();
} catch (error3) {
}
var extensions;
var extensionClasses;
var hasNodeBuffer = typeof Buffer !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? function(length4) {
  return Buffer.allocUnsafeSlow(length4);
} : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var target;
var keysTarget;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var writeStructSlots;
var MAX_BUNDLE_SIZE = 21760;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");
var Packr = class extends Unpackr {
  constructor(options4) {
    super(options4);
    this.offset = 0;
    let typeBuffer;
    let start3;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string7, position3) {
      return target.utf8Write(string7, position3, target.byteLength - position3);
    } : textEncoder && textEncoder.encodeInto ? function(string7, position3) {
      return textEncoder.encodeInto(string7, target.subarray(position3)).written;
    } : false;
    let packr = this;
    if (!options4)
      options4 = {};
    let isSequential2 = options4 && options4.sequential;
    let hasSharedStructures = options4.structures || options4.saveStructures;
    let maxSharedStructures = options4.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 32 : 0;
    if (maxSharedStructures > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    if (options4.structuredClone && options4.moreTypes == void 0) {
      this.moreTypes = true;
    }
    let maxOwnStructures = options4.maxOwnStructures;
    if (maxOwnStructures == null)
      maxOwnStructures = hasSharedStructures ? 32 : 64;
    if (!this.structures && options4.useRecords != false)
      this.structures = [];
    let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
    let sharedLimitId = maxSharedStructures + 64;
    let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
    if (maxStructureId > 8256) {
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.pack = this.encode = function(value6, encodeOptions) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
        safeEnd = target.length - 10;
        position2 = 0;
      } else
        position2 = position2 + 7 & 2147483640;
      start3 = position2;
      if (encodeOptions & RESERVE_START_SPACE)
        position2 += encodeOptions & 255;
      referenceMap2 = packr.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (packr.bundleStrings && typeof value6 !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Infinity;
      } else
        bundledStrings2 = null;
      structures = packr.structures;
      if (structures) {
        if (structures.uninitialized)
          structures = packr._mergeStructures(packr.getStructures());
        let sharedLength = structures.sharedLength || 0;
        if (sharedLength > maxSharedStructures) {
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
        }
        if (!structures.transitions) {
          structures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedLength; i++) {
            let keys6 = structures[i];
            if (!keys6)
              continue;
            let nextTransition, transition = structures.transitions;
            for (let j = 0, l = keys6.length; j < l; j++) {
              let key = keys6[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i + 64;
          }
          this.lastNamedStructuresLength = sharedLength;
        }
        if (!isSequential2) {
          structures.nextId = sharedLength + 64;
        }
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      let encodingError;
      try {
        if (packr.randomAccessStructure && value6 && value6.constructor && value6.constructor === Object)
          writeStruct(value6);
        else
          pack3(value6);
        let lastBundle = bundledStrings2;
        if (bundledStrings2)
          writeBundles(start3, pack3, 0);
        if (referenceMap2 && referenceMap2.idsToInsert) {
          let idsToInsert = referenceMap2.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
          let i = idsToInsert.length;
          let incrementPosition = -1;
          while (lastBundle && i > 0) {
            let insertionPoint = idsToInsert[--i].offset + start3;
            if (insertionPoint < lastBundle.stringsPosition + start3 && incrementPosition === -1)
              incrementPosition = 0;
            if (insertionPoint > lastBundle.position + start3) {
              if (incrementPosition >= 0)
                incrementPosition += 6;
            } else {
              if (incrementPosition >= 0) {
                targetView.setUint32(
                  lastBundle.position + start3,
                  targetView.getUint32(lastBundle.position + start3) + incrementPosition
                );
                incrementPosition = -1;
              }
              lastBundle = lastBundle.previous;
              i++;
            }
          }
          if (incrementPosition >= 0 && lastBundle) {
            targetView.setUint32(
              lastBundle.position + start3,
              targetView.getUint32(lastBundle.position + start3) + incrementPosition
            );
          }
          position2 += idsToInsert.length * 6;
          if (position2 > safeEnd)
            makeRoom(position2);
          packr.offset = position2;
          let serialized = insertIds(target.subarray(start3, position2), idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        packr.offset = position2;
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start3;
          target.end = position2;
          return target;
        }
        return target.subarray(start3, position2);
      } catch (error3) {
        encodingError = error3;
        throw error3;
      } finally {
        if (structures) {
          resetStructures();
          if (hasSharedUpdate && packr.saveStructures) {
            let sharedLength = structures.sharedLength || 0;
            let returnBuffer = target.subarray(start3, position2);
            let newSharedData = prepareStructures(structures, packr);
            if (!encodingError) {
              if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                return packr.pack(value6, encodeOptions);
              }
              packr.lastNamedStructuresLength = sharedLength;
              if (target.length > 1073741824)
                target = null;
              return returnBuffer;
            }
          }
        }
        if (target.length > 1073741824)
          target = null;
        if (encodeOptions & RESET_BUFFER_MODE)
          position2 = start3;
      }
    };
    const resetStructures = /* @__PURE__ */ __name(() => {
      if (serializationsSinceTransitionRebuild < 10)
        serializationsSinceTransitionRebuild++;
      let sharedLength = structures.sharedLength || 0;
      if (structures.length > sharedLength && !isSequential2)
        structures.length = sharedLength;
      if (transitionsCount > 1e4) {
        structures.transitions = null;
        serializationsSinceTransitionRebuild = 0;
        transitionsCount = 0;
        if (recordIdsToRemove.length > 0)
          recordIdsToRemove = [];
      } else if (recordIdsToRemove.length > 0 && !isSequential2) {
        for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
          recordIdsToRemove[i][RECORD_SYMBOL] = 0;
        }
        recordIdsToRemove = [];
      }
    }, "resetStructures");
    const packArray = /* @__PURE__ */ __name((value6) => {
      var length4 = value6.length;
      if (length4 < 16) {
        target[position2++] = 144 | length4;
      } else if (length4 < 65536) {
        target[position2++] = 220;
        target[position2++] = length4 >> 8;
        target[position2++] = length4 & 255;
      } else {
        target[position2++] = 221;
        targetView.setUint32(position2, length4);
        position2 += 4;
      }
      for (let i = 0; i < length4; i++) {
        pack3(value6[i]);
      }
    }, "packArray");
    const pack3 = /* @__PURE__ */ __name((value6) => {
      if (position2 > safeEnd)
        target = makeRoom(position2);
      var type3 = typeof value6;
      var length4;
      if (type3 === "string") {
        let strLength = value6.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 4096) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd)
              target = makeRoom(position2 + maxBytes2);
            let lastBundle;
            if (bundledStrings2.position) {
              lastBundle = bundledStrings2;
              target[position2] = 200;
              position2 += 3;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
              writeBundles(start3, pack3, 0);
              targetView.setUint16(extStart + start3 - 3, position2 - start3 - extStart);
            } else {
              target[position2++] = 214;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.previous = lastBundle;
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          let twoByte = hasNonLatin.test(value6);
          bundledStrings2[twoByte ? 0 : 1] += value6;
          target[position2++] = 193;
          pack3(twoByte ? -strLength : strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd)
          target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position2 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value6.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value6.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length4 = strPosition - position2 - headerSize;
        } else {
          length4 = encodeUtf8(value6, position2 + headerSize);
        }
        if (length4 < 32) {
          target[position2++] = 160 | length4;
        } else if (length4 < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length4);
          }
          target[position2++] = 217;
          target[position2++] = length4;
        } else if (length4 < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length4);
          }
          target[position2++] = 218;
          target[position2++] = length4 >> 8;
          target[position2++] = length4 & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length4);
          }
          target[position2++] = 219;
          targetView.setUint32(position2, length4);
          position2 += 4;
        }
        position2 += length4;
      } else if (type3 === "number") {
        if (value6 >>> 0 === value6) {
          if (value6 < 32 || value6 < 128 && this.useRecords === false || value6 < 64 && !this.randomAccessStructure) {
            target[position2++] = value6;
          } else if (value6 < 256) {
            target[position2++] = 204;
            target[position2++] = value6;
          } else if (value6 < 65536) {
            target[position2++] = 205;
            target[position2++] = value6 >> 8;
            target[position2++] = value6 & 255;
          } else {
            target[position2++] = 206;
            targetView.setUint32(position2, value6);
            position2 += 4;
          }
        } else if (value6 >> 0 === value6) {
          if (value6 >= -32) {
            target[position2++] = 256 + value6;
          } else if (value6 >= -128) {
            target[position2++] = 208;
            target[position2++] = value6 + 256;
          } else if (value6 >= -32768) {
            target[position2++] = 209;
            targetView.setInt16(position2, value6);
            position2 += 2;
          } else {
            target[position2++] = 210;
            targetView.setInt32(position2, value6);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value6 < 4294967296 && value6 >= -2147483648) {
            target[position2++] = 202;
            targetView.setFloat32(position2, value6);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value6 * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            } else
              position2--;
          }
          target[position2++] = 203;
          targetView.setFloat64(position2, value6);
          position2 += 8;
        }
      } else if (type3 === "object" || type3 === "function") {
        if (!value6)
          target[position2++] = 192;
        else {
          if (referenceMap2) {
            let referee = referenceMap2.get(value6);
            if (referee) {
              if (!referee.id) {
                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.id = idsToInsert.push(referee);
              }
              target[position2++] = 214;
              target[position2++] = 112;
              targetView.setUint32(position2, referee.id);
              position2 += 4;
              return;
            } else
              referenceMap2.set(value6, { offset: position2 - start3 });
          }
          let constructor = value6.constructor;
          if (constructor === Object) {
            writeObject(value6);
          } else if (constructor === Array) {
            packArray(value6);
          } else if (constructor === Map) {
            if (this.mapAsEmptyObject)
              target[position2++] = 128;
            else {
              length4 = value6.size;
              if (length4 < 16) {
                target[position2++] = 128 | length4;
              } else if (length4 < 65536) {
                target[position2++] = 222;
                target[position2++] = length4 >> 8;
                target[position2++] = length4 & 255;
              } else {
                target[position2++] = 223;
                targetView.setUint32(position2, length4);
                position2 += 4;
              }
              for (let [key, entryValue] of value6) {
                pack3(key);
                pack3(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value6 instanceof extensionClass) {
                let extension = extensions[i];
                if (extension.write) {
                  if (extension.type) {
                    target[position2++] = 212;
                    target[position2++] = extension.type;
                    target[position2++] = 0;
                  }
                  let writeResult = extension.write.call(this, value6);
                  if (writeResult === value6) {
                    if (Array.isArray(value6)) {
                      packArray(value6);
                    } else {
                      writeObject(value6);
                    }
                  } else {
                    pack3(writeResult);
                  }
                  return;
                }
                let currentTarget = target;
                let currentTargetView = targetView;
                let currentPosition = position2;
                target = null;
                let result;
                try {
                  result = extension.pack.call(this, value6, (size18) => {
                    target = currentTarget;
                    currentTarget = null;
                    position2 += size18;
                    if (position2 > safeEnd)
                      makeRoom(position2);
                    return {
                      target,
                      targetView,
                      position: position2 - size18
                    };
                  }, pack3);
                } finally {
                  if (currentTarget) {
                    target = currentTarget;
                    targetView = currentTargetView;
                    position2 = currentPosition;
                    safeEnd = target.length - 10;
                  }
                }
                if (result) {
                  if (result.length + position2 > safeEnd)
                    makeRoom(result.length + position2);
                  position2 = writeExtensionData(result, target, position2, extension.type);
                }
                return;
              }
            }
            if (Array.isArray(value6)) {
              packArray(value6);
            } else {
              if (value6.toJSON) {
                const json8 = value6.toJSON();
                if (json8 !== value6)
                  return pack3(json8);
              }
              if (type3 === "function")
                return pack3(this.writeFunction && this.writeFunction(value6));
              writeObject(value6);
            }
          }
        }
      } else if (type3 === "boolean") {
        target[position2++] = value6 ? 195 : 194;
      } else if (type3 === "bigint") {
        if (value6 < 9223372036854776e3 && value6 >= -9223372036854776e3) {
          target[position2++] = 211;
          targetView.setBigInt64(position2, value6);
        } else if (value6 < 18446744073709552e3 && value6 > 0) {
          target[position2++] = 207;
          targetView.setBigUint64(position2, value6);
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 203;
            targetView.setFloat64(position2, Number(value6));
          } else if (this.largeBigIntToString) {
            return pack3(value6.toString());
          } else if (this.useBigIntExtension || this.moreTypes) {
            let empty44 = value6 < 0 ? BigInt(-1) : BigInt(0);
            let array6;
            if (value6 >> BigInt(65536) === empty44) {
              let mask = BigInt(18446744073709552e3) - BigInt(1);
              let chunks3 = [];
              while (true) {
                chunks3.push(value6 & mask);
                if (value6 >> BigInt(63) === empty44)
                  break;
                value6 >>= BigInt(64);
              }
              array6 = new Uint8Array(new BigUint64Array(chunks3).buffer);
              array6.reverse();
            } else {
              let invert2 = value6 < 0;
              let string7 = (invert2 ? ~value6 : value6).toString(16);
              if (string7.length % 2) {
                string7 = "0" + string7;
              } else if (parseInt(string7.charAt(0), 16) >= 8) {
                string7 = "00" + string7;
              }
              if (hasNodeBuffer) {
                array6 = Buffer.from(string7, "hex");
              } else {
                array6 = new Uint8Array(string7.length / 2);
                for (let i = 0; i < array6.length; i++) {
                  array6[i] = parseInt(string7.slice(i * 2, i * 2 + 2), 16);
                }
              }
              if (invert2) {
                for (let i = 0; i < array6.length; i++)
                  array6[i] = ~array6[i];
              }
            }
            if (array6.length + position2 > safeEnd)
              makeRoom(array6.length + position2);
            position2 = writeExtensionData(array6, target, position2, 66);
            return;
          } else {
            throw new RangeError(value6 + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string");
          }
        }
        position2 += 8;
      } else if (type3 === "undefined") {
        if (this.encodeUndefinedAsNil)
          target[position2++] = 192;
        else {
          target[position2++] = 212;
          target[position2++] = 0;
          target[position2++] = 0;
        }
      } else {
        throw new Error("Unknown type: " + type3);
      }
    }, "pack");
    const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object2) => {
      let keys6;
      if (this.skipValues) {
        keys6 = [];
        for (let key2 in object2) {
          if ((typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key2)) && !this.skipValues.includes(object2[key2]))
            keys6.push(key2);
        }
      } else {
        keys6 = Object.keys(object2);
      }
      let length4 = keys6.length;
      if (length4 < 16) {
        target[position2++] = 128 | length4;
      } else if (length4 < 65536) {
        target[position2++] = 222;
        target[position2++] = length4 >> 8;
        target[position2++] = length4 & 255;
      } else {
        target[position2++] = 223;
        targetView.setUint32(position2, length4);
        position2 += 4;
      }
      let key;
      if (this.coercibleKeyAsNumber) {
        for (let i = 0; i < length4; i++) {
          key = keys6[i];
          let num = Number(key);
          pack3(isNaN(num) ? key : num);
          pack3(object2[key]);
        }
      } else {
        for (let i = 0; i < length4; i++) {
          pack3(key = keys6[i]);
          pack3(object2[key]);
        }
      }
    } : (object2) => {
      target[position2++] = 222;
      let objectOffset = position2 - start3;
      position2 += 2;
      let size18 = 0;
      for (let key in object2) {
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack3(key);
          pack3(object2[key]);
          size18++;
        }
      }
      if (size18 > 65535) {
        throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');
      }
      target[objectOffset++ + start3] = size18 >> 8;
      target[objectOffset + start3] = size18 & 255;
    };
    const writeRecord = this.useRecords === false ? writePlainObject : options4.progressiveRecords && !useTwoByteRecords ? (
      // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
      (object2) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
        let objectOffset = position2++ - start3;
        let wroteKeys;
        for (let key in object2) {
          if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (nextTransition)
              transition = nextTransition;
            else {
              let keys6 = Object.keys(object2);
              let lastTransition = transition;
              transition = structures.transitions;
              let newTransitions = 0;
              for (let i = 0, l = keys6.length; i < l; i++) {
                let key2 = keys6[i];
                nextTransition = transition[key2];
                if (!nextTransition) {
                  nextTransition = transition[key2] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
              if (objectOffset + start3 + 1 == position2) {
                position2--;
                newRecord(transition, keys6, newTransitions);
              } else
                insertNewRecord(transition, keys6, objectOffset, newTransitions);
              wroteKeys = true;
              transition = lastTransition[key];
            }
            pack3(object2[key]);
          }
        }
        if (!wroteKeys) {
          let recordId = transition[RECORD_SYMBOL];
          if (recordId)
            target[objectOffset + start3] = recordId;
          else
            insertNewRecord(transition, Object.keys(object2), objectOffset, 0);
        }
      }
    ) : (object2) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      for (let key in object2)
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId) {
        if (recordId >= 96 && useTwoByteRecords) {
          target[position2++] = ((recordId -= 96) & 31) + 96;
          target[position2++] = recordId >> 5;
        } else
          target[position2++] = recordId;
      } else {
        newRecord(transition, transition.__keys__ || Object.keys(object2), newTransitions);
      }
      for (let key in object2)
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack3(object2[key]);
        }
    };
    const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
    const writeObject = checkUseRecords ? (object2) => {
      checkUseRecords(object2) ? writeRecord(object2) : writePlainObject(object2);
    } : writeRecord;
    const makeRoom = /* @__PURE__ */ __name((end6) => {
      let newSize;
      if (end6 > 16777216) {
        if (end6 - start3 > MAX_BUFFER_SIZE)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE,
          Math.round(Math.max((end6 - start3) * (end6 > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else
        newSize = (Math.max(end6 - start3 << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
      end6 = Math.min(end6, target.length);
      if (target.copy)
        target.copy(newBuffer, 0, start3, end6);
      else
        newBuffer.set(target.slice(start3, end6));
      position2 -= start3;
      start3 = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    }, "makeRoom");
    const newRecord = /* @__PURE__ */ __name((transition, keys6, newTransitions) => {
      let recordId = structures.nextId;
      if (!recordId)
        recordId = 64;
      if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys6)) {
        recordId = structures.nextOwnId;
        if (!(recordId < maxStructureId))
          recordId = sharedLimitId;
        structures.nextOwnId = recordId + 1;
      } else {
        if (recordId >= maxStructureId)
          recordId = sharedLimitId;
        structures.nextId = recordId + 1;
      }
      let highByte = keys6.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
      transition[RECORD_SYMBOL] = recordId;
      transition.__keys__ = keys6;
      structures[recordId - 64] = keys6;
      if (recordId < sharedLimitId) {
        keys6.isShared = true;
        structures.sharedLength = recordId - 63;
        hasSharedUpdate = true;
        if (highByte >= 0) {
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = recordId;
        }
      } else {
        if (highByte >= 0) {
          target[position2++] = 213;
          target[position2++] = 114;
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = 212;
          target[position2++] = 114;
          target[position2++] = recordId;
        }
        if (newTransitions)
          transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
        if (recordIdsToRemove.length >= maxOwnStructures)
          recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
        recordIdsToRemove.push(transition);
        pack3(keys6);
      }
    }, "newRecord");
    const insertNewRecord = /* @__PURE__ */ __name((transition, keys6, insertionOffset, newTransitions) => {
      let mainTarget = target;
      let mainPosition = position2;
      let mainSafeEnd = safeEnd;
      let mainStart = start3;
      target = keysTarget;
      position2 = 0;
      start3 = 0;
      if (!target)
        keysTarget = target = new ByteArrayAllocate(8192);
      safeEnd = target.length - 10;
      newRecord(transition, keys6, newTransitions);
      keysTarget = target;
      let keysPosition = position2;
      target = mainTarget;
      position2 = mainPosition;
      safeEnd = mainSafeEnd;
      start3 = mainStart;
      if (keysPosition > 1) {
        let newEnd = position2 + keysPosition - 1;
        if (newEnd > safeEnd)
          makeRoom(newEnd);
        let insertionPosition = insertionOffset + start3;
        target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position2);
        target.set(keysTarget.slice(0, keysPosition), insertionPosition);
        position2 = newEnd;
      } else {
        target[insertionOffset + start3] = keysTarget[0];
      }
    }, "insertNewRecord");
    const writeStruct = /* @__PURE__ */ __name((object2) => {
      let newPosition = writeStructSlots(object2, target, start3, position2, structures, makeRoom, (value6, newPosition2, notifySharedUpdate) => {
        if (notifySharedUpdate)
          return hasSharedUpdate = true;
        position2 = newPosition2;
        let startTarget = target;
        pack3(value6);
        resetStructures();
        if (startTarget !== target) {
          return { position: position2, targetView, target };
        }
        return position2;
      }, this);
      if (newPosition === 0)
        return writeObject(object2);
      position2 = newPosition;
    }, "writeStruct");
  }
  useBuffer(buffer4) {
    target = buffer4;
    target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));
    targetView = target.dataView;
    position2 = 0;
  }
  set position(value6) {
    position2 = value6;
  }
  get position() {
    return position2;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.typedStructs)
      this.typedStructs = [];
  }
};
__name(Packr, "Packr");
extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, DataView, C1Type];
extensions = [{
  pack(date4, allocateForWrite, pack3) {
    let seconds2 = date4.getTime() / 1e3;
    if ((this.useTimestamp32 || date4.getMilliseconds() === 0) && seconds2 >= 0 && seconds2 < 4294967296) {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(6);
      target2[position3++] = 214;
      target2[position3++] = 255;
      targetView2.setUint32(position3, seconds2);
    } else if (seconds2 > 0 && seconds2 < 4294967296) {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(10);
      target2[position3++] = 215;
      target2[position3++] = 255;
      targetView2.setUint32(position3, date4.getMilliseconds() * 4e6 + (seconds2 / 1e3 / 4294967296 >> 0));
      targetView2.setUint32(position3 + 4, seconds2);
    } else if (isNaN(seconds2)) {
      if (this.onInvalidDate) {
        allocateForWrite(0);
        return pack3(this.onInvalidDate());
      }
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(3);
      target2[position3++] = 212;
      target2[position3++] = 255;
      target2[position3++] = 255;
    } else {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(15);
      target2[position3++] = 199;
      target2[position3++] = 12;
      target2[position3++] = 255;
      targetView2.setUint32(position3, date4.getMilliseconds() * 1e6);
      targetView2.setBigInt64(position3 + 4, BigInt(Math.floor(seconds2)));
    }
  }
}, {
  pack(set15, allocateForWrite, pack3) {
    if (this.setAsEmptyObject) {
      allocateForWrite(0);
      return pack3({});
    }
    let array6 = Array.from(set15);
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 115;
      target2[position3++] = 0;
    }
    pack3(array6);
  }
}, {
  pack(error3, allocateForWrite, pack3) {
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 101;
      target2[position3++] = 0;
    }
    pack3([error3.name, error3.message, error3.cause]);
  }
}, {
  pack(regex, allocateForWrite, pack3) {
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 120;
      target2[position3++] = 0;
    }
    pack3([regex.source, regex.flags]);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 16, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(typedArray, allocateForWrite) {
    let constructor = typedArray.constructor;
    if (constructor !== ByteArray && this.moreTypes)
      writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);
    else
      writeBuffer(typedArray, allocateForWrite);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 17, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(c1, allocateForWrite) {
    let { target: target2, position: position3 } = allocateForWrite(1);
    target2[position3] = 193;
  }
}];
function writeExtBuffer(typedArray, type3, allocateForWrite, encode7) {
  let length4 = typedArray.byteLength;
  if (length4 + 1 < 256) {
    var { target: target2, position: position3 } = allocateForWrite(4 + length4);
    target2[position3++] = 199;
    target2[position3++] = length4 + 1;
  } else if (length4 + 1 < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(5 + length4);
    target2[position3++] = 200;
    target2[position3++] = length4 + 1 >> 8;
    target2[position3++] = length4 + 1 & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(7 + length4);
    target2[position3++] = 201;
    targetView2.setUint32(position3, length4 + 1);
    position3 += 4;
  }
  target2[position3++] = 116;
  target2[position3++] = type3;
  if (!typedArray.buffer)
    typedArray = new Uint8Array(typedArray);
  target2.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position3);
}
__name(writeExtBuffer, "writeExtBuffer");
function writeBuffer(buffer4, allocateForWrite) {
  let length4 = buffer4.byteLength;
  var target2, position3;
  if (length4 < 256) {
    var { target: target2, position: position3 } = allocateForWrite(length4 + 2);
    target2[position3++] = 196;
    target2[position3++] = length4;
  } else if (length4 < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(length4 + 3);
    target2[position3++] = 197;
    target2[position3++] = length4 >> 8;
    target2[position3++] = length4 & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(length4 + 5);
    target2[position3++] = 198;
    targetView2.setUint32(position3, length4);
    position3 += 4;
  }
  target2.set(buffer4, position3);
}
__name(writeBuffer, "writeBuffer");
function writeExtensionData(result, target2, position3, type3) {
  let length4 = result.length;
  switch (length4) {
    case 1:
      target2[position3++] = 212;
      break;
    case 2:
      target2[position3++] = 213;
      break;
    case 4:
      target2[position3++] = 214;
      break;
    case 8:
      target2[position3++] = 215;
      break;
    case 16:
      target2[position3++] = 216;
      break;
    default:
      if (length4 < 256) {
        target2[position3++] = 199;
        target2[position3++] = length4;
      } else if (length4 < 65536) {
        target2[position3++] = 200;
        target2[position3++] = length4 >> 8;
        target2[position3++] = length4 & 255;
      } else {
        target2[position3++] = 201;
        target2[position3++] = length4 >> 24;
        target2[position3++] = length4 >> 16 & 255;
        target2[position3++] = length4 >> 8 & 255;
        target2[position3++] = length4 & 255;
      }
  }
  target2[position3++] = type3;
  target2.set(result, position3);
  position3 += length4;
  return position3;
}
__name(writeExtensionData, "writeExtensionData");
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 6;
  let lastEnd = serialized.length - distanceToMove;
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    let id3 = nextId.id;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 6;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 214;
    serialized[position3++] = 105;
    serialized[position3++] = id3 >> 24;
    serialized[position3++] = id3 >> 16 & 255;
    serialized[position3++] = id3 >> 8 & 255;
    serialized[position3++] = id3 & 255;
    lastEnd = offset;
  }
  return serialized;
}
__name(insertIds, "insertIds");
function writeBundles(start3, pack3, incrementPosition) {
  if (bundledStrings2.length > 0) {
    targetView.setUint32(bundledStrings2.position + start3, position2 + incrementPosition - bundledStrings2.position - start3);
    bundledStrings2.stringsPosition = position2 - start3;
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    pack3(writeStrings[0]);
    pack3(writeStrings[1]);
  }
}
__name(writeBundles, "writeBundles");
function prepareStructures(structures, packr) {
  structures.isCompatible = (existingStructures) => {
    let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
    if (!compatible)
      packr._mergeStructures(existingStructures);
    return compatible;
  };
  return structures;
}
__name(prepareStructures, "prepareStructures");
var defaultPackr = new Packr({ useRecords: false });
var pack2 = defaultPackr.pack;
var encode6 = defaultPackr.pack;
var { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var RESERVE_START_SPACE = 2048;

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcSerialization.js
var RpcSerialization = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcSerialization")()) {
};
__name(RpcSerialization, "RpcSerialization");
var json4 = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/json",
  includesFraming: false,
  unsafeMake: () => {
    const decoder3 = new TextDecoder();
    return {
      decode: (bytes) => [JSON.parse(typeof bytes === "string" ? bytes : decoder3.decode(bytes))],
      encode: (response) => JSON.stringify(response)
    };
  }
});
var ndjson = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/ndjson",
  includesFraming: true,
  unsafeMake: () => {
    const decoder3 = new TextDecoder();
    let buffer4 = "";
    return {
      decode: (bytes) => {
        buffer4 += typeof bytes === "string" ? bytes : decoder3.decode(bytes);
        let position3 = 0;
        let nlIndex = buffer4.indexOf("\n", position3);
        const items = [];
        while (nlIndex !== -1) {
          const item = JSON.parse(buffer4.slice(position3, nlIndex));
          items.push(item);
          position3 = nlIndex + 1;
          nlIndex = buffer4.indexOf("\n", position3);
        }
        buffer4 = buffer4.slice(position3);
        return items;
      },
      encode: (response) => {
        if (Array.isArray(response)) {
          if (response.length === 0)
            return void 0;
          let data = "";
          for (let i = 0; i < response.length; i++) {
            data += JSON.stringify(response[i]) + "\n";
          }
          return data;
        }
        return JSON.stringify(response) + "\n";
      }
    };
  }
});
var jsonRpc = /* @__PURE__ */ __name((options4) => RpcSerialization.of({
  contentType: options4?.contentType ?? "application/json",
  includesFraming: false,
  unsafeMake: () => {
    const decoder3 = new TextDecoder();
    const batches = /* @__PURE__ */ new Map();
    return {
      decode: (bytes) => {
        const decoded = JSON.parse(typeof bytes === "string" ? bytes : decoder3.decode(bytes));
        return decodeJsonRpcRaw(decoded, batches);
      },
      encode: (response) => {
        if (Array.isArray(response)) {
          if (response.length === 0)
            return void 0;
          return JSON.stringify(response.map(encodeJsonRpcMessage));
        }
        const encoded = encodeJsonRpcRaw(response, batches);
        return encoded && JSON.stringify(encoded);
      }
    };
  }
}), "jsonRpc");
var ndJsonRpc = /* @__PURE__ */ __name((options4) => RpcSerialization.of({
  contentType: options4?.contentType ?? "application/json-rpc",
  includesFraming: true,
  unsafeMake: () => {
    const parser = ndjson.unsafeMake();
    const batches = /* @__PURE__ */ new Map();
    return {
      decode: (bytes) => {
        const frames = parser.decode(bytes);
        if (frames.length === 0)
          return [];
        const messages = [];
        for (let i = 0; i < frames.length; i++) {
          const frame = frames[i];
          messages.push(...decodeJsonRpcRaw(frame, batches));
        }
        return messages;
      },
      encode: (response) => {
        if (Array.isArray(response)) {
          return parser.encode(response.map(encodeJsonRpcMessage));
        }
        const encoded = encodeJsonRpcRaw(response, batches);
        return encoded && parser.encode(encoded);
      }
    };
  }
}), "ndJsonRpc");
function decodeJsonRpcRaw(decoded, batches) {
  if (Array.isArray(decoded)) {
    const batch = {
      size: 0,
      responses: /* @__PURE__ */ new Map()
    };
    const messages = [];
    for (let i = 0; i < decoded.length; i++) {
      const message = decodeJsonRpcMessage(decoded[i]);
      if (message._tag === "Request") {
        batch.size++;
        batches.set(message.id, batch);
      }
    }
    return messages;
  }
  return Array.isArray(decoded) ? decoded.map(decodeJsonRpcMessage) : [decodeJsonRpcMessage(decoded)];
}
__name(decodeJsonRpcRaw, "decodeJsonRpcRaw");
function decodeJsonRpcMessage(decoded) {
  if ("method" in decoded) {
    if (!decoded.id && decoded.method.startsWith("@effect/rpc/")) {
      const tag8 = decoded.method.slice("@effect/rpc/".length);
      const requestId = decoded.params?.requestId;
      return requestId ? {
        _tag: tag8,
        requestId: String(requestId)
      } : {
        _tag: tag8
      };
    }
    return {
      _tag: "Request",
      id: decoded.id ? String(decoded.id) : "",
      tag: decoded.method,
      payload: decoded.params,
      headers: decoded.headers ?? [],
      traceId: decoded.traceId,
      spanId: decoded.spanId,
      sampled: decoded.sampled
    };
  } else if (decoded.error && decoded.error._tag === "Defect") {
    return {
      _tag: "Defect",
      defect: decoded.error.data
    };
  } else if (decoded.chunk === true) {
    return {
      _tag: "Chunk",
      requestId: String(decoded.id),
      values: decoded.result
    };
  }
  return {
    _tag: "Exit",
    requestId: String(decoded.id),
    exit: decoded.error != null ? {
      _tag: "Failure",
      cause: decoded.error._tag === "Cause" ? decoded.error.data : {
        _tag: "Die",
        defect: decoded.error
      }
    } : {
      _tag: "Success",
      value: decoded.result
    }
  };
}
__name(decodeJsonRpcMessage, "decodeJsonRpcMessage");
function encodeJsonRpcRaw(response, batches) {
  if (!("requestId" in response)) {
    return encodeJsonRpcMessage(response);
  }
  const batch = batches.get(response.requestId);
  if (batch) {
    batches.delete(response.requestId);
    batch.responses.set(response.requestId, response);
    if (batch.size === batch.responses.size) {
      return Array.from(batch.responses.values(), encodeJsonRpcMessage);
    }
    return void 0;
  }
  return encodeJsonRpcMessage(response);
}
__name(encodeJsonRpcRaw, "encodeJsonRpcRaw");
function encodeJsonRpcMessage(response) {
  switch (response._tag) {
    case "Request":
      return {
        jsonrpc: "2.0",
        method: response.tag,
        params: response.payload,
        id: response.id && Number(response.id),
        headers: response.headers,
        traceId: response.traceId,
        spanId: response.spanId,
        sampled: response.sampled
      };
    case "Ping":
    case "Pong":
    case "Interrupt":
    case "Ack":
    case "Eof":
      return {
        jsonrpc: "2.0",
        method: `@effect/rpc/${response._tag}`,
        params: "requestId" in response ? {
          requestId: response.requestId
        } : void 0
      };
    case "Chunk":
      return {
        jsonrpc: "2.0",
        chunk: true,
        id: Number(response.requestId),
        result: response.values
      };
    case "Exit":
      return {
        jsonrpc: "2.0",
        id: response.requestId ? Number(response.requestId) : void 0,
        result: response.exit._tag === "Success" ? response.exit.value : void 0,
        error: response.exit._tag === "Failure" ? {
          _tag: "Cause",
          code: response.exit.cause._tag === "Fail" && hasProperty(response.exit.cause.error, "code") ? Number(response.exit.cause.error.code) : 0,
          message: response.exit.cause._tag === "Fail" && hasProperty(response.exit.cause.error, "message") ? response.exit.cause.error.message : JSON.stringify(response.exit.cause),
          data: response.exit.cause
        } : void 0
      };
    case "Defect":
      return {
        jsonrpc: "2.0",
        id: jsonRpcInternalError,
        error: {
          _tag: "Defect",
          code: 1,
          message: "A defect occurred",
          data: response.defect
        }
      };
    case "ClientProtocolError":
      return {};
  }
}
__name(encodeJsonRpcMessage, "encodeJsonRpcMessage");
var jsonRpcInternalError = -32603;
var msgPack = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/msgpack",
  includesFraming: true,
  unsafeMake: () => {
    const unpackr = new Unpackr();
    const packr = new Packr();
    const encoder3 = new TextEncoder();
    let incomplete = void 0;
    return {
      decode: (bytes) => {
        let buf = typeof bytes === "string" ? encoder3.encode(bytes) : bytes;
        if (incomplete !== void 0) {
          const prev = buf;
          bytes = new Uint8Array(incomplete.length + buf.length);
          bytes.set(incomplete);
          bytes.set(prev, incomplete.length);
          buf = bytes;
          incomplete = void 0;
        }
        try {
          return unpackr.unpackMultiple(buf);
        } catch (error_) {
          const error3 = error_;
          if (error3.incomplete) {
            incomplete = buf.subarray(error3.lastPosition);
            return error3.values ?? [];
          }
          return [];
        }
      },
      encode: (response) => packr.pack(response)
    };
  }
});
var layerJson = /* @__PURE__ */ succeed12(RpcSerialization, json4);
var layerNdjson = /* @__PURE__ */ succeed12(RpcSerialization, ndjson);
var layerJsonRpc = /* @__PURE__ */ __name((options4) => succeed12(RpcSerialization, jsonRpc(options4)), "layerJsonRpc");
var layerNdJsonRpc = /* @__PURE__ */ __name((options4) => succeed12(RpcSerialization, ndJsonRpc(options4)), "layerNdJsonRpc");
var layerMsgPack = /* @__PURE__ */ succeed12(RpcSerialization, msgPack);

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcServer.js
var RpcServer_exports = {};
__export(RpcServer_exports, {
  Protocol: () => Protocol,
  fiberIdClientInterrupt: () => fiberIdClientInterrupt,
  layer: () => layer5,
  layerHttpRouter: () => layerHttpRouter,
  layerProtocolHttp: () => layerProtocolHttp,
  layerProtocolHttpRouter: () => layerProtocolHttpRouter,
  layerProtocolSocketServer: () => layerProtocolSocketServer,
  layerProtocolStdio: () => layerProtocolStdio,
  layerProtocolWebsocket: () => layerProtocolWebsocket,
  layerProtocolWebsocketRouter: () => layerProtocolWebsocketRouter,
  layerProtocolWorkerRunner: () => layerProtocolWorkerRunner,
  make: () => make85,
  makeNoSerialization: () => makeNoSerialization,
  makeProtocolHttp: () => makeProtocolHttp,
  makeProtocolHttpRouter: () => makeProtocolHttpRouter,
  makeProtocolSocketServer: () => makeProtocolSocketServer,
  makeProtocolStdio: () => makeProtocolStdio,
  makeProtocolWebsocket: () => makeProtocolWebsocket,
  makeProtocolWebsocketRouter: () => makeProtocolWebsocketRouter,
  makeProtocolWithHttpApp: () => makeProtocolWithHttpApp,
  makeProtocolWithHttpAppWebsocket: () => makeProtocolWithHttpAppWebsocket,
  makeProtocolWorkerRunner: () => makeProtocolWorkerRunner,
  toHttpApp: () => toHttpApp2,
  toHttpAppWebsocket: () => toHttpAppWebsocket,
  toWebHandler: () => toWebHandler2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpApp.js
var HttpApp_exports = {};
__export(HttpApp_exports, {
  appendPreResponseHandler: () => appendPreResponseHandler2,
  currentPreResponseHandlers: () => currentPreResponseHandlers2,
  ejectDefaultScopeClose: () => ejectDefaultScopeClose,
  toHandled: () => toHandled,
  toWebHandler: () => toWebHandler,
  toWebHandlerLayer: () => toWebHandlerLayer,
  toWebHandlerLayerWith: () => toWebHandlerLayerWith,
  toWebHandlerRuntime: () => toWebHandlerRuntime,
  unsafeEjectStreamScope: () => unsafeEjectStreamScope,
  withPreResponseHandler: () => withPreResponseHandler2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerRespondable.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerResponse.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServerResponse.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId39 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerResponse");
var respondableSymbol = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRespondable");
var ServerResponseImpl = class extends StructuralClass {
  status;
  statusText;
  cookies;
  body;
  [TypeId39];
  headers;
  constructor(status3, statusText, headers, cookies, body) {
    super();
    this.status = status3;
    this.statusText = statusText;
    this.cookies = cookies;
    this.body = body;
    this[TypeId39] = TypeId39;
    if (body.contentType || body.contentLength) {
      const newHeaders = {
        ...headers
      };
      if (body.contentType) {
        newHeaders["content-type"] = body.contentType;
      }
      if (body.contentLength) {
        newHeaders["content-length"] = body.contentLength.toString();
      }
      this.headers = newHeaders;
    } else {
      this.headers = headers;
    }
  }
  commit() {
    return succeed10(this);
  }
  [respondableSymbol]() {
    return succeed10(this);
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  toString() {
    return format(this);
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpServerResponse",
      status: this.status,
      statusText: this.statusText,
      headers: redact(this.headers),
      cookies: this.cookies.toJSON(),
      body: this.body.toJSON()
    };
  }
};
__name(ServerResponseImpl, "ServerResponseImpl");
var isServerResponse = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && TypeId39 in u, "isServerResponse");
var empty41 = /* @__PURE__ */ __name((options4) => new ServerResponseImpl(options4?.status ?? 204, options4?.statusText, options4?.headers ? fromInput3(options4.headers) : empty36, options4?.cookies ?? empty39, empty38), "empty");
var uint8Array3 = /* @__PURE__ */ __name((body, options4) => {
  const headers = options4?.headers ? fromInput3(options4.headers) : empty36;
  return new ServerResponseImpl(options4?.status ?? 200, options4?.statusText, headers, options4?.cookies ?? empty39, uint8Array2(body, getContentType(options4, headers)));
}, "uint8Array");
var text2 = /* @__PURE__ */ __name((body, options4) => {
  const headers = options4?.headers ? fromInput3(options4.headers) : empty36;
  return new ServerResponseImpl(options4?.status ?? 200, options4?.statusText, headers, options4?.cookies ?? empty39, text(body, getContentType(options4, headers)));
}, "text");
var stream4 = /* @__PURE__ */ __name((body, options4) => {
  const headers = options4?.headers ? fromInput3(options4.headers) : empty36;
  return new ServerResponseImpl(options4?.status ?? 200, options4?.statusText, headers, options4?.cookies ?? empty39, stream2(body, getContentType(options4, headers), options4?.contentLength));
}, "stream");
var getContentType = /* @__PURE__ */ __name((options4, headers) => {
  if (options4?.contentType) {
    return options4.contentType;
  } else if (options4?.headers) {
    return headers["content-type"];
  } else {
    return;
  }
}, "getContentType");
var setBody2 = /* @__PURE__ */ dual(2, (self2, body) => {
  let headers = self2.headers;
  if (body._tag === "Empty") {
    headers = remove11(remove11(headers, "Content-Type"), "Content-length");
  }
  return new ServerResponseImpl(self2.status, self2.statusText, headers, self2.cookies, body);
});
var toWeb = /* @__PURE__ */ __name((response, options4) => {
  const headers = new globalThis.Headers(response.headers);
  if (!isEmpty16(response.cookies)) {
    const toAdd = toSetCookieHeaders(response.cookies);
    for (const header of toAdd) {
      headers.append("set-cookie", header);
    }
  }
  if (options4?.withoutBody) {
    return new Response(void 0, {
      status: response.status,
      statusText: response.statusText,
      headers
    });
  }
  const body = response.body;
  switch (body._tag) {
    case "Empty": {
      return new Response(void 0, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "Uint8Array":
    case "Raw": {
      if (body.body instanceof Response) {
        for (const [key, value6] of headers) {
          body.body.headers.set(key, value6);
        }
        return body.body;
      }
      return new Response(body.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "FormData": {
      return new Response(body.formData, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "Stream": {
      return new Response(toReadableStreamRuntime2(body.stream, options4?.runtime ?? defaultRuntime2), {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
  }
}, "toWeb");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerResponse.js
var isServerResponse2 = isServerResponse;
var empty42 = empty41;
var uint8Array4 = uint8Array3;
var text3 = text2;
var stream5 = stream4;
var setBody3 = setBody2;
var toWeb2 = toWeb;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerRespondable.js
var symbol5 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRespondable");
var isRespondable = /* @__PURE__ */ __name((u) => hasProperty(u, symbol5), "isRespondable");
var badRequest = /* @__PURE__ */ empty42({
  status: 400
});
var notFound2 = /* @__PURE__ */ empty42({
  status: 404
});
var toResponse = /* @__PURE__ */ __name((self2) => {
  if (isServerResponse2(self2)) {
    return succeed10(self2);
  }
  return orDie3(self2[symbol5]());
}, "toResponse");
var toResponseOrElse = /* @__PURE__ */ __name((u, orElse16) => {
  if (isServerResponse2(u)) {
    return succeed10(u);
  } else if (isRespondable(u)) {
    return catchAllCause3(u[symbol5](), () => succeed10(orElse16));
  } else if (isParseError(u)) {
    return succeed10(badRequest);
  } else if (isNoSuchElementException2(u)) {
    return succeed10(notFound2);
  }
  return succeed10(orElse16);
}, "toResponseOrElse");
var toResponseOrElseDefect = /* @__PURE__ */ __name((u, orElse16) => {
  if (isServerResponse2(u)) {
    return succeed10(u);
  } else if (isRespondable(u)) {
    return catchAllCause3(u[symbol5](), () => succeed10(orElse16));
  }
  return succeed10(orElse16);
}, "toResponseOrElseDefect");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServerError.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var TypeId40 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerError");
var clientAbortFiberId = /* @__PURE__ */ globalValue("@effect/platform/HttpServerError/clientAbortFiberId", () => runtime2(-499, 0));
var causeResponse = /* @__PURE__ */ __name((cause3) => {
  const [effect4, stripped] = reduce11(cause3, [succeed10(internalServerError), empty26], (acc, cause4) => {
    switch (cause4._tag) {
      case "Empty": {
        return some3(acc);
      }
      case "Fail": {
        return some3([toResponseOrElse(cause4.error, internalServerError), cause4]);
      }
      case "Die": {
        return some3([toResponseOrElseDefect(cause4.defect, internalServerError), cause4]);
      }
      case "Interrupt": {
        if (acc[1]._tag !== "Empty") {
          return none2();
        }
        const response = cause4.fiberId === clientAbortFiberId ? clientAbortError : serverAbortError;
        return some3([succeed10(response), cause4]);
      }
      default: {
        return none2();
      }
    }
  });
  return map20(effect4, (response) => {
    if (isEmptyType2(stripped)) {
      return [response, die4(response)];
    }
    return [response, sequential4(stripped, die4(response))];
  });
}, "causeResponse");
var causeResponseStripped = /* @__PURE__ */ __name((cause3) => {
  let response;
  const stripped = stripSomeDefects2(cause3, (defect) => {
    if (isServerResponse(defect)) {
      response = defect;
      return some3(empty26);
    }
    return none2();
  });
  return [response ?? internalServerError, stripped];
}, "causeResponseStripped");
var internalServerError = /* @__PURE__ */ empty41({
  status: 500
});
var clientAbortError = /* @__PURE__ */ empty41({
  status: 499
});
var serverAbortError = /* @__PURE__ */ empty41({
  status: 503
});
var exitResponse = /* @__PURE__ */ __name((exit4) => {
  if (exit4._tag === "Success") {
    return exit4.value;
  }
  return causeResponseStripped(exit4.cause)[0];
}, "exitResponse");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerError.js
var TypeId41 = TypeId40;
var RequestError2 = class extends (/* @__PURE__ */ TypeIdError(TypeId41, "RequestError")) {
  /**
   * @since 1.0.0
   */
  [symbol5]() {
    return empty42({
      status: 400
    });
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    return this.description ? `${this.reason}: ${this.description} (${this.methodAndUrl})` : `${this.reason} error (${this.methodAndUrl})`;
  }
};
__name(RequestError2, "RequestError");
var RouteNotFound = class extends (/* @__PURE__ */ TypeIdError(TypeId41, "RouteNotFound")) {
  constructor(options4) {
    super(options4);
    this.stack = `${this.name}: ${this.message}`;
  }
  /**
   * @since 1.0.0
   */
  [symbol5]() {
    return empty42({
      status: 404
    });
  }
  get message() {
    return `${this.request.method} ${this.request.url} not found`;
  }
};
__name(RouteNotFound, "RouteNotFound");
var ResponseError2 = class extends (/* @__PURE__ */ TypeIdError(TypeId41, "ResponseError")) {
  /**
   * @since 1.0.0
   */
  [symbol5]() {
    return empty42({
      status: 500
    });
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    const info2 = `${this.response.status} ${this.methodAndUrl}`;
    return this.description ? `${this.description} (${info2})` : `${this.reason} error (${info2})`;
  }
};
__name(ResponseError2, "ResponseError");
var clientAbortFiberId2 = clientAbortFiberId;
var causeResponse2 = causeResponse;
var exitResponse2 = exitResponse;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServerRequest.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Multipart.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/multipart.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/contentType.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
var mediaTypeRENoSlash = /^[!#$%&'*+.^\w|~-]+$/u;
var defaultContentType = {
  value: "",
  parameters: /* @__PURE__ */ Object.create(null)
};
function parse2(header, withoutSlash = false) {
  if (typeof header !== "string") {
    return defaultContentType;
  }
  let index2 = header.indexOf(";");
  const type3 = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
  const mediaRE = withoutSlash ? mediaTypeRENoSlash : mediaTypeRE;
  if (mediaRE.test(type3) === false) {
    return defaultContentType;
  }
  const result = {
    value: type3.toLowerCase(),
    parameters: /* @__PURE__ */ Object.create(null)
  };
  if (index2 === -1) {
    return result;
  }
  let key;
  let match21;
  let value6;
  paramRE.lastIndex = index2;
  while (match21 = paramRE.exec(header)) {
    if (match21.index !== index2) {
      return defaultContentType;
    }
    index2 += match21[0].length;
    key = match21[1].toLowerCase();
    value6 = match21[2];
    if (value6[0] === '"') {
      value6 = value6.slice(1, value6.length - 1);
      !withoutSlash && quotedPairRE.test(value6) && (value6 = value6.replace(quotedPairRE, "$1"));
    }
    result.parameters[key] = value6;
  }
  if (index2 !== header.length) {
    return defaultContentType;
  }
  return result;
}
__name(parse2, "parse");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/headers.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var constMaxPairs = 100;
var constMaxSize = 16 * 1024;
var State;
(function(State3) {
  State3[State3["key"] = 0] = "key";
  State3[State3["whitespace"] = 1] = "whitespace";
  State3[State3["value"] = 2] = "value";
})(State || (State = {}));
var constContinue = {
  _tag: "Continue"
};
var constNameChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1];
var constValueChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
function make74() {
  const decoder3 = new TextDecoder();
  const state = {
    state: State.key,
    headers: /* @__PURE__ */ Object.create(null),
    key: "",
    value: void 0,
    crlf: 0,
    previousChunk: void 0,
    pairs: 0,
    size: 0
  };
  function reset2(value6) {
    state.state = State.key;
    state.headers = /* @__PURE__ */ Object.create(null);
    state.key = "";
    state.value = void 0;
    state.crlf = 0;
    state.previousChunk = void 0;
    state.pairs = 0;
    state.size = 0;
    return value6;
  }
  __name(reset2, "reset");
  function concatUint8Array(a, b) {
    const newUint8Array = new Uint8Array(a.length + b.length);
    newUint8Array.set(a);
    newUint8Array.set(b, a.length);
    return newUint8Array;
  }
  __name(concatUint8Array, "concatUint8Array");
  function error3(reason) {
    return reset2({
      _tag: "Failure",
      reason,
      headers: state.headers
    });
  }
  __name(error3, "error");
  return /* @__PURE__ */ __name(function write3(chunk4, start3) {
    let endOffset = 0;
    let previousCursor;
    if (state.previousChunk !== void 0) {
      endOffset = state.previousChunk.length;
      previousCursor = endOffset;
      const newChunk = new Uint8Array(chunk4.length + endOffset);
      newChunk.set(state.previousChunk);
      newChunk.set(chunk4, endOffset);
      state.previousChunk = void 0;
      chunk4 = newChunk;
    }
    const end6 = chunk4.length;
    outer:
      while (start3 < end6) {
        if (state.state === State.key) {
          let i = start3;
          for (; i < end6; i++) {
            if (state.size++ > constMaxSize) {
              return error3("HeaderTooLarge");
            }
            if (chunk4[i] === 58) {
              state.key += decoder3.decode(chunk4.subarray(start3, i)).toLowerCase();
              if (state.key.length === 0) {
                return error3("InvalidHeaderName");
              }
              if (chunk4[i + 1] === 32 && chunk4[i + 2] !== 32 && chunk4[i + 2] !== 9) {
                start3 = i + 2;
                state.state = State.value;
                state.size++;
              } else if (chunk4[i + 1] !== 32 && chunk4[i + 1] !== 9) {
                start3 = i + 1;
                state.state = State.value;
              } else {
                start3 = i + 1;
                state.state = State.whitespace;
              }
              break;
            } else if (constNameChars[chunk4[i]] !== 1) {
              return error3("InvalidHeaderName");
            }
          }
          if (i === end6) {
            state.key += decoder3.decode(chunk4.subarray(start3, end6)).toLowerCase();
            return constContinue;
          }
        }
        if (state.state === State.whitespace) {
          for (; start3 < end6; start3++) {
            if (state.size++ > constMaxSize) {
              return error3("HeaderTooLarge");
            }
            if (chunk4[start3] !== 32 && chunk4[start3] !== 9) {
              state.state = State.value;
              break;
            }
          }
          if (start3 === end6) {
            return constContinue;
          }
        }
        if (state.state === State.value) {
          let i = start3;
          if (previousCursor !== void 0) {
            i = previousCursor;
            previousCursor = void 0;
          }
          for (; i < end6; i++) {
            if (state.size++ > constMaxSize) {
              return error3("HeaderTooLarge");
            }
            if (chunk4[i] === 13 || state.crlf > 0) {
              let byte = chunk4[i];
              if (byte === 13 && state.crlf === 0) {
                state.crlf = 1;
                i++;
                state.size++;
                byte = chunk4[i];
              }
              if (byte === 10 && state.crlf === 1) {
                state.crlf = 2;
                i++;
                state.size++;
                byte = chunk4[i];
              }
              if (byte === 13 && state.crlf === 2) {
                state.crlf = 3;
                i++;
                state.size++;
                byte = chunk4[i];
              }
              if (byte === 10 && state.crlf === 3) {
                state.crlf = 4;
                i++;
                state.size++;
              }
              if (state.crlf < 4 && i >= end6) {
                state.previousChunk = chunk4.subarray(start3);
                return constContinue;
              } else if (state.crlf >= 2) {
                state.value = state.value === void 0 ? chunk4.subarray(start3, i - state.crlf) : concatUint8Array(state.value, chunk4.subarray(start3, i - state.crlf));
                const value6 = decoder3.decode(state.value);
                if (state.headers[state.key] === void 0) {
                  state.headers[state.key] = value6;
                } else if (typeof state.headers[state.key] === "string") {
                  state.headers[state.key] = [state.headers[state.key], value6];
                } else {
                  ;
                  state.headers[state.key].push(value6);
                }
                start3 = i;
                state.size--;
                if (state.crlf !== 4 && state.pairs === constMaxPairs) {
                  return error3("TooManyHeaders");
                } else if (state.crlf === 3) {
                  return error3("InvalidHeaderValue");
                } else if (state.crlf === 4) {
                  return reset2({
                    _tag: "Headers",
                    headers: state.headers,
                    endPosition: start3 - endOffset
                  });
                }
                state.pairs++;
                state.key = "";
                state.value = void 0;
                state.crlf = 0;
                state.state = State.key;
                continue outer;
              }
            } else if (constValueChars[chunk4[i]] !== 1) {
              return error3("InvalidHeaderValue");
            }
          }
          if (i === end6) {
            state.value = state.value === void 0 ? chunk4.subarray(start3, end6) : concatUint8Array(state.value, chunk4.subarray(start3, end6));
            return constContinue;
          }
        }
      }
    if (start3 > end6) {
      state.size += end6 - start3;
    }
    return constContinue;
  }, "write");
}
__name(make74, "make");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/search.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function makeState(needle_) {
  const needle = new TextEncoder().encode(needle_);
  const needleLength = needle.length;
  const indexes = {};
  for (let i = 0; i < needleLength; i++) {
    const b = needle[i];
    if (indexes[b] === void 0)
      indexes[b] = [];
    indexes[b].push(i);
  }
  return {
    needle,
    needleLength,
    indexes,
    firstByte: needle[0],
    previousChunk: void 0,
    previousChunkLength: 0,
    matchIndex: 0
  };
}
__name(makeState, "makeState");
function make75(needle, callback, seed) {
  const state = makeState(needle);
  if (seed !== void 0) {
    state.previousChunk = seed;
    state.previousChunkLength = seed.length;
  }
  function makeIndexOf() {
    if ("Buffer" in globalThis && !("Bun" in globalThis || "Deno" in globalThis)) {
      return function(chunk4, needle2, fromIndex) {
        return Buffer.prototype.indexOf.call(chunk4, needle2, fromIndex);
      };
    }
    const skipTable = new Uint8Array(256).fill(state.needle.length);
    for (let i = 0, lastIndex = state.needle.length - 1; i < lastIndex; ++i) {
      skipTable[state.needle[i]] = lastIndex - i;
    }
    return function(chunk4, needle2, fromIndex) {
      const lengthTotal = chunk4.length;
      let i = fromIndex + state.needleLength - 1;
      while (i < lengthTotal) {
        for (let j = state.needleLength - 1, k = i; j >= 0 && chunk4[k] === needle2[j]; j--, k--) {
          if (j === 0)
            return k;
        }
        i += skipTable[chunk4[i]];
      }
      return -1;
    };
  }
  __name(makeIndexOf, "makeIndexOf");
  const indexOf = makeIndexOf();
  function write3(chunk4) {
    let chunkLength = chunk4.length;
    if (state.previousChunk !== void 0) {
      const newChunk = new Uint8Array(state.previousChunkLength + chunkLength);
      newChunk.set(state.previousChunk);
      newChunk.set(chunk4, state.previousChunkLength);
      chunk4 = newChunk;
      chunkLength = state.previousChunkLength + chunkLength;
      state.previousChunk = void 0;
    }
    if (chunkLength < state.needleLength) {
      state.previousChunk = chunk4;
      state.previousChunkLength = chunkLength;
      return;
    }
    let pos = 0;
    while (pos < chunkLength) {
      const match21 = indexOf(chunk4, state.needle, pos);
      if (match21 > -1) {
        if (match21 > pos) {
          callback(state.matchIndex, chunk4.subarray(pos, match21));
        }
        state.matchIndex += 1;
        pos = match21 + state.needleLength;
        continue;
      } else if (chunk4[chunkLength - 1] in state.indexes) {
        const indexes = state.indexes[chunk4[chunkLength - 1]];
        let earliestIndex = -1;
        for (let i = 0, len = indexes.length; i < len; i++) {
          const index2 = indexes[i];
          if (chunk4[chunkLength - 1 - index2] === state.firstByte && i > earliestIndex) {
            earliestIndex = index2;
          }
        }
        if (earliestIndex === -1) {
          if (pos === 0) {
            callback(state.matchIndex, chunk4);
          } else {
            callback(state.matchIndex, chunk4.subarray(pos));
          }
        } else {
          if (chunkLength - 1 - earliestIndex > pos) {
            callback(state.matchIndex, chunk4.subarray(pos, chunkLength - 1 - earliestIndex));
          }
          state.previousChunk = chunk4.subarray(chunkLength - 1 - earliestIndex);
          state.previousChunkLength = earliestIndex + 1;
        }
      } else if (pos === 0) {
        callback(state.matchIndex, chunk4);
      } else {
        callback(state.matchIndex, chunk4.subarray(pos));
      }
      break;
    }
  }
  __name(write3, "write");
  function end6() {
    if (state.previousChunk !== void 0 && state.previousChunk !== seed) {
      callback(state.matchIndex, state.previousChunk);
    }
    state.previousChunk = seed;
    state.previousChunkLength = seed?.length ?? 0;
    state.matchIndex = 0;
  }
  __name(end6, "end");
  return {
    write: write3,
    end: end6
  };
}
__name(make75, "make");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/multipart.js
var State2;
(function(State3) {
  State3[State3["headers"] = 0] = "headers";
  State3[State3["body"] = 1] = "body";
})(State2 || (State2 = {}));
var errInvalidDisposition = {
  _tag: "InvalidDisposition"
};
var errEndNotReached = {
  _tag: "EndNotReached"
};
var errMaxParts = {
  _tag: "ReachedLimit",
  limit: "MaxParts"
};
var errMaxTotalSize = {
  _tag: "ReachedLimit",
  limit: "MaxTotalSize"
};
var errMaxPartSize = {
  _tag: "ReachedLimit",
  limit: "MaxPartSize"
};
var errMaxFieldSize = {
  _tag: "ReachedLimit",
  limit: "MaxFieldSize"
};
var constCR = /* @__PURE__ */ new TextEncoder().encode("\r\n");
function defaultIsFile(info2) {
  return info2.filename !== void 0 || info2.contentType === "application/octet-stream";
}
__name(defaultIsFile, "defaultIsFile");
function parseBoundary(headers) {
  const contentType = parse2(headers["content-type"]);
  return contentType.parameters.boundary;
}
__name(parseBoundary, "parseBoundary");
function noopOnChunk(_chunk) {
}
__name(noopOnChunk, "noopOnChunk");
function make76({
  headers,
  onFile: onPart,
  onField,
  onError: onError5,
  onDone: onDone3,
  isFile = defaultIsFile,
  maxParts = Infinity,
  maxTotalSize = Infinity,
  maxPartSize = Infinity,
  maxFieldSize = 1024 * 1024
}) {
  const boundary = parseBoundary(headers);
  if (boundary === void 0) {
    onError5({
      _tag: "InvalidBoundary"
    });
    return {
      write: noopOnChunk,
      end() {
      }
    };
  }
  const state = {
    state: State2.headers,
    index: 0,
    parts: 0,
    onChunk: noopOnChunk,
    info: void 0,
    headerSkip: 0,
    partSize: 0,
    totalSize: 0,
    isFile: false,
    fieldChunks: [],
    fieldSize: 0
  };
  function skipBody() {
    state.state = State2.body;
    state.isFile = true;
    state.onChunk = noopOnChunk;
  }
  __name(skipBody, "skipBody");
  const headerParser = make74();
  const split5 = make75(`\r
--${boundary}`, function(index2, chunk4) {
    if (index2 === 0) {
      skipBody();
      return;
    } else if (index2 !== state.index) {
      if (state.index > 0) {
        if (state.isFile) {
          state.onChunk(null);
          state.partSize = 0;
        } else {
          if (state.fieldChunks.length === 1) {
            onField(state.info, state.fieldChunks[0]);
          } else {
            const buf = new Uint8Array(state.fieldSize);
            let offset = 0;
            for (let i = 0; i < state.fieldChunks.length; i++) {
              const chunk5 = state.fieldChunks[i];
              buf.set(chunk5, offset);
              offset += chunk5.length;
            }
            onField(state.info, buf);
          }
          state.fieldSize = 0;
          state.fieldChunks = [];
        }
      }
      state.state = State2.headers;
      state.index = index2;
      state.headerSkip = 2;
      if (chunk4[0] === 45 && chunk4[1] === 45) {
        return onDone3();
      }
      state.parts++;
      if (state.parts > maxParts) {
        onError5(errMaxParts);
      }
    }
    if ((state.partSize += chunk4.length) > maxPartSize) {
      onError5(errMaxPartSize);
    }
    if (state.state === State2.headers) {
      const result = headerParser(chunk4, state.headerSkip);
      state.headerSkip = 0;
      if (result._tag === "Continue") {
        return;
      } else if (result._tag === "Failure") {
        skipBody();
        return onError5({
          _tag: "BadHeaders",
          error: result
        });
      }
      const contentType = parse2(result.headers["content-type"]);
      const contentDisposition = parse2(result.headers["content-disposition"], true);
      if ("form-data" === contentDisposition.value && !("name" in contentDisposition.parameters)) {
        skipBody();
        return onError5(errInvalidDisposition);
      }
      let encodedFilename;
      if ("filename*" in contentDisposition.parameters) {
        const parts2 = contentDisposition.parameters["filename*"].split("''");
        if (parts2.length === 2) {
          encodedFilename = decodeURIComponent(parts2[1]);
        }
      }
      state.info = {
        name: contentDisposition.parameters.name ?? "",
        filename: encodedFilename ?? contentDisposition.parameters.filename,
        contentType: contentType.value === "" ? contentDisposition.parameters.filename !== void 0 ? "application/octet-stream" : "text/plain" : contentType.value,
        contentTypeParameters: contentType.parameters,
        contentDisposition: contentDisposition.value,
        contentDispositionParameters: contentDisposition.parameters,
        headers: result.headers
      };
      state.state = State2.body;
      state.isFile = isFile(state.info);
      if (state.isFile) {
        state.onChunk = onPart(state.info);
      }
      if (result.endPosition < chunk4.length) {
        if (state.isFile) {
          state.onChunk(chunk4.subarray(result.endPosition));
        } else {
          const buf = chunk4.subarray(result.endPosition);
          if ((state.fieldSize += buf.length) > maxFieldSize) {
            onError5(errMaxFieldSize);
          }
          state.fieldChunks.push(buf);
        }
      }
    } else if (state.isFile) {
      state.onChunk(chunk4);
    } else {
      if ((state.fieldSize += chunk4.length) > maxFieldSize) {
        onError5(errMaxFieldSize);
      }
      state.fieldChunks.push(chunk4);
    }
  }, constCR);
  return {
    write(chunk4) {
      if ((state.totalSize += chunk4.length) > maxTotalSize) {
        return onError5(errMaxTotalSize);
      }
      return split5.write(chunk4);
    },
    end() {
      split5.end();
      if (state.state === State2.body) {
        onError5(errEndNotReached);
      }
      state.state = State2.headers;
      state.index = 0;
      state.parts = 0;
      state.onChunk = noopOnChunk;
      state.info = void 0;
      state.totalSize = 0;
      state.partSize = 0;
      state.fieldChunks = [];
      state.fieldSize = 0;
    }
  };
}
__name(make76, "make");
var utf8Decoder = /* @__PURE__ */ new TextDecoder("utf-8");
function getDecoder(charset) {
  if (charset === "utf-8" || charset === "utf8" || charset === "") {
    return utf8Decoder;
  }
  try {
    return new TextDecoder(charset);
  } catch (error3) {
    return utf8Decoder;
  }
}
__name(getDecoder, "getDecoder");
function decodeField(info2, value6) {
  return getDecoder(info2.contentTypeParameters.charset ?? "utf-8").decode(value6);
}
__name(decodeField, "decodeField");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/index.js
var make77 = make76;
var defaultIsFile2 = defaultIsFile;
var decodeField2 = decodeField;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Multipart.js
var TypeId42 = /* @__PURE__ */ Symbol.for("@effect/platform/Multipart");
var ErrorTypeId2 = /* @__PURE__ */ Symbol.for("@effect/platform/Multipart/MultipartError");
var MultipartError = class extends (/* @__PURE__ */ TaggedError2()("MultipartError", {
  reason: /* @__PURE__ */ Literal2("FileTooLarge", "FieldTooLarge", "BodyTooLarge", "TooManyParts", "InternalError", "Parse"),
  cause: Defect
})) {
  /**
   * @since 1.0.0
   */
  [ErrorTypeId2] = ErrorTypeId2;
  /**
   * @since 1.0.0
   */
  get message() {
    return this.reason;
  }
};
__name(MultipartError, "MultipartError");
var makeConfig = /* @__PURE__ */ __name((headers) => withFiberRuntime2((fiber) => {
  const mimeTypes = get6(fiber.currentContext, FieldMimeTypes);
  return succeed10({
    headers,
    maxParts: getOrUndefined(get6(fiber.currentContext, MaxParts)),
    maxFieldSize: Number(get6(fiber.currentContext, MaxFieldSize)),
    maxPartSize: get6(fiber.currentContext, MaxFileSize).pipe(map2(Number), getOrUndefined),
    maxTotalSize: get6(fiber.currentContext, MaxBodySize).pipe(map2(Number), getOrUndefined),
    isFile: mimeTypes.length === 0 ? void 0 : (info2) => !some4(mimeTypes, (_) => info2.contentType.includes(_)) && defaultIsFile2(info2)
  });
}), "makeConfig");
var makeChannel = /* @__PURE__ */ __name((headers, bufferSize = 16) => acquireUseRelease4(all7([makeConfig(headers), make68(bufferSize)]), ([config2, mailbox]) => {
  let partsBuffer = [];
  let exit4 = none2();
  const input = {
    awaitRead: () => _void,
    emit(element2) {
      return mailbox.offer(element2);
    },
    error(cause3) {
      exit4 = some3(failCause3(cause3));
      return mailbox.end;
    },
    done(_value) {
      return mailbox.end;
    }
  };
  const parser = make77({
    ...config2,
    onField(info2, value6) {
      partsBuffer.push(new FieldImpl(info2.name, info2.contentType, decodeField2(info2, value6)));
    },
    onFile(info2) {
      let chunks3 = [];
      let finished = false;
      const take10 = suspend13(() => {
        if (chunks3.length === 0) {
          return finished ? void_10 : zipRight12(pump, take10);
        }
        const chunk4 = unsafeFromArray(chunks3);
        chunks3 = [];
        return finished ? write2(chunk4) : zipRight12(write2(chunk4), zipRight12(pump, take10));
      });
      partsBuffer.push(new FileImpl(info2, take10));
      return function(chunk4) {
        if (chunk4 === null) {
          finished = true;
        } else {
          chunks3.push(chunk4);
        }
      };
    },
    onError(error_) {
      exit4 = some3(fail3(convertError(error_)));
    },
    onDone() {
      exit4 = some3(void_4);
    }
  });
  const pump = flatMap21(mailbox.takeAll, ([chunks3, done12]) => sync13(() => {
    forEach(chunks3, forEach(parser.write));
    if (done12) {
      parser.end();
    }
  }));
  const partsChannel = flatMap21(pump, () => {
    if (partsBuffer.length === 0) {
      return exit4._tag === "None" ? partsChannel : writeExit(exit4.value);
    }
    const chunk4 = unsafeFromArray(partsBuffer);
    partsBuffer = [];
    return zipRight12(write2(chunk4), exit4._tag === "None" ? partsChannel : writeExit(exit4.value));
  });
  return embedInput2(partsChannel, input);
}, ([, mailbox]) => mailbox.shutdown), "makeChannel");
var writeExit = /* @__PURE__ */ __name((self2) => self2._tag === "Success" ? void_10 : failCause15(self2.cause), "writeExit");
function convertError(cause3) {
  switch (cause3._tag) {
    case "ReachedLimit": {
      switch (cause3.limit) {
        case "MaxParts": {
          return new MultipartError({
            reason: "TooManyParts",
            cause: cause3
          });
        }
        case "MaxFieldSize": {
          return new MultipartError({
            reason: "FieldTooLarge",
            cause: cause3
          });
        }
        case "MaxPartSize": {
          return new MultipartError({
            reason: "FileTooLarge",
            cause: cause3
          });
        }
        case "MaxTotalSize": {
          return new MultipartError({
            reason: "BodyTooLarge",
            cause: cause3
          });
        }
      }
    }
    default: {
      return new MultipartError({
        reason: "Parse",
        cause: cause3
      });
    }
  }
}
__name(convertError, "convertError");
var PartBase = class extends Class {
  [TypeId42];
  constructor() {
    super();
    this[TypeId42] = TypeId42;
  }
};
__name(PartBase, "PartBase");
var FieldImpl = class extends PartBase {
  key;
  contentType;
  value;
  _tag = "Field";
  constructor(key, contentType, value6) {
    super();
    this.key = key;
    this.contentType = contentType;
    this.value = value6;
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "Field",
      key: this.key,
      contentType: this.contentType,
      value: this.value
    };
  }
};
__name(FieldImpl, "FieldImpl");
var FileImpl = class extends PartBase {
  _tag = "File";
  key;
  name;
  contentType;
  content;
  contentEffect;
  constructor(info2, channel) {
    super();
    this.key = info2.name;
    this.name = info2.filename ?? info2.name;
    this.contentType = info2.contentType;
    this.content = fromChannel3(channel);
    this.contentEffect = channel.pipe(pipeTo2(collectUint8Array), run4, mapError4((cause3) => new MultipartError({
      reason: "InternalError",
      cause: cause3
    })));
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "File",
      key: this.key,
      name: this.name,
      contentType: this.contentType
    };
  }
};
__name(FileImpl, "FileImpl");
var defaultWriteFile = /* @__PURE__ */ __name((path, file3) => flatMap14(FileSystem, (fs) => mapError4(run5(file3.content, fs.sink(path)), (cause3) => new MultipartError({
  reason: "InternalError",
  cause: cause3
}))), "defaultWriteFile");
var collectUint8Array = /* @__PURE__ */ suspend13(() => {
  let accumulator = new Uint8Array(0);
  const loop3 = readWithCause2({
    onInput(chunk4) {
      for (const element2 of chunk4) {
        const newAccumulator = new Uint8Array(accumulator.length + element2.length);
        newAccumulator.set(accumulator, 0);
        newAccumulator.set(element2, accumulator.length);
        accumulator = newAccumulator;
      }
      return loop3;
    },
    onFailure: (cause3) => failCause15(cause3),
    onDone: () => succeed19(accumulator)
  });
  return loop3;
});
var toPersisted = /* @__PURE__ */ __name((stream6, writeFile = defaultWriteFile) => gen3(function* () {
  const fs = yield* FileSystem;
  const path_ = yield* Path2;
  const dir2 = yield* fs.makeTempDirectoryScoped();
  const persisted = /* @__PURE__ */ Object.create(null);
  yield* runForEach2(stream6, (part) => {
    if (part._tag === "Field") {
      if (!(part.key in persisted)) {
        persisted[part.key] = part.value;
      } else if (typeof persisted[part.key] === "string") {
        persisted[part.key] = [persisted[part.key], part.value];
      } else {
        ;
        persisted[part.key].push(part.value);
      }
      return _void;
    } else if (part.name === "") {
      return _void;
    }
    const file3 = part;
    const path = path_.join(dir2, path_.basename(file3.name).slice(-128));
    const filePart = new PersistedFileImpl(file3.key, file3.name, file3.contentType, path);
    if (Array.isArray(persisted[part.key])) {
      ;
      persisted[part.key].push(filePart);
    } else {
      persisted[part.key] = [filePart];
    }
    return writeFile(path, file3);
  });
  return persisted;
}).pipe(catchTags2({
  SystemError: (cause3) => fail10(new MultipartError({
    reason: "InternalError",
    cause: cause3
  })),
  BadArgument: (cause3) => fail10(new MultipartError({
    reason: "InternalError",
    cause: cause3
  }))
})), "toPersisted");
var PersistedFileImpl = class extends PartBase {
  key;
  name;
  contentType;
  path;
  _tag = "PersistedFile";
  constructor(key, name, contentType, path) {
    super();
    this.key = key;
    this.name = name;
    this.contentType = contentType;
    this.path = path;
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "PersistedFile",
      key: this.key,
      name: this.name,
      contentType: this.contentType,
      path: this.path
    };
  }
};
__name(PersistedFileImpl, "PersistedFileImpl");
var MaxParts = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxParts", {
  defaultValue: none2
})) {
};
__name(MaxParts, "MaxParts");
var MaxFieldSize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxFieldSize", {
  defaultValue: /* @__PURE__ */ constant(/* @__PURE__ */ Size2(10 * 1024 * 1024))
})) {
};
__name(MaxFieldSize, "MaxFieldSize");
var MaxFileSize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxFileSize", {
  defaultValue: none2
})) {
};
__name(MaxFileSize, "MaxFileSize");
var FieldMimeTypes = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/FieldMimeTypes", {
  defaultValue: /* @__PURE__ */ constant(/* @__PURE__ */ make4("application/json"))
})) {
};
__name(FieldMimeTypes, "FieldMimeTypes");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServerRequest.js
var TypeId43 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRequest");
var serverRequestTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServerRequest");
var parsedSearchParamsTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServerRequest/ParsedSearchParams");
var fromWeb2 = /* @__PURE__ */ __name((request2) => new ServerRequestImpl(request2, removeHost(request2.url)), "fromWeb");
var removeHost = /* @__PURE__ */ __name((url2) => {
  if (url2[0] === "/") {
    return url2;
  }
  const index2 = url2.indexOf("/", url2.indexOf("//") + 2);
  return index2 === -1 ? "/" : url2.slice(index2);
}, "removeHost");
var ServerRequestImpl = class extends Class {
  source;
  url;
  headersOverride;
  remoteAddressOverride;
  [TypeId43];
  [TypeId35];
  constructor(source, url2, headersOverride, remoteAddressOverride) {
    super();
    this.source = source;
    this.url = url2;
    this.headersOverride = headersOverride;
    this.remoteAddressOverride = remoteAddressOverride;
    this[TypeId43] = TypeId43;
    this[TypeId35] = TypeId35;
  }
  toJSON() {
    return inspect(this, {
      _id: "@effect/platform/HttpServerRequest",
      method: this.method,
      url: this.originalUrl
    });
  }
  modify(options4) {
    return new ServerRequestImpl(this.source, options4.url ?? this.url, options4.headers ?? this.headersOverride, options4.remoteAddress ?? this.remoteAddressOverride);
  }
  get method() {
    return this.source.method.toUpperCase();
  }
  get originalUrl() {
    return this.source.url;
  }
  get remoteAddress() {
    return this.remoteAddressOverride ? some3(this.remoteAddressOverride) : none2();
  }
  get headers() {
    this.headersOverride ??= fromInput3(this.source.headers);
    return this.headersOverride;
  }
  cachedCookies;
  get cookies() {
    if (this.cachedCookies) {
      return this.cachedCookies;
    }
    return this.cachedCookies = parseHeader(this.headers.cookie ?? "");
  }
  get stream() {
    return this.source.body ? fromReadableStream2(() => this.source.body, (cause3) => new RequestError2({
      request: this,
      reason: "Decode",
      cause: cause3
    })) : fail20(new RequestError2({
      request: this,
      reason: "Decode",
      description: "can not create stream from empty body"
    }));
  }
  textEffect;
  get text() {
    if (this.textEffect) {
      return this.textEffect;
    }
    this.textEffect = runSync(cached3(tryPromise2({
      try: () => this.source.text(),
      catch: (cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      })
    })));
    return this.textEffect;
  }
  get json() {
    return tryMap2(this.text, {
      try: (_) => JSON.parse(_),
      catch: (cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      })
    });
  }
  get urlParamsBody() {
    return flatMap14(this.text, (_) => try_3({
      try: () => fromInput4(new URLSearchParams(_)),
      catch: (cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      })
    }));
  }
  multipartEffect;
  get multipart() {
    if (this.multipartEffect) {
      return this.multipartEffect;
    }
    this.multipartEffect = runSync(cached3(toPersisted(this.multipartStream)));
    return this.multipartEffect;
  }
  get multipartStream() {
    return pipeThroughChannel2(mapError10(this.stream, (cause3) => new MultipartError({
      reason: "InternalError",
      cause: cause3
    })), makeChannel(this.headers));
  }
  arrayBufferEffect;
  get arrayBuffer() {
    if (this.arrayBufferEffect) {
      return this.arrayBufferEffect;
    }
    this.arrayBufferEffect = runSync(cached3(tryPromise2({
      try: () => this.source.arrayBuffer(),
      catch: (cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      })
    })));
    return this.arrayBufferEffect;
  }
  get upgrade() {
    return fail10(new RequestError2({
      request: this,
      reason: "Decode",
      description: "Not an upgradeable ServerRequest"
    }));
  }
};
__name(ServerRequestImpl, "ServerRequestImpl");
var toURL = /* @__PURE__ */ __name((self2) => {
  const host = self2.headers.host ?? "localhost";
  const protocol = self2.headers["x-forwarded-proto"] === "https" ? "https" : "http";
  try {
    return some3(new URL(self2.url, `${protocol}://${host}`));
  } catch {
    return none2();
  }
}, "toURL");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServerRequest.js
var HttpServerRequest = serverRequestTag;
var ParsedSearchParams = parsedSearchParamsTag;
var fromWeb3 = fromWeb2;
var toURL2 = toURL;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpApp.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var currentPreResponseHandlers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpApp/preResponseHandlers"), () => unsafeMake12(none2()));
var appendPreResponseHandler = /* @__PURE__ */ __name((handler) => update5(currentPreResponseHandlers, match2({
  onNone: () => some3(handler),
  onSome: (prev) => some3((request2, response) => flatMap14(prev(request2, response), (response2) => handler(request2, response2)))
})), "appendPreResponseHandler");
var withPreResponseHandler = /* @__PURE__ */ dual(2, (self2, handler) => locallyWith(self2, currentPreResponseHandlers, match2({
  onNone: () => some3(handler),
  onSome: (prev) => some3((request2, response) => flatMap14(prev(request2, response), (response2) => handler(request2, response2)))
})));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpMiddleware.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make78 = /* @__PURE__ */ __name((middleware2) => middleware2, "make");
var loggerDisabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpMiddleware/loggerDisabled"), () => unsafeMake12(false));
var withLoggerDisabled = /* @__PURE__ */ __name((self2) => zipRight6(set8(loggerDisabled, true), self2), "withLoggerDisabled");
var currentTracerDisabledWhen2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpMiddleware/tracerDisabledWhen"), () => unsafeMake12(constFalse));
var SpanNameGenerator2 = /* @__PURE__ */ Reference2()("@effect/platform/HttpMiddleware/SpanNameGenerator", {
  defaultValue: () => (request2) => `http.server ${request2.method}`
});
var tracer3 = /* @__PURE__ */ make78((httpApp) => withFiberRuntime2((fiber) => {
  const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
  const disabled = fiber.getFiberRef(currentTracerDisabledWhen2)(request2);
  if (disabled) {
    return httpApp;
  }
  const url2 = getOrUndefined(toURL2(request2));
  if (url2 !== void 0 && (url2.username !== "" || url2.password !== "")) {
    url2.username = "REDACTED";
    url2.password = "REDACTED";
  }
  const redactedHeaderNames = fiber.getFiberRef(currentRedactedNames);
  const redactedHeaders = redact2(request2.headers, redactedHeaderNames);
  const nameGenerator = get6(fiber.currentContext, SpanNameGenerator2);
  return useSpan2(nameGenerator(request2), {
    parent: getOrUndefined(fromHeaders(request2.headers)),
    kind: "server",
    captureStackTrace: false
  }, (span4) => {
    span4.attribute("http.request.method", request2.method);
    if (url2 !== void 0) {
      span4.attribute("url.full", url2.toString());
      span4.attribute("url.path", url2.pathname);
      const query = url2.search.slice(1);
      if (query !== "") {
        span4.attribute("url.query", url2.search.slice(1));
      }
      span4.attribute("url.scheme", url2.protocol.slice(0, -1));
    }
    if (request2.headers["user-agent"] !== void 0) {
      span4.attribute("user_agent.original", request2.headers["user-agent"]);
    }
    for (const name in redactedHeaders) {
      span4.attribute(`http.request.header.${name}`, String(redactedHeaders[name]));
    }
    if (request2.remoteAddress._tag === "Some") {
      span4.attribute("client.address", request2.remoteAddress.value);
    }
    return flatMap14(exit3(withParentSpan3(httpApp, span4)), (exit4) => {
      const response = exitResponse2(exit4);
      span4.attribute("http.response.status_code", response.status);
      const redactedHeaders2 = redact2(response.headers, redactedHeaderNames);
      for (const name in redactedHeaders2) {
        span4.attribute(`http.response.header.${name}`, String(redactedHeaders2[name]));
      }
      return exit4;
    });
  });
}));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpApp.js
var handledSymbol = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApp/handled");
var toHandled = /* @__PURE__ */ __name((self2, handleResponse, middleware2) => {
  const responded = withFiberRuntime2((fiber) => flatMap14(self2, (response) => {
    const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
    const handler = fiber.getFiberRef(currentPreResponseHandlers2);
    if (handler._tag === "None") {
      ;
      request2[handledSymbol] = true;
      return as7(handleResponse(request2, response), response);
    }
    return tap4(handler.value(request2, response), (response2) => {
      ;
      request2[handledSymbol] = true;
      return handleResponse(request2, response2);
    });
  }));
  const withErrorHandling = catchAllCause3(responded, (cause3) => withFiberRuntime2((fiber) => flatMap14(causeResponse2(cause3), ([response, cause4]) => {
    const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
    const handler = fiber.getFiberRef(currentPreResponseHandlers2);
    if (handler._tag === "None") {
      ;
      request2[handledSymbol] = true;
      return zipRight6(handleResponse(request2, response), failCause9(cause4));
    }
    return zipRight6(tap4(handler.value(request2, response), (response2) => {
      ;
      request2[handledSymbol] = true;
      return handleResponse(request2, response2);
    }), failCause9(cause4));
  })));
  const withMiddleware = unify2(middleware2 === void 0 ? tracer3(withErrorHandling) : matchCauseEffect3(tracer3(middleware2(withErrorHandling)), {
    onFailure: (cause3) => withFiberRuntime2((fiber) => {
      const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
      if (handledSymbol in request2) {
        return _void;
      }
      return matchCauseEffect3(causeResponse2(cause3), {
        onFailure: (_cause) => handleResponse(request2, empty42({
          status: 500
        })),
        onSuccess: ([response]) => handleResponse(request2, response)
      });
    }),
    onSuccess: (response) => withFiberRuntime2((fiber) => {
      const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
      return handledSymbol in request2 ? _void : handleResponse(request2, response);
    })
  }));
  return uninterruptible2(scoped8(withMiddleware));
}, "toHandled");
var ejectDefaultScopeClose = /* @__PURE__ */ __name((scope5) => {
  ejectedScopes.add(scope5);
}, "ejectDefaultScopeClose");
var unsafeEjectStreamScope = /* @__PURE__ */ __name((response) => {
  if (response.body._tag !== "Stream") {
    return response;
  }
  const fiber = getOrThrow2(getCurrentFiber2());
  const scope5 = unsafeGet5(fiber.currentContext, Scope);
  ejectDefaultScopeClose(scope5);
  return setBody3(response, stream3(ensuring8(response.body.stream, close(scope5, void_4)), response.body.contentType, response.body.contentLength));
}, "unsafeEjectStreamScope");
var ejectedScopes = /* @__PURE__ */ globalValue("@effect/platform/HttpApp/ejectedScopes", () => /* @__PURE__ */ new WeakSet());
var scoped8 = /* @__PURE__ */ __name((effect4) => flatMap14(make39(), (scope5) => onExit3(extend2(effect4, scope5), (exit4) => {
  if (ejectedScopes.has(scope5)) {
    return _void;
  }
  return close(scope5, exit4);
})), "scoped");
var currentPreResponseHandlers2 = currentPreResponseHandlers;
var appendPreResponseHandler2 = appendPreResponseHandler;
var withPreResponseHandler2 = withPreResponseHandler;
var toWebHandlerRuntime = /* @__PURE__ */ __name((runtime6) => {
  const httpRuntime = make53(runtime6);
  const run6 = runFork3(httpRuntime);
  return (self2, middleware2) => {
    const resolveSymbol = Symbol.for("@effect/platform/HttpApp/resolve");
    const httpApp = toHandled(self2, (request2, response) => {
      response = unsafeEjectStreamScope(response);
      request2[resolveSymbol](toWeb2(response, {
        withoutBody: request2.method === "HEAD",
        runtime: runtime6
      }));
      return _void;
    }, middleware2);
    return (request2, context11) => new Promise((resolve3) => {
      const contextMap = new Map(runtime6.context.unsafeMap);
      if (isContext2(context11)) {
        for (const [key, value6] of context11.unsafeMap) {
          contextMap.set(key, value6);
        }
      }
      const httpServerRequest = fromWeb3(request2);
      contextMap.set(HttpServerRequest.key, httpServerRequest);
      httpServerRequest[resolveSymbol] = resolve3;
      httpRuntime.context = unsafeMake(contextMap);
      const fiber = run6(httpApp);
      request2.signal?.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(clientAbortFiberId2);
      }, {
        once: true
      });
    });
  };
}, "toWebHandlerRuntime");
var toWebHandler = /* @__PURE__ */ toWebHandlerRuntime(defaultRuntime2);
var toWebHandlerLayerWith = /* @__PURE__ */ __name((layer13, options4) => {
  const scope5 = runSync(make39());
  const dispose = /* @__PURE__ */ __name(() => runPromise(close(scope5, void_4)), "dispose");
  let handlerCache;
  let handlerPromise;
  function handler(request2, context11) {
    if (handlerCache) {
      return handlerCache(request2, context11);
    }
    handlerPromise ??= gen3(function* () {
      const runtime6 = yield* options4.memoMap ? toRuntimeWithMemoMap2(layer13, options4.memoMap) : toRuntime2(layer13);
      return handlerCache = toWebHandlerRuntime(runtime6)(yield* options4.toHandler(runtime6), options4.middleware);
    }).pipe(extend2(scope5), runPromise);
    return handlerPromise.then((f) => f(request2, context11));
  }
  __name(handler, "handler");
  return {
    dispose,
    handler
  };
}, "toWebHandlerLayerWith");
var toWebHandlerLayer = /* @__PURE__ */ __name((self2, layer13, options4) => toWebHandlerLayerWith(layer13, {
  ...options4,
  toHandler: () => succeed10(self2)
}), "toWebHandlerLayer");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpLayerRouter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/internal/router.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/QueryString.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var plusRegex = /\+/g;
var Empty = /* @__PURE__ */ __name(function() {
}, "Empty");
Empty.prototype = /* @__PURE__ */ Object.create(null);
function parse3(input) {
  const result = new Empty();
  if (typeof input !== "string") {
    return result;
  }
  const inputLength = input.length;
  let key = "";
  let value6 = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let shouldDecodeKey = false;
  let shouldDecodeValue = false;
  let keyHasPlus = false;
  let valueHasPlus = false;
  let hasBothKeyValuePair = false;
  let c = 0;
  for (let i = 0; i < inputLength + 1; i++) {
    c = i !== inputLength ? input.charCodeAt(i) : 38;
    if (c === 38) {
      hasBothKeyValuePair = equalityIndex > startingIndex;
      if (!hasBothKeyValuePair) {
        equalityIndex = i;
      }
      key = input.slice(startingIndex + 1, equalityIndex);
      if (hasBothKeyValuePair || key.length > 0) {
        if (keyHasPlus) {
          key = key.replace(plusRegex, " ");
        }
        if (shouldDecodeKey) {
          try {
            key = decodeURIComponent(key) || key;
          } catch {
          }
        }
        if (hasBothKeyValuePair) {
          value6 = input.slice(equalityIndex + 1, i);
          if (valueHasPlus) {
            value6 = value6.replace(plusRegex, " ");
          }
          if (shouldDecodeValue) {
            try {
              value6 = decodeURIComponent(value6) || value6;
            } catch {
            }
          }
        }
        const currentValue = result[key];
        if (currentValue === void 0) {
          result[key] = value6;
        } else {
          if (currentValue.pop) {
            currentValue.push(value6);
          } else {
            result[key] = [currentValue, value6];
          }
        }
      }
      value6 = "";
      startingIndex = i;
      equalityIndex = i;
      shouldDecodeKey = false;
      shouldDecodeValue = false;
      keyHasPlus = false;
      valueHasPlus = false;
    } else if (c === 61) {
      if (equalityIndex <= startingIndex) {
        equalityIndex = i;
      } else {
        shouldDecodeValue = true;
      }
    } else if (c === 43) {
      if (equalityIndex > startingIndex) {
        valueHasPlus = true;
      } else {
        keyHasPlus = true;
      }
    } else if (c === 37) {
      if (equalityIndex > startingIndex) {
        shouldDecodeValue = true;
      } else {
        shouldDecodeKey = true;
      }
    }
  }
  return result;
}
__name(parse3, "parse");

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/internal/router.js
var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
var make79 = /* @__PURE__ */ __name((options4 = {}) => new RouterImpl(options4), "make");
var RouterImpl = class {
  constructor(options4 = {}) {
    this.options = {
      ignoreTrailingSlash: true,
      ignoreDuplicateSlashes: true,
      caseSensitive: false,
      maxParamLength: 100,
      ...options4
    };
  }
  options;
  routes = [];
  trees = {};
  on(method, path, handler) {
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch && optionalParamMatch.index !== void 0) {
      assert3(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.on(method, pathFull, handler);
      this.on(method, pathOptional, handler);
      return;
    }
    if (this.options.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.options.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = typeof method === "string" ? [method] : method;
    for (const method2 of methods) {
      this._on(method2, path, handler);
    }
  }
  all(path, handler) {
    this.on(httpMethods, path, handler);
  }
  _on(method, path, handler) {
    if (this.trees[method] === void 0) {
      this.trees[method] = new StaticNode("/");
    }
    let pattern2 = path;
    if (pattern2 === "*" && this.trees[method].prefix.length !== 0) {
      const currentRoot = this.trees[method];
      this.trees[method] = new StaticNode("");
      this.trees[method].staticChildren["/"] = currentRoot;
    }
    let parentNodePathIndex = this.trees[method].prefix.length;
    let currentNode = this.trees[method];
    const params2 = [];
    for (let i = 0; i <= pattern2.length; i++) {
      if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern2.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern2.slice(parentNodePathIndex, i);
        if (!this.options.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.split("::").join(":");
        staticNodePath = staticNodePath.split("%").join("%25");
        currentNode = currentNode.createStaticChild(staticNodePath);
      }
      if (isParametricNode) {
        let isRegexNode = false;
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex; ; j++) {
          const charCode = pattern2.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern2.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern2.slice(lastParamStartIndex, j);
            params2.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
              const regexString = pattern2.slice(j, endOfRegexIndex + 1);
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
            } else {
              regexps.push("(.*?)");
            }
            const staticPartStartIndex = j;
            for (; j < pattern2.length; j++) {
              const charCode2 = pattern2.charCodeAt(j);
              if (charCode2 === 47)
                break;
              if (charCode2 === 58) {
                const nextCharCode = pattern2.charCodeAt(j + 1);
                if (nextCharCode === 58)
                  j++;
                else
                  break;
              }
            }
            let staticPart = pattern2.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.split("::").join(":");
              staticPart = staticPart.split("%").join("%25");
              regexps.push(escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern2.slice(i, j);
              pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : void 0;
              currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params2.push("*");
        currentNode = currentNode.createWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern2.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.options.caseSensitive) {
      pattern2 = pattern2.toLowerCase();
    }
    if (pattern2 === "*") {
      pattern2 = "/*";
    }
    for (const existRoute of this.routes) {
      if (existRoute.method === method && existRoute.pattern === pattern2) {
        throw new Error(`Method '${method}' already declared for route '${pattern2}'`);
      }
    }
    const route2 = {
      method,
      path,
      pattern: pattern2,
      params: params2,
      handler
    };
    this.routes.push(route2);
    currentNode.addRoute(route2);
  }
  has(method, path) {
    const node = this.trees[method];
    if (node === void 0) {
      return false;
    }
    const staticNode = node.getStaticChild(path);
    if (staticNode === void 0) {
      return false;
    }
    return staticNode.isLeafNode;
  }
  find(method, path) {
    let currentNode = this.trees[method];
    if (currentNode === void 0)
      return void 0;
    if (path.charCodeAt(0) !== 47) {
      path = path.replace(FULL_PATH_REGEXP, "/");
    }
    if (this.options.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    let sanitizedUrl;
    let querystring;
    let shouldDecodeParam;
    try {
      sanitizedUrl = safeDecodeURI(path);
      path = sanitizedUrl.path;
      querystring = sanitizedUrl.querystring;
      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
    } catch (error3) {
      return void 0;
    }
    if (this.options.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const originPath = path;
    if (this.options.caseSensitive === false) {
      path = path.toLowerCase();
    }
    const maxParamLength = this.options.maxParamLength;
    let pathIndex = currentNode.prefix.length;
    const params2 = [];
    const pathLen = path.length;
    const brothersNodesStack = [];
    while (true) {
      if (pathIndex === pathLen && currentNode.isLeafNode) {
        const handle = currentNode.handlerStorage?.find();
        if (handle !== void 0) {
          return {
            handler: handle.handler,
            params: handle.createParams(params2),
            searchParams: parse3(querystring)
          };
        }
      }
      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params2.length);
      if (node === void 0) {
        if (brothersNodesStack.length === 0) {
          return void 0;
        }
        const brotherNodeState = brothersNodesStack.pop();
        pathIndex = brotherNodeState.brotherPathIndex;
        params2.splice(brotherNodeState.paramsCount);
        node = brotherNodeState.brotherNode;
      }
      currentNode = node;
      if (currentNode._tag === "StaticNode") {
        pathIndex += currentNode.prefix.length;
        continue;
      }
      if (currentNode._tag === "WildcardNode") {
        let param = originPath.slice(pathIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        params2.push(param);
        pathIndex = pathLen;
        continue;
      }
      if (currentNode._tag === "ParametricNode") {
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.regex !== void 0) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null)
            continue;
          for (let i = 1; i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return void 0;
            }
            params2.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return void 0;
          }
          params2.push(param);
        }
        pathIndex = paramEndIndex;
      }
    }
  }
};
__name(RouterImpl, "RouterImpl");
var HandlerStorage = class {
  handlers = [];
  unconstrainedHandler;
  find() {
    return this.unconstrainedHandler;
  }
  add(route2) {
    const handler = {
      params: route2.params,
      handler: route2.handler,
      createParams: compileCreateParams(route2.params)
    };
    this.handlers.push(handler);
    this.unconstrainedHandler = this.handlers[0];
  }
};
__name(HandlerStorage, "HandlerStorage");
var NodeBase = class {
  isLeafNode = false;
  routes;
  handlerStorage;
  addRoute(route2) {
    if (this.routes === void 0) {
      this.routes = [route2];
    } else {
      this.routes.push(route2);
    }
    if (this.handlerStorage === void 0) {
      this.handlerStorage = new HandlerStorage();
    }
    this.isLeafNode = true;
    this.handlerStorage.add(route2);
  }
};
__name(NodeBase, "NodeBase");
var ParentNode = class extends NodeBase {
  staticChildren = {};
  findStaticMatchingChild(path, pathIndex) {
    const staticChild = this.staticChildren[path.charAt(pathIndex)];
    if (staticChild === void 0 || !staticChild.matchPrefix(path, pathIndex)) {
      return void 0;
    }
    return staticChild;
  }
  getStaticChild(path, pathIndex = 0) {
    if (path.length === pathIndex) {
      return this;
    }
    const staticChild = this.findStaticMatchingChild(path, pathIndex);
    if (staticChild === void 0) {
      return void 0;
    }
    return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
  }
  createStaticChild(path) {
    if (path.length === 0) {
      return this;
    }
    let staticChild = this.staticChildren[path.charAt(0)];
    if (staticChild) {
      let i = 1;
      for (; i < staticChild.prefix.length; i++) {
        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
          staticChild = staticChild.split(this, i);
          break;
        }
      }
      return staticChild.createStaticChild(path.slice(i));
    }
    const label = path.charAt(0);
    this.staticChildren[label] = new StaticNode(path);
    return this.staticChildren[label];
  }
};
__name(ParentNode, "ParentNode");
var StaticNode = class extends ParentNode {
  _tag = "StaticNode";
  constructor(prefix3) {
    super();
    this.setPrefix(prefix3);
  }
  prefix;
  matchPrefix;
  parametricChildren = [];
  wildcardChild;
  setPrefix(prefix3) {
    this.prefix = prefix3;
    if (prefix3.length === 1) {
      this.matchPrefix = (_path, _pathIndex) => true;
    } else {
      const len = prefix3.length;
      this.matchPrefix = function(path, pathIndex) {
        for (let i = 1; i < len; i++) {
          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {
            return false;
          }
        }
        return true;
      };
    }
  }
  getParametricChild(regex) {
    if (regex === void 0) {
      return this.parametricChildren.find((child) => child.isRegex === false);
    }
    const source = regex.source;
    return this.parametricChildren.find((child) => {
      if (child.regex === void 0) {
        return false;
      }
      return child.regex.source === source;
    });
  }
  createParametricChild(regex, staticSuffix, nodePath) {
    let child = this.getParametricChild(regex);
    if (child !== void 0) {
      child.nodePaths.add(nodePath);
      return child;
    }
    child = new ParametricNode(regex, staticSuffix, nodePath);
    this.parametricChildren.push(child);
    this.parametricChildren.sort((child1, child2) => {
      if (!child1.isRegex)
        return 1;
      if (!child2.isRegex)
        return -1;
      if (child1.staticSuffix === void 0)
        return 1;
      if (child2.staticSuffix === void 0)
        return -1;
      if (child2.staticSuffix.endsWith(child1.staticSuffix))
        return 1;
      if (child1.staticSuffix.endsWith(child2.staticSuffix))
        return -1;
      return 0;
    });
    return child;
  }
  createWildcardChild() {
    if (this.wildcardChild === void 0) {
      this.wildcardChild = new WildcardNode();
    }
    return this.wildcardChild;
  }
  split(parentNode, length4) {
    const parentPrefix = this.prefix.slice(0, length4);
    const childPrefix = this.prefix.slice(length4);
    this.setPrefix(childPrefix);
    const staticNode = new StaticNode(parentPrefix);
    staticNode.staticChildren[childPrefix.charAt(0)] = this;
    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
    return staticNode;
  }
  getNextNode(path, pathIndex, nodeStack, paramsCount) {
    let node = this.findStaticMatchingChild(path, pathIndex);
    let parametricBrotherNodeIndex = 0;
    if (node === void 0) {
      if (this.parametricChildren.length === 0) {
        return this.wildcardChild;
      }
      node = this.parametricChildren[0];
      parametricBrotherNodeIndex = 1;
    }
    if (this.wildcardChild !== void 0) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.wildcardChild
      });
    }
    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.parametricChildren[i]
      });
    }
    return node;
  }
};
__name(StaticNode, "StaticNode");
var ParametricNode = class extends ParentNode {
  regex;
  staticSuffix;
  _tag = "ParametricNode";
  constructor(regex, staticSuffix, nodePath) {
    super();
    this.regex = regex;
    this.staticSuffix = staticSuffix;
    this.isRegex = !!regex;
    this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
  }
  isRegex;
  nodePaths;
  getNextNode(path, pathIndex) {
    return this.findStaticMatchingChild(path, pathIndex);
  }
};
__name(ParametricNode, "ParametricNode");
var WildcardNode = class extends NodeBase {
  _tag = "WildcardNode";
  getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {
    return void 0;
  }
};
__name(WildcardNode, "WildcardNode");
var assert3 = /* @__PURE__ */ __name((condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
}, "assert");
function removeDuplicateSlashes(path) {
  return path.replace(/\/\/+/g, "/");
}
__name(removeDuplicateSlashes, "removeDuplicateSlashes");
function trimLastSlash(path) {
  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
    return path.slice(0, -1);
  }
  return path;
}
__name(trimLastSlash, "trimLastSlash");
function compileCreateParams(params2) {
  const len = params2.length;
  return function(paramsArray) {
    const paramsObject = {};
    for (let i = 0; i < len; i++) {
      paramsObject[params2[i]] = paramsArray[i];
    }
    return paramsObject;
  };
}
__name(compileCreateParams, "compileCreateParams");
function getClosingParenthensePosition(path, idx) {
  let parentheses = 1;
  while (idx < path.length) {
    idx++;
    if (path[idx] === "\\") {
      idx++;
      continue;
    }
    if (path[idx] === ")") {
      parentheses--;
    } else if (path[idx] === "(") {
      parentheses++;
    }
    if (!parentheses)
      return idx;
  }
  throw new TypeError('Invalid regexp expression in "' + path + '"');
}
__name(getClosingParenthensePosition, "getClosingParenthensePosition");
function trimRegExpStartAndEnd(regexString) {
  if (regexString.charCodeAt(1) === 94) {
    regexString = regexString.slice(0, 1) + regexString.slice(2);
  }
  if (regexString.charCodeAt(regexString.length - 2) === 36) {
    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
  }
  return regexString;
}
__name(trimRegExpStartAndEnd, "trimRegExpStartAndEnd");
function escapeRegExp(string7) {
  return string7.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegExp, "escapeRegExp");
function decodeComponentChar(highCharCode, lowCharCode) {
  if (highCharCode === 50) {
    if (lowCharCode === 53)
      return "%";
    if (lowCharCode === 51)
      return "#";
    if (lowCharCode === 52)
      return "$";
    if (lowCharCode === 54)
      return "&";
    if (lowCharCode === 66)
      return "+";
    if (lowCharCode === 98)
      return "+";
    if (lowCharCode === 67)
      return ",";
    if (lowCharCode === 99)
      return ",";
    if (lowCharCode === 70)
      return "/";
    if (lowCharCode === 102)
      return "/";
    return void 0;
  }
  if (highCharCode === 51) {
    if (lowCharCode === 65)
      return ":";
    if (lowCharCode === 97)
      return ":";
    if (lowCharCode === 66)
      return ";";
    if (lowCharCode === 98)
      return ";";
    if (lowCharCode === 68)
      return "=";
    if (lowCharCode === 100)
      return "=";
    if (lowCharCode === 70)
      return "?";
    if (lowCharCode === 102)
      return "?";
    return void 0;
  }
  if (highCharCode === 52 && lowCharCode === 48) {
    return "@";
  }
  return void 0;
}
__name(decodeComponentChar, "decodeComponentChar");
function safeDecodeURI(path) {
  let shouldDecode = false;
  let shouldDecodeParam = false;
  let querystring = "";
  for (let i = 1; i < path.length; i++) {
    const charCode = path.charCodeAt(i);
    if (charCode === 37) {
      const highCharCode = path.charCodeAt(i + 1);
      const lowCharCode = path.charCodeAt(i + 2);
      if (decodeComponentChar(highCharCode, lowCharCode) === void 0) {
        shouldDecode = true;
      } else {
        shouldDecodeParam = true;
        if (highCharCode === 50 && lowCharCode === 53) {
          shouldDecode = true;
          path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
          i += 2;
        }
        i += 2;
      }
    } else if (charCode === 63 || charCode === 59 || charCode === 35) {
      querystring = path.slice(i + 1);
      path = path.slice(0, i);
      break;
    }
  }
  const decodedPath = shouldDecode ? decodeURI(path) : path;
  return {
    path: decodedPath,
    querystring,
    shouldDecodeParam
  };
}
__name(safeDecodeURI, "safeDecodeURI");
function safeDecodeURIComponent(uriComponent) {
  const startIndex = uriComponent.indexOf("%");
  if (startIndex === -1)
    return uriComponent;
  let decoded = "";
  let lastIndex = startIndex;
  for (let i = startIndex; i < uriComponent.length; i++) {
    if (uriComponent.charCodeAt(i) === 37) {
      const highCharCode = uriComponent.charCodeAt(i + 1);
      const lowCharCode = uriComponent.charCodeAt(i + 2);
      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
      decoded += uriComponent.slice(lastIndex, i) + decodedChar;
      lastIndex = i + 3;
    }
  }
  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
}
__name(safeDecodeURIComponent, "safeDecodeURIComponent");
var httpMethods = ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/index.js
var make80 = make79;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpMiddleware.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var withLoggerDisabled2 = withLoggerDisabled;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpRouter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpRouter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServer.js
var HttpServer_exports = {};
__export(HttpServer_exports, {
  HttpServer: () => HttpServer,
  TypeId: () => TypeId46,
  addressFormattedWith: () => addressFormattedWith2,
  addressWith: () => addressWith2,
  formatAddress: () => formatAddress2,
  layerContext: () => layerContext2,
  layerTestClient: () => layerTestClient2,
  logAddress: () => logAddress2,
  make: () => make83,
  serve: () => serve2,
  serveEffect: () => serveEffect2,
  withLogAddress: () => withLogAddress2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/etag.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var GeneratorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Etag/Generator");
var tag6 = /* @__PURE__ */ GenericTag("@effect/platform/Etag/Generator");
var toString2 = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case "Weak":
      return `W/"${self2.value}"`;
    case "Strong":
      return `"${self2.value}"`;
  }
}, "toString");
var fromFileInfo = /* @__PURE__ */ __name((info2) => {
  const mtime = info2.mtime._tag === "Some" ? info2.mtime.value.getTime().toString(16) : "0";
  return `${info2.size.toString(16)}-${mtime}`;
}, "fromFileInfo");
var fromFileWeb = /* @__PURE__ */ __name((file3) => {
  return `${file3.size.toString(16)}-${file3.lastModified.toString(16)}`;
}, "fromFileWeb");
var layer2 = /* @__PURE__ */ succeed12(tag6, /* @__PURE__ */ tag6.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info2) {
    return sync6(() => ({
      _tag: "Strong",
      value: fromFileInfo(info2)
    }));
  },
  fromFileWeb(file3) {
    return sync6(() => ({
      _tag: "Strong",
      value: fromFileWeb(file3)
    }));
  }
}));
var layerWeak = /* @__PURE__ */ succeed12(tag6, /* @__PURE__ */ tag6.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info2) {
    return sync6(() => ({
      _tag: "Weak",
      value: fromFileInfo(info2)
    }));
  },
  fromFileWeb(file3) {
    return sync6(() => ({
      _tag: "Weak",
      value: fromFileWeb(file3)
    }));
  }
}));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpPlatform.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Etag.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var toString3 = toString2;
var Generator = tag6;
var layerWeak2 = layerWeak;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpPlatform.js
var TypeId44 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpPlatform");
var tag7 = /* @__PURE__ */ GenericTag("@effect/platform/HttpPlatform");
var make81 = /* @__PURE__ */ __name((impl) => gen3(function* () {
  const fs = yield* FileSystem;
  const etagGen = yield* Generator;
  return tag7.of({
    [TypeId44]: TypeId44,
    fileResponse(path, options4) {
      return pipe(bindTo4(fs.stat(path), "info"), bind4("etag", ({
        info: info2
      }) => etagGen.fromFileInfo(info2)), map20(({
        etag,
        info: info2
      }) => {
        const start3 = Number(options4?.offset ?? 0);
        const end6 = options4?.bytesToRead !== void 0 ? start3 + Number(options4.bytesToRead) : void 0;
        const headers = set11(options4?.headers ? fromInput3(options4.headers) : empty36, "etag", toString3(etag));
        if (info2.mtime._tag === "Some") {
          ;
          headers["last-modified"] = info2.mtime.value.toUTCString();
        }
        const contentLength = end6 !== void 0 ? end6 - start3 : Number(info2.size) - start3;
        return impl.fileResponse(path, options4?.status ?? 200, options4?.statusText, headers, start3, end6, contentLength);
      }));
    },
    fileWebResponse(file3, options4) {
      return map20(etagGen.fromFileWeb(file3), (etag) => {
        const headers = merge11(options4?.headers ? fromInput3(options4.headers) : empty36, unsafeFromRecord({
          etag: toString3(etag),
          "last-modified": new Date(file3.lastModified).toUTCString()
        }));
        return impl.fileWebResponse(file3, options4?.status ?? 200, options4?.statusText, headers, options4);
      });
    }
  });
}), "make");
var layer3 = /* @__PURE__ */ effect(tag7, flatMap14(FileSystem, (fs) => make81({
  fileResponse(path, status3, statusText, headers, start3, end6, contentLength) {
    return stream4(fs.stream(path, {
      offset: start3,
      bytesToRead: end6 !== void 0 ? end6 - start3 : void 0
    }), {
      contentLength,
      headers,
      status: status3,
      statusText
    });
  },
  fileWebResponse(file3, status3, statusText, headers, _options) {
    return stream4(fromReadableStream2(() => file3.stream(), identity), {
      headers,
      status: status3,
      statusText
    });
  }
}))).pipe(/* @__PURE__ */ provide3(layerWeak2));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpServer.js
var TypeId45 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServer");
var serverTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServer");
var serverProto = {
  [TypeId45]: TypeId45
};
var make82 = /* @__PURE__ */ __name((options4) => Object.assign(Object.create(serverProto), options4), "make");
var serve = /* @__PURE__ */ dual((args2) => isEffect2(args2[0]), (httpApp, middleware2) => scopedDiscard2(flatMap14(serverTag, (server) => server.serve(httpApp, middleware2))));
var serveEffect = /* @__PURE__ */ dual((args2) => isEffect2(args2[0]), (httpApp, middleware2) => flatMap14(serverTag, (server) => server.serve(httpApp, middleware2)));
var formatAddress = /* @__PURE__ */ __name((address) => {
  switch (address._tag) {
    case "UnixAddress":
      return `unix://${address.path}`;
    case "TcpAddress":
      return `http://${address.hostname}:${address.port}`;
  }
}, "formatAddress");
var addressWith = /* @__PURE__ */ __name((effect4) => flatMap14(serverTag, (server) => effect4(server.address)), "addressWith");
var addressFormattedWith = /* @__PURE__ */ __name((effect4) => flatMap14(serverTag, (server) => effect4(formatAddress(server.address))), "addressFormattedWith");
var logAddress = /* @__PURE__ */ addressFormattedWith((_) => log3(`Listening on ${_}`));
var withLogAddress = /* @__PURE__ */ __name((layer13) => effectDiscard(logAddress).pipe(provideMerge2(layer13)), "withLogAddress");
var makeTestClient = /* @__PURE__ */ addressWith((address) => flatMap14(HttpClient, (client) => {
  if (address._tag === "UnixAddress") {
    return die7(new Error("HttpServer.layerTestClient: UnixAddress not supported"));
  }
  const host = address.hostname === "0.0.0.0" ? "127.0.0.1" : address.hostname;
  const url2 = `http://${host}:${address.port}`;
  return succeed10(mapRequest2(client, prependUrl2(url2)));
}));
var layerTestClient = /* @__PURE__ */ effect(HttpClient, makeTestClient);
var layerContext = /* @__PURE__ */ mergeAll5(layer3, layer, layerWeak).pipe(/* @__PURE__ */ provideMerge2(/* @__PURE__ */ layerNoop({})));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpServer.js
var TypeId46 = TypeId45;
var HttpServer = serverTag;
var make83 = make82;
var serve2 = serve;
var serveEffect2 = serveEffect;
var formatAddress2 = formatAddress;
var addressWith2 = addressWith;
var addressFormattedWith2 = addressFormattedWith;
var logAddress2 = logAddress;
var withLogAddress2 = withLogAddress;
var layerTestClient2 = layerTestClient;
var layerContext2 = layerContext;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/httpRouter.js
var TypeId47 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter");
var RouteTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter/Route");
var RouteContextTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter/RouteContext");
var RouteContext = /* @__PURE__ */ GenericTag("@effect/platform/HttpRouter/RouteContext");
var isRouter = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId47), "isRouter");
var currentRouterConfig = /* @__PURE__ */ globalValue("@effect/platform/HttpRouter/currentRouterConfig", () => unsafeMake12({}));
var RouterImpl2 = class extends StructuralClass {
  routes;
  mounts;
  [TypeId47];
  constructor(routes, mounts) {
    super();
    this.routes = routes;
    this.mounts = mounts;
    this[TypeId47] = TypeId47;
    this.httpApp = toHttpApp(this).pipe(flatMap14((app) => this.httpApp = app));
  }
  httpApp;
  commit() {
    return this.httpApp;
  }
  toJSON() {
    return {
      _id: "Router",
      routes: this.routes.toJSON(),
      mounts: this.mounts.toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
__name(RouterImpl2, "RouterImpl");
var toHttpApp = /* @__PURE__ */ __name((self2) => map20(get14(currentRouterConfig), (config2) => {
  const router = make80(config2);
  const mounts = toReadonlyArray(self2.mounts).map(([path, app, options4]) => [path, new RouteContextImpl(new RouteImpl("*", options4?.includePrefix ? `${path}/*` : "/*", app, options4?.includePrefix ? none2() : some3(path), false), {}), options4]);
  const mountsLen = mounts.length;
  forEach(self2.routes, (route2) => {
    if (route2.method === "*") {
      router.all(route2.path, route2);
    } else {
      router.on(route2.method, route2.path, route2);
    }
  });
  return withFiberRuntime2((fiber) => {
    const context11 = unsafeMake(new Map(fiber.getFiberRef(currentContext2).unsafeMap));
    const request2 = unsafeGet5(context11, HttpServerRequest);
    if (mountsLen > 0) {
      const searchIndex = request2.url.indexOf("?");
      const pathname = searchIndex === -1 ? request2.url : request2.url.slice(0, searchIndex);
      for (let i = 0; i < mountsLen; i++) {
        const [path, routeContext, options4] = mounts[i];
        if (pathname === path || pathname.startsWith(path + "/")) {
          context11.unsafeMap.set(RouteContext.key, routeContext);
          if (options4?.includePrefix !== true) {
            context11.unsafeMap.set(HttpServerRequest.key, sliceRequestUrl(request2, path));
          }
          return locally2(flatMap14(routeContext.route.handler, toResponse), currentContext2, context11);
        }
      }
    }
    let result = router.find(request2.method, request2.url);
    if (result === void 0 && request2.method === "HEAD") {
      result = router.find("GET", request2.url);
    }
    if (result === void 0) {
      return fail10(new RouteNotFound({
        request: request2
      }));
    }
    const route2 = result.handler;
    if (route2.prefix._tag === "Some") {
      context11.unsafeMap.set(HttpServerRequest.key, sliceRequestUrl(request2, route2.prefix.value));
    }
    context11.unsafeMap.set(ParsedSearchParams.key, result.searchParams);
    context11.unsafeMap.set(RouteContext.key, new RouteContextImpl(route2, result.params));
    const span4 = getOption2(context11, ParentSpan);
    if (span4._tag === "Some" && span4.value._tag === "Span") {
      span4.value.attribute("http.route", route2.path);
    }
    const handlerResponse = flatMap14(route2.handler, toResponse);
    return locally2(route2.uninterruptible ? handlerResponse : interruptible4(handlerResponse), currentContext2, context11);
  });
}), "toHttpApp");
function sliceRequestUrl(request2, prefix3) {
  const prefexLen = prefix3.length;
  return request2.modify({
    url: request2.url.length <= prefexLen ? "/" : request2.url.slice(prefexLen)
  });
}
__name(sliceRequestUrl, "sliceRequestUrl");
var RouteImpl = class extends Class {
  method;
  path;
  handler;
  prefix;
  uninterruptible;
  [RouteTypeId];
  constructor(method, path, handler, prefix3 = none2(), uninterruptible4 = false) {
    super();
    this.method = method;
    this.path = path;
    this.handler = handler;
    this.prefix = prefix3;
    this.uninterruptible = uninterruptible4;
    this[RouteTypeId] = RouteTypeId;
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpRouter/Route",
      method: this.method,
      path: this.path,
      prefix: this.prefix.toJSON()
    };
  }
};
__name(RouteImpl, "RouteImpl");
var RouteContextImpl = class {
  route;
  params;
  [RouteContextTypeId];
  constructor(route2, params2) {
    this.route = route2;
    this.params = params2;
    this[RouteContextTypeId] = RouteContextTypeId;
  }
};
__name(RouteContextImpl, "RouteContextImpl");
var empty43 = /* @__PURE__ */ new RouterImpl2(/* @__PURE__ */ empty3(), /* @__PURE__ */ empty3());
var append5 = /* @__PURE__ */ dual(2, (self2, route2) => new RouterImpl2(append2(self2.routes, route2), self2.mounts));
var concat4 = /* @__PURE__ */ dual(2, (self2, that) => concatAll4(self2, that));
var concatAll4 = /* @__PURE__ */ __name((...routers) => new RouterImpl2(routers.reduce((cur, acc) => appendAll2(cur, acc.routes), empty3()), routers.reduce((cur, acc) => appendAll2(cur, acc.mounts), empty3())), "concatAll");
var removeTrailingSlash = /* @__PURE__ */ __name((path) => path.endsWith("/") ? path.slice(0, -1) : path, "removeTrailingSlash");
var prefixAll = /* @__PURE__ */ dual(2, (self2, prefix3) => {
  prefix3 = removeTrailingSlash(prefix3);
  return new RouterImpl2(map5(self2.routes, (route2) => new RouteImpl(route2.method, route2.path === "/" ? prefix3 : prefix3 + route2.path, route2.handler, orElse(map2(route2.prefix, (_) => prefix3 + _), () => some3(prefix3)), route2.uninterruptible)), map5(self2.mounts, ([path, app]) => [path === "/" ? prefix3 : prefix3 + path, app]));
});
var mount = /* @__PURE__ */ dual(3, (self2, path, that) => concat4(self2, prefixAll(that, path)));
var mountApp = /* @__PURE__ */ dual((args2) => hasProperty(args2[0], TypeId47), (self2, path, that, options4) => new RouterImpl2(self2.routes, append2(self2.mounts, [removeTrailingSlash(path), that, options4])));
var route = /* @__PURE__ */ __name((method) => dual((args2) => isRouter(args2[0]), (self2, path, handler, options4) => new RouterImpl2(append2(self2.routes, new RouteImpl(method, path, handler, none2(), options4?.uninterruptible ?? false)), self2.mounts)), "route");
var all11 = /* @__PURE__ */ route("*");
var get22 = /* @__PURE__ */ route("GET");
var post4 = /* @__PURE__ */ route("POST");
var put3 = /* @__PURE__ */ route("PUT");
var patch11 = /* @__PURE__ */ route("PATCH");
var del3 = /* @__PURE__ */ route("DELETE");
var head9 = /* @__PURE__ */ route("HEAD");
var options3 = /* @__PURE__ */ route("OPTIONS");
var makeService = /* @__PURE__ */ __name(() => {
  let router = empty43;
  return {
    addRoute(route2) {
      return sync6(() => {
        router = append5(router, route2);
      });
    },
    all(path, handler, options4) {
      return sync6(() => {
        router = all11(router, path, handler, options4);
      });
    },
    get(path, handler, options4) {
      return sync6(() => {
        router = get22(router, path, handler, options4);
      });
    },
    post(path, handler, options4) {
      return sync6(() => {
        router = post4(router, path, handler, options4);
      });
    },
    put(path, handler, options4) {
      return sync6(() => {
        router = put3(router, path, handler, options4);
      });
    },
    patch(path, handler, options4) {
      return sync6(() => {
        router = patch11(router, path, handler, options4);
      });
    },
    del(path, handler, options4) {
      return sync6(() => {
        router = del3(router, path, handler, options4);
      });
    },
    head(path, handler, options4) {
      return sync6(() => {
        router = head9(router, path, handler, options4);
      });
    },
    options(path, handler, opts) {
      return sync6(() => {
        router = options3(router, path, handler, opts);
      });
    },
    router: sync6(() => router),
    mount(path, that) {
      return sync6(() => {
        router = mount(router, path, that);
      });
    },
    mountApp(path, app, options4) {
      return sync6(() => {
        router = mountApp(router, path, app, options4);
      });
    },
    concat(that) {
      return sync6(() => {
        router = concat4(router, that);
      });
    }
  };
}, "makeService");
var Tag4 = /* @__PURE__ */ __name((id3) => () => {
  const Err = globalThis.Error;
  const limit = Err.stackTraceLimit;
  Err.stackTraceLimit = 2;
  const creationError = new Err();
  Err.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  const TagClass_ = TagClass;
  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(GenericTag(id3)));
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  TagClass_.Live = sync8(TagClass_, makeService);
  TagClass_.router = flatMap14(TagClass_, (_) => _.router);
  TagClass_.use = (f) => TagClass_.pipe(flatMap14(f), scopedDiscard2, provide3(TagClass_.Live));
  TagClass_.unwrap = (f) => TagClass_.pipe(flatMap14((_) => _.router), map20(f), unwrapEffect2, provide3(TagClass_.Live));
  TagClass_.serve = (middleware2) => TagClass_.unwrap(serve2(middleware2));
  return TagClass;
}, "Tag");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpRouter.js
var Tag5 = Tag4;
var Default = class extends (/* @__PURE__ */ Tag5("@effect/platform/HttpRouter/Default")()) {
};
__name(Default, "Default");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/HttpLayerRouter.js
var HttpRouter = /* @__PURE__ */ GenericTag("@effect/platform/HttpLayerRouter");
var MiddlewareTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpLayerRouter/Middleware");
var middleware = /* @__PURE__ */ __name(function() {
  if (arguments.length === 0) {
    return makeMiddleware;
  }
  return makeMiddleware(arguments[0], arguments[1]);
}, "middleware");
var makeMiddleware = /* @__PURE__ */ __name((middleware2, options4) => options4?.global ? scopedDiscard2(gen3(function* () {
  const router = yield* HttpRouter;
  const fn2 = isEffect2(middleware2) ? yield* middleware2 : middleware2;
  yield* router.addGlobalMiddleware(fn2);
})) : new MiddlewareImpl(isEffect2(middleware2) ? scopedContext2(map20(middleware2, (fn2) => unsafeMake(/* @__PURE__ */ new Map([[fnContextKey, fn2]])))) : succeedContext2(unsafeMake(/* @__PURE__ */ new Map([[fnContextKey, middleware2]])))), "makeMiddleware");
var middlewareId = 0;
var fnContextKey = "@effect/platform/HttpLayerRouter/MiddlewareFn";
var MiddlewareImpl = class {
  layerFn;
  dependencies;
  [MiddlewareTypeId] = {};
  constructor(layerFn, dependencies) {
    this.layerFn = layerFn;
    this.dependencies = dependencies;
    const contextKey = `@effect/platform/HttpLayerRouter/Middleware-${++middlewareId}`;
    this.layer = scopedContext2(gen3(this, function* () {
      const context11 = yield* context3();
      const stack = [context11.unsafeMap.get(fnContextKey)];
      if (this.dependencies) {
        const memoMap = yield* CurrentMemoMap2;
        const scope5 = get6(context11, Scope);
        const depsContext = yield* buildWithMemoMap2(this.dependencies, memoMap, scope5);
        stack.push(...getMiddleware(depsContext));
      }
      return unsafeMake(/* @__PURE__ */ new Map([[contextKey, stack]]));
    })).pipe(provide3(this.layerFn));
  }
  layer;
  combine(other) {
    return new MiddlewareImpl(this.layerFn, this.dependencies ? provideMerge2(this.dependencies, other.layer) : other.layer);
  }
};
__name(MiddlewareImpl, "MiddlewareImpl");
var middlewareCache = /* @__PURE__ */ new WeakMap();
var getMiddleware = /* @__PURE__ */ __name((context11) => {
  let arr = middlewareCache.get(context11);
  if (arr)
    return arr;
  const topLevel = empty2();
  let maxLength2 = 0;
  for (const [key, value6] of context11.unsafeMap) {
    if (key.startsWith("@effect/platform/HttpLayerRouter/Middleware-")) {
      topLevel.push(value6);
      if (value6.length > maxLength2) {
        maxLength2 = value6.length;
      }
    }
  }
  if (topLevel.length === 0) {
    arr = [];
  } else {
    const middleware2 = /* @__PURE__ */ new Set();
    for (let i = maxLength2 - 1; i >= 0; i--) {
      for (const arr2 of topLevel) {
        if (i < arr2.length) {
          middleware2.add(arr2[i]);
        }
      }
    }
    arr = fromIterable2(middleware2).reverse();
  }
  middlewareCache.set(context11, arr);
  return arr;
}, "getMiddleware");
var disableLogger = middleware(withLoggerDisabled2).layer;

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/SocketServer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SocketServer = class extends (/* @__PURE__ */ Tag2("@effect/platform/SocketServer")()) {
};
__name(SocketServer, "SocketServer");
var ErrorTypeId3 = /* @__PURE__ */ Symbol.for("@effect/platform/SocketServer/SocketServerError");
var SocketServerError = class extends (/* @__PURE__ */ TaggedError("SocketServerError")) {
  /**
   * @since 1.0.0
   */
  [ErrorTypeId3] = ErrorTypeId3;
  /**
   * @since 1.0.0
   */
  get message() {
    return this.reason;
  }
};
__name(SocketServerError, "SocketServerError");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/WorkerRunner.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/workerRunner.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var PlatformRunner = /* @__PURE__ */ GenericTag("@effect/platform/Runner/PlatformRunner");
var CloseLatch = /* @__PURE__ */ Reference2()("@effect/platform/WorkerRunner/CloseLatch", {
  defaultValue: () => unsafeMake10(none4)
});

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/WorkerRunner.js
var PlatformRunner2 = PlatformRunner;
var CloseLatch2 = CloseLatch;

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/RpcServer.js
var makeNoSerialization = /* @__PURE__ */ fnUntraced2(function* (group2, options4) {
  const enableTracing = options4.disableTracing !== true;
  const enableSpanPropagation = options4.disableSpanPropagation !== true;
  const supportsAck = options4.disableClientAcks !== true;
  const spanPrefix = options4.spanPrefix ?? "RpcServer";
  const concurrency = options4.concurrency ?? "unbounded";
  const disableFatalDefects = options4.disableFatalDefects ?? false;
  const context11 = yield* context3();
  const scope5 = get6(context11, Scope);
  const fiberSet = yield* make65();
  const runFork4 = yield* runtime5(fiberSet)().pipe(interruptible4);
  const concurrencySemaphore = concurrency === "unbounded" ? void 0 : yield* makeSemaphore2(concurrency);
  const clients = /* @__PURE__ */ new Map();
  let isShutdown7 = false;
  const shutdownLatch = unsafeMakeLatch2(false);
  yield* addFinalizer2(scope5, fiberIdWith2((fiberId3) => {
    isShutdown7 = true;
    for (const client of clients.values()) {
      client.ended = true;
      if (client.fibers.size === 0) {
        runFork4(endClient(client));
        continue;
      }
      for (const fiber of client.fibers.values()) {
        fiber.unsafeInterruptAsFork(fiberId3);
      }
    }
    if (clients.size === 0) {
      return _void;
    }
    return shutdownLatch.await;
  }));
  const disconnect3 = /* @__PURE__ */ __name((clientId) => fiberIdWith2((fiberId3) => {
    const client = clients.get(clientId);
    if (!client)
      return _void;
    for (const fiber of client.fibers.values()) {
      fiber.unsafeInterruptAsFork(fiberId3);
    }
    clients.delete(clientId);
    return _void;
  }), "disconnect");
  const write3 = /* @__PURE__ */ __name((clientId, message) => catchAllDefect2(withFiberRuntime2((requestFiber) => {
    if (isShutdown7)
      return interrupt7;
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        latches: /* @__PURE__ */ new Map(),
        fibers: /* @__PURE__ */ new Map(),
        ended: false
      };
      clients.set(clientId, client);
    } else if (client.ended) {
      return interrupt7;
    }
    switch (message._tag) {
      case "Request": {
        return handleRequest(requestFiber, client, message);
      }
      case "Ack": {
        const latch = client.latches.get(message.requestId);
        return latch ? latch.open : _void;
      }
      case "Interrupt": {
        const fiber = client.fibers.get(message.requestId);
        return fiber ? interruptAsFork2(fiber, fiberIdClientInterrupt) : options4.onFromServer({
          _tag: "Exit",
          clientId,
          requestId: message.requestId,
          exit: interrupt3(none4)
        });
      }
      case "Eof": {
        client.ended = true;
        if (client.fibers.size > 0)
          return _void;
        return endClient(client);
      }
      default: {
        return sendDefect(client, `Unknown request tag: ${message._tag}`);
      }
    }
  }), (defect) => sendDefect(clients.get(clientId), defect)), "write");
  const endClient = /* @__PURE__ */ __name((client) => {
    clients.delete(client.id);
    const write4 = options4.onFromServer({
      _tag: "ClientEnd",
      clientId: client.id
    });
    if (isShutdown7 && clients.size === 0) {
      return zipRight6(write4, shutdownLatch.open);
    }
    return write4;
  }, "endClient");
  const handleRequest = /* @__PURE__ */ __name((requestFiber, client, request2) => {
    if (client.fibers.has(request2.id)) {
      return interrupt7;
    }
    const rpc = group2.requests.get(request2.tag);
    const entry = context11.unsafeMap.get(rpc?.key);
    if (!rpc || !entry) {
      const write4 = catchAllDefect2(options4.onFromServer({
        _tag: "Exit",
        clientId: client.id,
        requestId: request2.id,
        exit: die3(`Unknown request tag: ${request2.tag}`)
      }), (defect) => sendDefect(client, defect));
      if (!client.ended || client.fibers.size > 0)
        return write4;
      return zipRight6(write4, endClient(client));
    }
    const isStream3 = isStreamSchema(rpc.successSchema);
    const result = entry.handler(request2.payload, {
      clientId: client.id,
      headers: request2.headers
    });
    const isWrapper2 = isWrapper(result);
    const isFork = isWrapper2 && result.fork;
    const isUninterruptible = isWrapper2 && result.uninterruptible;
    const streamOrEffect = isWrapper2 ? result.value : result;
    const handler = applyMiddleware(rpc, context11, client.id, request2.payload, request2.headers, isStream3 ? streamEffect(client, request2, streamOrEffect) : streamOrEffect);
    let responded = false;
    let effect4 = matchCauseEffect3(isUninterruptible ? handler : interruptible4(handler), {
      onSuccess: (value6) => {
        responded = true;
        return options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: succeed3(value6)
        });
      },
      onFailure: (cause3) => {
        responded = true;
        if (!disableFatalDefects && isDie2(cause3) && !isInterrupted3(cause3)) {
          return sendDefect(client, squash(cause3));
        }
        return options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: failCause3(cause3)
        });
      }
    });
    if (enableTracing) {
      const parentSpan3 = requestFiber.currentContext.unsafeMap.get(ParentSpan.key);
      effect4 = withSpan3(effect4, `${spanPrefix}.${request2.tag}`, {
        captureStackTrace: false,
        attributes: options4.spanAttributes,
        parent: enableSpanPropagation && request2.spanId ? {
          _tag: "ExternalSpan",
          traceId: request2.traceId,
          spanId: request2.spanId,
          sampled: request2.sampled,
          context: empty9()
        } : void 0,
        links: enableSpanPropagation && parentSpan3 ? [{
          _tag: "SpanLink",
          span: parentSpan3,
          attributes: {}
        }] : void 0
      });
    }
    if (!isFork && concurrencySemaphore) {
      effect4 = concurrencySemaphore.withPermits(1)(effect4);
    }
    const runtime6 = make53({
      context: merge3(entry.context, requestFiber.currentContext),
      fiberRefs: requestFiber.getFiberRefs(),
      runtimeFlags: disable4(defaultRuntime2.runtimeFlags, Interruption2)
    });
    const fiber = runFork3(runtime6, effect4);
    unsafeAdd(fiberSet, fiber);
    client.fibers.set(request2.id, fiber);
    fiber.addObserver((exit4) => {
      if (!responded && exit4._tag === "Failure") {
        unsafeAdd(fiberSet, runFork3(runtime6, options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: interrupt3(none4)
        })));
      }
      client.fibers.delete(request2.id);
      client.latches.delete(request2.id);
      if (client.ended && client.fibers.size === 0) {
        unsafeAdd(fiberSet, runFork3(runtime6, endClient(client)));
      }
    });
    return _void;
  }, "handleRequest");
  const streamEffect = /* @__PURE__ */ __name((client, request2, stream6) => {
    let latch = client.latches.get(request2.id);
    if (supportsAck && !latch) {
      latch = unsafeMakeLatch2(false);
      client.latches.set(request2.id, latch);
    }
    if (isEffect2(stream6)) {
      let done12 = false;
      return stream6.pipe(flatMap14((mailbox) => whileLoop3({
        while: () => !done12,
        body: constant(flatMap14(mailbox.takeAll, ([chunk4, done_]) => {
          done12 = done_;
          if (!isNonEmpty(chunk4))
            return _void;
          const write4 = options4.onFromServer({
            _tag: "Chunk",
            clientId: client.id,
            requestId: request2.id,
            values: toReadonlyArray(chunk4)
          });
          if (!latch)
            return write4;
          latch.unsafeClose();
          return zipRight6(write4, latch.await);
        })),
        step: constVoid
      })), scoped3);
    }
    return runForEachChunk2(stream6, (chunk4) => {
      if (!isNonEmpty(chunk4))
        return _void;
      const write4 = options4.onFromServer({
        _tag: "Chunk",
        clientId: client.id,
        requestId: request2.id,
        values: toReadonlyArray(chunk4)
      });
      if (!latch)
        return write4;
      latch.unsafeClose();
      return zipRight6(write4, latch.await);
    });
  }, "streamEffect");
  const sendDefect = /* @__PURE__ */ __name((client, defect) => suspend4(() => {
    const shouldEnd = client.ended && client.fibers.size === 0;
    const write4 = options4.onFromServer({
      _tag: "Defect",
      clientId: client.id,
      defect
    });
    if (!shouldEnd)
      return write4;
    return zipRight6(write4, endClient(client));
  }), "sendDefect");
  return identity({
    write: write3,
    disconnect: disconnect3
  });
});
var applyMiddleware = /* @__PURE__ */ __name((rpc, context11, clientId, payload, headers, handler) => {
  if (rpc.middlewares.size === 0) {
    return handler;
  }
  const options4 = {
    rpc,
    payload,
    headers,
    clientId
  };
  for (const tag8 of rpc.middlewares) {
    if (tag8.wrap) {
      const middleware2 = unsafeGet5(context11, tag8);
      handler = middleware2({
        ...options4,
        next: handler
      });
    } else if (tag8.optional) {
      const middleware2 = unsafeGet5(context11, tag8);
      const previous2 = handler;
      handler = matchEffect3(middleware2(options4), {
        onFailure: () => previous2,
        onSuccess: tag8.provides !== void 0 ? (value6) => provideService2(previous2, tag8.provides, value6) : (_) => previous2
      });
    } else {
      const middleware2 = unsafeGet5(context11, tag8);
      handler = tag8.provides !== void 0 ? provideServiceEffect2(handler, tag8.provides, middleware2(options4)) : zipRight6(middleware2(options4), handler);
    }
  }
  return handler;
}, "applyMiddleware");
var make85 = /* @__PURE__ */ fnUntraced2(function* (group2, options4) {
  const {
    disconnects,
    end: end6,
    run: run6,
    send,
    supportsAck,
    supportsSpanPropagation,
    supportsTransferables
  } = yield* Protocol;
  const context11 = yield* context3();
  const scope5 = yield* make39();
  const server = yield* makeNoSerialization(group2, {
    ...options4,
    disableClientAcks: !supportsAck,
    disableSpanPropagation: !supportsSpanPropagation,
    onFromServer(response) {
      const client = clients.get(response.clientId);
      if (!client)
        return _void;
      switch (response._tag) {
        case "Chunk": {
          const schemas = client.schemas.get(response.requestId);
          if (!schemas)
            return _void;
          return handleEncode(client, response.requestId, schemas.collector, provide2(schemas.encodeChunk(response.values), schemas.context), (values6) => ({
            _tag: "Chunk",
            requestId: String(response.requestId),
            values: values6
          }));
        }
        case "Exit": {
          const schemas = client.schemas.get(response.requestId);
          if (!schemas)
            return _void;
          client.schemas.delete(response.requestId);
          return handleEncode(client, response.requestId, schemas.collector, provide2(schemas.encodeExit(response.exit), schemas.context), (exit4) => ({
            _tag: "Exit",
            requestId: String(response.requestId),
            exit: exit4
          }));
        }
        case "Defect": {
          return sendDefect(client, response.defect);
        }
        case "ClientEnd": {
          clients.delete(response.clientId);
          return end6(response.clientId);
        }
      }
    }
  }).pipe(extend2(scope5));
  yield* fork3(interruptible4(whileLoop3({
    while: constTrue,
    body: constant(flatMap14(disconnects.take, (clientId) => {
      clients.delete(clientId);
      return server.disconnect(clientId);
    })),
    step: constVoid
  })));
  const schemasCache = /* @__PURE__ */ new WeakMap();
  const getSchemas = /* @__PURE__ */ __name((rpc) => {
    let schemas = schemasCache.get(rpc);
    if (!schemas) {
      const entry = context11.unsafeMap.get(rpc.key);
      const streamSchemas = getStreamSchemas(rpc.successSchema.ast);
      schemas = {
        decode: decodeUnknown3(rpc.payloadSchema),
        encodeChunk: encodeUnknown2(Array$(isSome2(streamSchemas) ? streamSchemas.value.success : Any)),
        encodeExit: encodeUnknown2(exitSchema2(rpc)),
        context: entry.context
      };
      schemasCache.set(rpc, schemas);
    }
    return schemas;
  }, "getSchemas");
  const clients = /* @__PURE__ */ new Map();
  const handleEncode = /* @__PURE__ */ __name((client, requestId, collector, effect4, onSuccess) => (collector ? provideService2(effect4, Collector, collector) : effect4).pipe(flatMap14((a) => send(client.id, onSuccess(a), collector && collector.unsafeClear())), catchAllCause3((cause3) => {
    client.schemas.delete(requestId);
    const defect = squash(map16(cause3, TreeFormatter.formatErrorSync));
    return zipRight6(sendRequestDefect(client, requestId, defect), server.write(client.id, {
      _tag: "Interrupt",
      requestId,
      interruptors: []
    }));
  })), "handleEncode");
  const sendRequestDefect = /* @__PURE__ */ __name((client, requestId, defect) => catchAllCause3(send(client.id, {
    _tag: "Exit",
    requestId: String(requestId),
    exit: {
      _tag: "Failure",
      cause: {
        _tag: "Die",
        defect
      }
    }
  }), (cause3) => sendDefect(client, squash(cause3))), "sendRequestDefect");
  const sendDefect = /* @__PURE__ */ __name((client, defect) => catchAllCause3(send(client.id, {
    _tag: "Defect",
    defect
  }), (cause3) => annotateLogs3(logDebug2(cause3), {
    module: "RpcServer",
    method: "sendDefect"
  })), "sendDefect");
  return yield* run6((clientId, request2) => {
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        schemas: /* @__PURE__ */ new Map()
      };
      clients.set(clientId, client);
    }
    switch (request2._tag) {
      case "Request": {
        const tag8 = hasProperty(request2, "tag") ? request2.tag : "";
        const rpc = group2.requests.get(tag8);
        if (!rpc) {
          return sendDefect(client, `Unknown request tag: ${tag8}`);
        }
        let requestId;
        switch (typeof request2.id) {
          case "bigint":
          case "string": {
            requestId = RequestId(request2.id);
            break;
          }
          default: {
            return sendDefect(client, `Invalid request id: ${request2.id}`);
          }
        }
        const schemas = getSchemas(rpc);
        return matchEffect3(provide2(schemas.decode(request2.payload), schemas.context), {
          onFailure: (error3) => sendRequestDefect(client, requestId, TreeFormatter.formatErrorSync(error3)),
          onSuccess: (payload) => {
            client.schemas.set(requestId, supportsTransferables ? {
              ...schemas,
              collector: unsafeMakeCollector()
            } : schemas);
            return server.write(clientId, {
              ...request2,
              id: requestId,
              payload,
              headers: fromInput3(request2.headers)
            });
          }
        });
      }
      case "Ping": {
        return catchAllCause3(send(client.id, constPong), (cause3) => sendDefect(client, squash(cause3)));
      }
      case "Eof": {
        return server.write(clientId, request2);
      }
      case "Ack": {
        return server.write(clientId, {
          ...request2,
          requestId: RequestId(request2.requestId)
        });
      }
      case "Interrupt": {
        return server.write(clientId, {
          ...request2,
          requestId: RequestId(request2.requestId),
          interruptors: []
        });
      }
      default: {
        return sendDefect(client, `Unknown request tag: ${request2._tag}`);
      }
    }
  }).pipe(interruptible4, tapErrorCause3((cause3) => logFatal2("BUG: RpcServer protocol crashed", cause3)), onExit3((exit4) => close(scope5, exit4)));
});
var layer5 = /* @__PURE__ */ __name((group2, options4) => scopedDiscard2(forkScoped2(interruptible4(make85(group2, options4)))), "layer");
var layerHttpRouter = /* @__PURE__ */ __name((options4) => layer5(options4.group, options4).pipe(provide3(options4.protocol === "http" ? layerProtocolHttpRouter(options4) : layerProtocolWebsocketRouter(options4))), "layerHttpRouter");
var Protocol = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcServer/Protocol")()) {
};
__name(Protocol, "Protocol");
/**
 * @since 1.0.0
 */
__publicField(Protocol, "make", /* @__PURE__ */ withRun());
var makeProtocolSocketServer = /* @__PURE__ */ gen3(function* () {
  const server = yield* SocketServer;
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  yield* forkScoped2(interruptible4(server.run(fnUntraced2(onSocket, scoped3))));
  return protocol;
});
var layerProtocolSocketServer = /* @__PURE__ */ scoped4(Protocol, makeProtocolSocketServer);
var makeProtocolWithHttpAppWebsocket = /* @__PURE__ */ gen3(function* () {
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  const httpApp = gen3(function* () {
    const request2 = yield* HttpServerRequest;
    const socket = yield* orDie3(request2.upgrade);
    yield* onSocket(socket, Object.entries(request2.headers));
    return empty42();
  });
  return {
    protocol,
    httpApp
  };
});
var makeProtocolWebsocket = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  const router = yield* options4.routerTag ?? Default;
  yield* router.get(options4.path, httpApp);
  return protocol;
});
var makeProtocolWebsocketRouter = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const router = yield* HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* router.add("GET", options4.path, httpApp);
  return protocol;
});
var layerProtocolWebsocket = /* @__PURE__ */ __name((options4) => {
  const routerTag = options4.routerTag ?? Default;
  return effect(Protocol, makeProtocolWebsocket(options4)).pipe(provide3(routerTag.Live));
}, "layerProtocolWebsocket");
var layerProtocolWebsocketRouter = /* @__PURE__ */ __name((options4) => effect(Protocol, makeProtocolWebsocketRouter(options4)), "layerProtocolWebsocketRouter");
var makeProtocolWithHttpApp = /* @__PURE__ */ gen3(function* () {
  const serialization = yield* RpcSerialization;
  const includesFraming = serialization.includesFraming;
  const isBinary = !serialization.contentType.includes("json");
  const disconnects = yield* make68();
  let writeRequest;
  let clientId = 0;
  const clients = /* @__PURE__ */ new Map();
  const clientIds = /* @__PURE__ */ new Set();
  const encoder3 = new TextEncoder();
  const httpApp = gen3(function* () {
    const request2 = yield* HttpServerRequest;
    const scope5 = yield* scope3;
    const requestHeaders = Object.entries(request2.headers);
    const data = yield* orDie3(isBinary ? map20(request2.arrayBuffer, (ab) => new Uint8Array(ab)) : request2.text);
    const id3 = clientId++;
    const mailbox = yield* make68();
    const parser = serialization.unsafeMake();
    const offer6 = /* @__PURE__ */ __name((data2) => typeof data2 === "string" ? mailbox.offer(encoder3.encode(data2)) : mailbox.offer(data2), "offer");
    clientIds.add(id3);
    const client = {
      write: !includesFraming ? (response) => mailbox.offer(response) : (response) => {
        try {
          const encoded = parser.encode(response);
          if (encoded === void 0)
            return _void;
          return offer6(encoded);
        } catch (cause3) {
          return offer6(parser.encode(ResponseDefectEncoded(cause3)));
        }
      },
      end: mailbox.end
    };
    clients.set(id3, client);
    yield* addFinalizerExit(scope5, () => {
      clientIds.delete(id3);
      clients.delete(id3);
      disconnects.unsafeOffer(id3);
      if (mailbox.unsafeSize()._tag === "None")
        return _void;
      return forEach10(requestIds, (requestId) => writeRequest(id3, {
        _tag: "Interrupt",
        requestId: String(requestId)
      }), {
        discard: true
      });
    });
    const requestIds = [];
    try {
      const decoded = parser.decode(data);
      for (const message of decoded) {
        if (message._tag === "Request") {
          requestIds.push(RequestId(message.id));
          message.headers = requestHeaders.concat(message.headers);
        }
        yield* writeRequest(id3, message);
      }
    } catch (cause3) {
      yield* client.write(ResponseDefectEncoded(cause3));
    }
    yield* writeRequest(id3, constEof);
    if (!includesFraming) {
      const responses = empty2();
      while (true) {
        const [items, done13] = yield* mailbox.takeAll;
        responses.push(...items);
        if (done13)
          break;
      }
      return text3(parser.encode(responses), {
        contentType: serialization.contentType
      });
    }
    const [initialChunk, done12] = yield* mailbox.takeAll;
    if (done12) {
      return uint8Array4(mergeUint8Arrays(initialChunk), {
        contentType: serialization.contentType
      });
    }
    return stream5(fromChunk2(initialChunk).pipe(concat3(toStream2(mailbox))), {
      contentType: serialization.contentType
    });
  }).pipe(interruptible4);
  const protocol = yield* Protocol.make((writeRequest_) => {
    writeRequest = writeRequest_;
    return succeed10({
      disconnects,
      send(clientId2, response) {
        const client = clients.get(clientId2);
        if (!client)
          return _void;
        return client.write(response);
      },
      end(clientId2) {
        const client = clients.get(clientId2);
        if (!client)
          return _void;
        return client.end;
      },
      clientIds: sync6(() => clientIds),
      initialMessage: succeedNone2,
      supportsAck: false,
      supportsTransferables: false,
      supportsSpanPropagation: false
    });
  });
  return {
    protocol,
    httpApp
  };
});
var mergeUint8Arrays = /* @__PURE__ */ __name((arrays) => {
  if (arrays.length === 0)
    return new Uint8Array(0);
  if (arrays.length === 1)
    return unsafeHead2(arrays);
  const length4 = reduce2(arrays, 0, (acc, a) => acc + a.length);
  const result = new Uint8Array(length4);
  let offset = 0;
  for (const array6 of arrays) {
    result.set(array6, offset);
    offset += array6.length;
  }
  return result;
}, "mergeUint8Arrays");
var makeProtocolHttp = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  const router = yield* options4.routerTag ?? Default;
  yield* router.post(options4.path, httpApp);
  return protocol;
});
var makeProtocolHttpRouter = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const router = yield* HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* router.add("POST", options4.path, httpApp);
  return protocol;
});
var makeProtocolWorkerRunner = /* @__PURE__ */ Protocol.make(/* @__PURE__ */ fnUntraced2(function* (writeRequest) {
  const fiber = yield* withFiberRuntime2(succeed10);
  const runner = yield* PlatformRunner2;
  const closeLatch = yield* CloseLatch2;
  const backing = yield* runner.start(closeLatch);
  const initialMessage = yield* make41();
  const clientIds = /* @__PURE__ */ new Set();
  const disconnects = yield* make68();
  yield* _await3(closeLatch).pipe(onExit3(() => {
    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
    return _void;
  }), forkScoped2);
  yield* backing.run((clientId, message) => {
    clientIds.add(clientId);
    if (message._tag === "InitialMessage") {
      return succeed8(initialMessage, message.value);
    }
    return writeRequest(clientId, message);
  });
  yield* disconnects.take.pipe(tap4((clientId) => {
    clientIds.delete(clientId);
    return disconnects.offer(clientId);
  }), forkScoped2);
  return {
    disconnects,
    send: backing.send,
    end(_clientId) {
      return _void;
    },
    clientIds: sync6(() => clientIds),
    initialMessage: asSome2(_await3(initialMessage)),
    supportsAck: true,
    supportsTransferables: true,
    supportsSpanPropagation: true
  };
}));
var layerProtocolWorkerRunner = /* @__PURE__ */ scoped4(Protocol, makeProtocolWorkerRunner);
var layerProtocolHttp = /* @__PURE__ */ __name((options4) => {
  const routerTag = options4.routerTag ?? Default;
  return effect(Protocol, makeProtocolHttp(options4)).pipe(provide3(routerTag.Live));
}, "layerProtocolHttp");
var layerProtocolHttpRouter = /* @__PURE__ */ __name((options4) => effect(Protocol, makeProtocolHttpRouter(options4)), "layerProtocolHttpRouter");
var toHttpApp2 = /* @__PURE__ */ fnUntraced2(function* (group2, options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* make85(group2, options4).pipe(provideService2(Protocol, protocol), interruptible4, forkScoped2);
  return httpApp;
});
var toHttpAppWebsocket = /* @__PURE__ */ fnUntraced2(function* (group2, options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* make85(group2, options4).pipe(provideService2(Protocol, protocol), interruptible4, forkScoped2);
  return httpApp;
});
var toWebHandler2 = /* @__PURE__ */ __name((group2, options4) => toWebHandlerLayerWith(mergeAll5(options4.layer, scope4), {
  memoMap: options4?.memoMap,
  middleware: options4?.middleware,
  toHandler: (r) => provide2(toHttpApp2(group2, options4), r)
}), "toWebHandler");
var makeProtocolStdio = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const fiber = getOrThrow2(getCurrentFiber2());
  const serialization = yield* RpcSerialization;
  return yield* Protocol.make(fnUntraced2(function* (writeRequest) {
    const mailbox = yield* make68();
    const parser = serialization.unsafeMake();
    yield* options4.stdin.pipe(runForEach2((data) => {
      const decoded = parser.decode(data);
      if (decoded.length === 0)
        return _void;
      let i = 0;
      return whileLoop3({
        while: () => i < decoded.length,
        body: () => writeRequest(0, decoded[i++]),
        step: constVoid
      });
    }), sandbox2, tapError3(logError2), retry2(spaced2(500)), ensuring2(interruptFork(fiber)), forkScoped2, interruptible4);
    yield* toStream2(mailbox).pipe(run5(options4.stdout), retry2(spaced2(500)), forkScoped2, interruptible4);
    return {
      disconnects: yield* make68(),
      send(_clientId, response) {
        const responseEncoded = parser.encode(response);
        if (responseEncoded === void 0) {
          return _void;
        }
        return mailbox.offer(responseEncoded);
      },
      end(_clientId) {
        return mailbox.end;
      },
      clientIds: succeed10(/* @__PURE__ */ new Set([0])),
      initialMessage: succeedNone2,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    };
  }));
});
var layerProtocolStdio = /* @__PURE__ */ __name((options4) => scoped4(Protocol, makeProtocolStdio(options4)), "layerProtocolStdio");
var fiberIdClientInterrupt = /* @__PURE__ */ make14(-499, 0);
var makeSocketProtocol = /* @__PURE__ */ gen3(function* () {
  const serialization = yield* RpcSerialization;
  const disconnects = yield* make68();
  let clientId = 0;
  const clients = /* @__PURE__ */ new Map();
  const clientIds = /* @__PURE__ */ new Set();
  let writeRequest;
  const onSocket = /* @__PURE__ */ __name(function* (socket, headers) {
    const scope5 = yield* scope3;
    const parser = serialization.unsafeMake();
    const id3 = clientId++;
    yield* addFinalizerExit(scope5, () => {
      clientIds.delete(id3);
      clients.delete(id3);
      return disconnects.offer(id3);
    });
    const writeRaw = yield* socket.writer;
    const write3 = /* @__PURE__ */ __name((response) => {
      try {
        const encoded = parser.encode(response);
        if (encoded === void 0) {
          return _void;
        }
        return orDie3(writeRaw(encoded));
      } catch (cause3) {
        return orDie3(writeRaw(parser.encode(ResponseDefectEncoded(cause3))));
      }
    }, "write");
    clientIds.add(id3);
    clients.set(id3, {
      write: write3
    });
    yield* socket.runRaw((data) => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0)
          return _void;
        let i = 0;
        return whileLoop3({
          while: () => i < decoded.length,
          body() {
            const message = decoded[i++];
            if (message._tag === "Request" && headers) {
              ;
              message.headers = headers.concat(message.headers);
            }
            return writeRequest(id3, message);
          },
          step: constVoid
        });
      } catch (cause3) {
        return writeRaw(parser.encode(ResponseDefectEncoded(cause3)));
      }
    }).pipe(interruptible4, catchIf2((error3) => error3.reason === "Close", () => _void), orDie3);
  }, "onSocket");
  const protocol = yield* Protocol.make((writeRequest_) => {
    writeRequest = writeRequest_;
    return succeed10({
      disconnects,
      send: (clientId2, response) => {
        const client = clients.get(clientId2);
        if (!client)
          return _void;
        return orDie3(client.write(response));
      },
      end(_clientId) {
        return _void;
      },
      clientIds: sync6(() => clientIds),
      initialMessage: succeedNone2,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    });
  });
  return {
    protocol,
    onSocket
  };
});

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/Otlp.js
var Otlp_exports = {};
__export(Otlp_exports, {
  layer: () => layer9
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/OtlpLogger.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/internal/otlpExporter.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var policy = /* @__PURE__ */ forever4.pipe(passthrough4, /* @__PURE__ */ addDelay2((error3) => {
  if (isHttpClientError(error3) && error3._tag === "ResponseError" && error3.response.status === 429) {
    const retryAfter = fromNullable(error3.response.headers["retry-after"]).pipe(flatMap(parse), getOrElse(() => 5));
    return seconds(retryAfter);
  }
  return seconds(1);
}));
var make86 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const clock3 = yield* clock2;
  const scope5 = yield* scope3;
  const exportInterval = decode(options4.exportInterval);
  let disabledUntil = void 0;
  const client = filterStatusOk3(yield* HttpClient).pipe(retryTransient2({
    schedule: policy,
    times: 3
  }));
  let headers = unsafeFromRecord({
    "user-agent": `effect-opentelemetry-${options4.label}/0.0.0`
  });
  if (options4.headers) {
    headers = merge11(fromInput3(options4.headers), headers);
  }
  const request2 = post3(options4.url, {
    headers
  });
  let buffer4 = [];
  const runExport = suspend4(() => {
    if (disabledUntil !== void 0 && clock3.unsafeCurrentTimeMillis() < disabledUntil) {
      return _void;
    } else if (disabledUntil !== void 0) {
      disabledUntil = void 0;
    }
    const items = buffer4;
    if (options4.maxBatchSize !== "disabled") {
      if (buffer4.length === 0) {
        return _void;
      }
      buffer4 = [];
    }
    return client.execute(bodyUnsafeJson2(request2, options4.body(items))).pipe(asVoid5, withTracerEnabled2(false));
  }).pipe(catchAllCause3((cause3) => {
    if (disabledUntil !== void 0)
      return _void;
    disabledUntil = clock3.unsafeCurrentTimeMillis() + toMillis("1 minute");
    return logDebug2(`Disabling ${options4.label} for 60 seconds`, cause3);
  }));
  yield* addFinalizer2(scope5, runExport.pipe(ignore2, interruptible4, timeoutOption2(options4.shutdownTimeout)));
  yield* sleep4(exportInterval).pipe(zipRight6(runExport), forever3, annotateLogs3({
    package: "@effect/opentelemetry",
    module: options4.label
  }), forkIn2(scope5), interruptible4);
  const runFork4 = yield* makeRuntime().pipe(interruptible4);
  return {
    push(data) {
      if (disabledUntil !== void 0)
        return;
      buffer4.push(data);
      if (options4.maxBatchSize !== "disabled" && buffer4.length >= options4.maxBatchSize) {
        runFork4(runExport);
      }
    }
  };
});

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/OtlpResource.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ATTR_SERVICE_NAME = "service.name";
var ATTR_SERVICE_VERSION = "service.version";
var make87 = /* @__PURE__ */ __name((options4) => {
  const resourceAttributes = options4.attributes ? entriesToAttributes(Object.entries(options4.attributes)) : [];
  resourceAttributes.push({
    key: ATTR_SERVICE_NAME,
    value: {
      stringValue: options4.serviceName
    }
  });
  if (options4.serviceVersion) {
    resourceAttributes.push({
      key: ATTR_SERVICE_VERSION,
      value: {
        stringValue: options4.serviceVersion
      }
    });
  }
  return {
    attributes: resourceAttributes,
    droppedAttributesCount: 0
  };
}, "make");
var fromConfig = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const attributes = yield* string4("OTEL_RESOURCE_ATTRIBUTES").pipe(map22((s) => {
    const attrs = s.split(",");
    return reduce(attrs, {}, (acc, attr) => {
      const parts2 = attr.split("=");
      if (parts2.length !== 2) {
        return acc;
      }
      acc[parts2[0].trim()] = parts2[1].trim();
      return acc;
    });
  }), withDefault2({}), map20((envAttrs) => ({
    ...envAttrs,
    ...options4?.attributes
  })));
  const serviceName = options4?.serviceName ?? attributes[ATTR_SERVICE_NAME] ?? (yield* string4("OTEL_SERVICE_NAME"));
  const serviceVersion = options4?.serviceVersion ?? attributes[ATTR_SERVICE_VERSION] ?? (yield* string4("OTEL_SERVICE_VERSION").pipe(withDefault2(void 0)));
  return make87({
    serviceName,
    serviceVersion,
    attributes
  });
}, orDie3);
var unsafeServiceName = /* @__PURE__ */ __name((resource) => {
  const serviceNameAttribute = resource.attributes.find((attr) => attr.key === ATTR_SERVICE_NAME);
  if (!serviceNameAttribute || !serviceNameAttribute.value.stringValue) {
    throw new Error("Resource does not contain a service name");
  }
  return serviceNameAttribute.value.stringValue;
}, "unsafeServiceName");
var entriesToAttributes = /* @__PURE__ */ __name((entries3) => {
  const attributes = [];
  for (const [key, value6] of entries3) {
    attributes.push({
      key,
      value: unknownToAttributeValue(value6)
    });
  }
  return attributes;
}, "entriesToAttributes");
var unknownToAttributeValue = /* @__PURE__ */ __name((value6) => {
  if (Array.isArray(value6)) {
    return {
      arrayValue: {
        values: value6.map(unknownToAttributeValue)
      }
    };
  }
  switch (typeof value6) {
    case "string":
      return {
        stringValue: value6
      };
    case "bigint":
      return {
        intValue: Number(value6)
      };
    case "number":
      return Number.isInteger(value6) ? {
        intValue: value6
      } : {
        doubleValue: value6
      };
    case "boolean":
      return {
        boolValue: value6
      };
    default:
      return {
        stringValue: toStringUnknown(value6)
      };
  }
}, "unknownToAttributeValue");

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/OtlpLogger.js
var make88 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const otelResource = yield* fromConfig(options4.resource);
  const scope5 = {
    name: unsafeServiceName(otelResource)
  };
  const exporter = yield* make86({
    label: "OtlpLogger",
    url: options4.url,
    headers: options4.headers,
    maxBatchSize: options4.maxBatchSize ?? 1e3,
    exportInterval: options4.exportInterval ?? seconds(1),
    body: (data) => ({
      resourceLogs: [{
        resource: otelResource,
        scopeLogs: [{
          scope: scope5,
          logRecords: data
        }]
      }]
    }),
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
  const opts = {
    excludeLogSpans: options4.excludeLogSpans ?? false
  };
  return make66((options5) => {
    exporter.push(makeLogRecord(options5, opts));
  });
});
var layer6 = /* @__PURE__ */ __name((options4) => options4.replaceLogger ? replaceScoped(options4.replaceLogger, make88(options4)) : addScoped(make88(options4)), "layer");
var makeLogRecord = /* @__PURE__ */ __name((options4, opts) => {
  const now2 = options4.date.getTime();
  const nanosString = `${now2}000000`;
  const attributes = entriesToAttributes(options4.annotations);
  attributes.push({
    key: "fiberId",
    value: {
      stringValue: threadName2(options4.fiberId)
    }
  });
  if (!opts.excludeLogSpans) {
    for (const span4 of options4.spans) {
      attributes.push({
        key: `logSpan.${span4.label}`,
        value: {
          stringValue: `${now2 - span4.startTime}ms`
        }
      });
    }
  }
  if (!isEmpty6(options4.cause)) {
    attributes.push({
      key: "log.error",
      value: {
        stringValue: pretty3(options4.cause, {
          renderErrorCause: true
        })
      }
    });
  }
  const message = ensure(options4.message);
  const maybeSpan = getOption2(getOrDefault2(options4.context, currentContext2), ParentSpan);
  const logRecord = {
    severityNumber: logLevelToSeverityNumber(options4.logLevel),
    severityText: options4.logLevel.label,
    timeUnixNano: nanosString,
    observedTimeUnixNano: nanosString,
    attributes,
    body: unknownToAttributeValue(message.length === 1 ? message[0] : message),
    droppedAttributesCount: 0
  };
  if (isSome2(maybeSpan)) {
    logRecord.traceId = maybeSpan.value.traceId;
    logRecord.spanId = maybeSpan.value.spanId;
  }
  return logRecord;
}, "makeLogRecord");
var logLevelToSeverityNumber = /* @__PURE__ */ __name((logLevel2) => {
  switch (logLevel2._tag) {
    case "Trace":
      return ESeverityNumber.SEVERITY_NUMBER_TRACE;
    case "Debug":
      return ESeverityNumber.SEVERITY_NUMBER_DEBUG;
    case "Info":
      return ESeverityNumber.SEVERITY_NUMBER_INFO;
    case "Warning":
      return ESeverityNumber.SEVERITY_NUMBER_WARN;
    case "Error":
      return ESeverityNumber.SEVERITY_NUMBER_ERROR;
    case "Fatal":
      return ESeverityNumber.SEVERITY_NUMBER_FATAL;
    default:
      return ESeverityNumber.SEVERITY_NUMBER_UNSPECIFIED;
  }
}, "logLevelToSeverityNumber");
var ESeverityNumber;
(function(ESeverityNumber2) {
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_UNSPECIFIED"] = 0] = "SEVERITY_NUMBER_UNSPECIFIED";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE"] = 1] = "SEVERITY_NUMBER_TRACE";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE2"] = 2] = "SEVERITY_NUMBER_TRACE2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE3"] = 3] = "SEVERITY_NUMBER_TRACE3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE4"] = 4] = "SEVERITY_NUMBER_TRACE4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG"] = 5] = "SEVERITY_NUMBER_DEBUG";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG2"] = 6] = "SEVERITY_NUMBER_DEBUG2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG3"] = 7] = "SEVERITY_NUMBER_DEBUG3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG4"] = 8] = "SEVERITY_NUMBER_DEBUG4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO"] = 9] = "SEVERITY_NUMBER_INFO";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO2"] = 10] = "SEVERITY_NUMBER_INFO2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO3"] = 11] = "SEVERITY_NUMBER_INFO3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO4"] = 12] = "SEVERITY_NUMBER_INFO4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN"] = 13] = "SEVERITY_NUMBER_WARN";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN2"] = 14] = "SEVERITY_NUMBER_WARN2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN3"] = 15] = "SEVERITY_NUMBER_WARN3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN4"] = 16] = "SEVERITY_NUMBER_WARN4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR"] = 17] = "SEVERITY_NUMBER_ERROR";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR2"] = 18] = "SEVERITY_NUMBER_ERROR2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR3"] = 19] = "SEVERITY_NUMBER_ERROR3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR4"] = 20] = "SEVERITY_NUMBER_ERROR4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL"] = 21] = "SEVERITY_NUMBER_FATAL";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL2"] = 22] = "SEVERITY_NUMBER_FATAL2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL3"] = 23] = "SEVERITY_NUMBER_FATAL3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL4"] = 24] = "SEVERITY_NUMBER_FATAL4";
})(ESeverityNumber || (ESeverityNumber = {}));

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/OtlpMetrics.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var make89 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const clock3 = yield* clock2;
  const startTime = String(clock3.unsafeCurrentTimeNanos());
  const resource = yield* fromConfig(options4.resource);
  const metricsScope = {
    name: unsafeServiceName(resource)
  };
  const snapshot2 = /* @__PURE__ */ __name(() => {
    const snapshot3 = unsafeSnapshot2();
    const nowNanos = clock3.unsafeCurrentTimeNanos();
    const nowTime = String(nowNanos);
    const metricData = [];
    const metricDataByName = /* @__PURE__ */ new Map();
    const addMetricData = /* @__PURE__ */ __name((data) => {
      metricData.push(data);
      metricDataByName.set(data.name, data);
    }, "addMetricData");
    for (let i = 0, len = snapshot3.length; i < len; i++) {
      const {
        metricKey,
        metricState
      } = snapshot3[i];
      let unit = "1";
      const attributes = reduce(metricKey.tags, [], (acc, label) => {
        if (label.key === "unit" || label.key === "time_unit") {
          unit = label.value;
        }
        acc.push({
          key: label.key,
          value: {
            stringValue: label.value
          }
        });
        return acc;
      });
      if (isCounterState2(metricState)) {
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime
        };
        if (typeof metricState.count === "bigint") {
          dataPoint.asInt = Number(metricState.count);
        } else {
          dataPoint.asDouble = metricState.count;
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).sum.dataPoints.push(dataPoint);
        } else {
          const key = metricKey;
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(key.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: key.keyType.incremental,
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isGaugeState2(metricState)) {
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime
        };
        if (typeof metricState.value === "bigint") {
          dataPoint.asInt = Number(metricState.value);
        } else {
          dataPoint.asDouble = metricState.value;
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).gauge.dataPoints.push(dataPoint);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            gauge: {
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isHistogramState2(metricState)) {
        const size18 = metricState.buckets.length;
        const buckets = {
          boundaries: allocate(size18 - 1),
          counts: allocate(size18)
        };
        let i2 = 0;
        let prev = 0;
        for (const [boundary, value6] of metricState.buckets) {
          if (i2 < size18 - 1) {
            buckets.boundaries[i2] = boundary;
          }
          buckets.counts[i2] = value6 - prev;
          prev = value6;
          i2++;
        }
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          count: metricState.count,
          min: metricState.min,
          max: metricState.max,
          sum: metricState.sum,
          bucketCounts: buckets.counts,
          explicitBounds: buckets.boundaries
        };
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).histogram.dataPoints.push(dataPoint);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            histogram: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isFrequencyState2(metricState)) {
        const dataPoints = [];
        for (const [freqKey, value6] of metricState.occurrences) {
          dataPoints.push({
            attributes: [...attributes, {
              key: "key",
              value: {
                stringValue: freqKey
              }
            }],
            startTimeUnixNano: startTime,
            timeUnixNano: nowTime,
            asInt: value6
          });
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).sum.dataPoints.push(...dataPoints);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints
            }
          });
        }
      } else if (isSummaryState2(metricState)) {
        const dataPoints = [{
          attributes: [...attributes, {
            key: "quantile",
            value: {
              stringValue: "min"
            }
          }],
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.min
        }];
        for (const [quantile, value6] of metricState.quantiles) {
          dataPoints.push({
            attributes: [...attributes, {
              key: "quantile",
              value: {
                stringValue: quantile.toString()
              }
            }],
            startTimeUnixNano: startTime,
            timeUnixNano: nowTime,
            asDouble: value6._tag === "Some" ? value6.value : 0
          });
        }
        dataPoints.push({
          attributes: [...attributes, {
            key: "quantile",
            value: {
              stringValue: "max"
            }
          }],
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.max
        });
        const countDataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asInt: metricState.count
        };
        const sumDataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.sum
        };
        if (metricDataByName.has(`${metricKey.name}_quantiles`)) {
          metricDataByName.get(`${metricKey.name}_quantiles`).sum.dataPoints.push(...dataPoints);
          metricDataByName.get(`${metricKey.name}_count`).sum.dataPoints.push(countDataPoint);
          metricDataByName.get(`${metricKey.name}_sum`).sum.dataPoints.push(sumDataPoint);
        } else {
          addMetricData({
            name: `${metricKey.name}_quantiles`,
            description: getOrEmpty(metricKey.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: false,
              dataPoints
            }
          });
          addMetricData({
            name: `${metricKey.name}_count`,
            description: getOrEmpty(metricKey.description),
            unit: "1",
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints: [countDataPoint]
            }
          });
          addMetricData({
            name: `${metricKey.name}_sum`,
            description: getOrEmpty(metricKey.description),
            unit: "1",
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints: [sumDataPoint]
            }
          });
        }
      }
    }
    return {
      resourceMetrics: [{
        resource,
        scopeMetrics: [{
          scope: metricsScope,
          metrics: metricData
        }]
      }]
    };
  }, "snapshot");
  yield* make86({
    label: "OtlpMetrics",
    url: options4.url,
    headers: options4.headers,
    maxBatchSize: "disabled",
    exportInterval: options4.exportInterval ?? seconds(10),
    body: snapshot2,
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
});
var layer7 = /* @__PURE__ */ __name((options4) => scopedDiscard2(make89(options4)), "layer");
var getOrEmpty = /* @__PURE__ */ getOrElse(() => "");
var EAggregationTemporality;
(function(EAggregationTemporality2) {
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED";
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_DELTA"] = 1] = "AGGREGATION_TEMPORALITY_DELTA";
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2] = "AGGREGATION_TEMPORALITY_CUMULATIVE";
})(EAggregationTemporality || (EAggregationTemporality = {}));

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/OtlpTracer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var ATTR_EXCEPTION_TYPE = "exception.type";
var ATTR_EXCEPTION_MESSAGE = "exception.message";
var ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
var make90 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const otelResource = yield* fromConfig(options4.resource);
  const scope5 = {
    name: unsafeServiceName(otelResource)
  };
  const exporter = yield* make86({
    label: "OtlpTracer",
    url: options4.url,
    headers: options4.headers,
    exportInterval: options4.exportInterval ?? seconds(5),
    maxBatchSize: options4.maxBatchSize ?? 1e3,
    body(spans) {
      const data = {
        resourceSpans: [{
          resource: otelResource,
          scopeSpans: [{
            scope: scope5,
            spans
          }]
        }]
      };
      return data;
    },
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
  const exportFn = /* @__PURE__ */ __name((span4) => {
    exporter.push(makeOtlpSpan(span4));
  }, "exportFn");
  return make28({
    span(name, parent, context11, links, startTime, kind) {
      return makeSpan3({
        name,
        parent,
        context: context11,
        status: {
          _tag: "Started",
          startTime
        },
        attributes: /* @__PURE__ */ new Map(),
        links,
        sampled: true,
        kind,
        export: exportFn
      });
    },
    context: options4.context ? function(f, fiber) {
      if (fiber.currentSpan === void 0) {
        return f();
      }
      return options4.context(f, fiber.currentSpan);
    } : defaultContext
  });
});
var layer8 = /* @__PURE__ */ __name((options4) => unwrapScoped2(map20(make90(options4), setTracer2)), "layer");
function defaultContext(f, _) {
  return f();
}
__name(defaultContext, "defaultContext");
var SpanProto = {
  _tag: "Span",
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      startTime: this.status.startTime,
      endTime,
      exit: exit4
    };
    this.export(this);
  },
  attribute(key, value6) {
    this.attributes.set(key, value6);
  },
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes]);
  },
  addLinks(links) {
    this.links.push(...links);
  }
};
var makeSpan3 = /* @__PURE__ */ __name((options4) => {
  const self2 = Object.assign(Object.create(SpanProto), options4);
  if (isSome2(self2.parent)) {
    self2.traceId = self2.parent.value.traceId;
  } else {
    self2.traceId = generateId(32);
  }
  self2.spanId = generateId(16);
  self2.events = [];
  return self2;
}, "makeSpan");
var generateId = /* @__PURE__ */ __name((len) => {
  const chars = "0123456789abcdef";
  let result = "";
  for (let i = 0; i < len; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}, "generateId");
var makeOtlpSpan = /* @__PURE__ */ __name((self2) => {
  const status3 = self2.status;
  const attributes = entriesToAttributes(self2.attributes.entries());
  const events = self2.events.map(([name, startTime, attributes2]) => ({
    name,
    timeUnixNano: String(startTime),
    attributes: attributes2 ? entriesToAttributes(Object.entries(attributes2)) : [],
    droppedAttributesCount: 0
  }));
  let otelStatus;
  if (status3.exit._tag === "Success") {
    otelStatus = constOtelStatusSuccess;
  } else if (isInterruptedOnly2(status3.exit.cause)) {
    otelStatus = {
      code: StatusCode.Ok,
      message: pretty3(status3.exit.cause)
    };
  } else {
    const errors3 = prettyErrors2(status3.exit.cause);
    const firstError = errors3[0];
    otelStatus = {
      code: StatusCode.Error
    };
    attributes.push({
      key: "span.label",
      value: {
        stringValue: "\u26A0\uFE0E Interrupted"
      }
    }, {
      key: "status.interrupted",
      value: {
        boolValue: true
      }
    });
    if (firstError) {
      otelStatus.message = firstError.message;
      events.push({
        name: "exception",
        timeUnixNano: String(status3.endTime),
        droppedAttributesCount: 0,
        attributes: [{
          "key": ATTR_EXCEPTION_TYPE,
          "value": {
            "stringValue": firstError.name
          }
        }, {
          "key": ATTR_EXCEPTION_MESSAGE,
          "value": {
            "stringValue": firstError.message
          }
        }, {
          "key": ATTR_EXCEPTION_STACKTRACE,
          "value": {
            "stringValue": pretty3(status3.exit.cause, {
              renderErrorCause: true
            })
          }
        }]
      });
    }
  }
  return {
    traceId: self2.traceId,
    spanId: self2.spanId,
    parentSpanId: isSome2(self2.parent) ? self2.parent.value.spanId : void 0,
    name: self2.name,
    kind: SpanKind[self2.kind],
    startTimeUnixNano: String(status3.startTime),
    endTimeUnixNano: String(status3.endTime),
    attributes,
    droppedAttributesCount: 0,
    events,
    droppedEventsCount: 0,
    status: otelStatus,
    links: self2.links.map((link) => ({
      traceId: link.span.traceId,
      spanId: link.span.spanId,
      attributes: entriesToAttributes(Object.entries(link.attributes)),
      droppedAttributesCount: 0
    })),
    droppedLinksCount: 0
  };
}, "makeOtlpSpan");
var StatusCode;
(function(StatusCode2) {
  StatusCode2[StatusCode2["Unset"] = 0] = "Unset";
  StatusCode2[StatusCode2["Ok"] = 1] = "Ok";
  StatusCode2[StatusCode2["Error"] = 2] = "Error";
})(StatusCode || (StatusCode = {}));
var SpanKind;
(function(SpanKind3) {
  SpanKind3[SpanKind3["unspecified"] = 0] = "unspecified";
  SpanKind3[SpanKind3["internal"] = 1] = "internal";
  SpanKind3[SpanKind3["server"] = 2] = "server";
  SpanKind3[SpanKind3["client"] = 3] = "client";
  SpanKind3[SpanKind3["producer"] = 4] = "producer";
  SpanKind3[SpanKind3["consumer"] = 5] = "consumer";
})(SpanKind || (SpanKind = {}));
var constOtelStatusSuccess = {
  code: StatusCode.Ok
};

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/Otlp.js
var layer9 = /* @__PURE__ */ __name((options4) => {
  const baseReq = get21(options4.baseUrl);
  const url2 = /* @__PURE__ */ __name((path) => appendUrl2(baseReq, path).url, "url");
  return mergeAll5(layer6({
    replaceLogger: options4.replaceLogger,
    url: url2("/v1/logs"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.loggerExportInterval,
    maxBatchSize: options4.maxBatchSize,
    shutdownTimeout: options4.shutdownTimeout,
    excludeLogSpans: options4.loggerExcludeLogSpans
  }), layer7({
    url: url2("/v1/metrics"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.metricsExportInterval,
    shutdownTimeout: options4.shutdownTimeout
  }), layer8({
    url: url2("/v1/traces"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.tracerExportInterval,
    maxBatchSize: options4.maxBatchSize,
    context: options4.tracerContext,
    shutdownTimeout: options4.shutdownTimeout
  }));
}, "layer");

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/FetchHttpClient.js
var FetchHttpClient_exports = {};
__export(FetchHttpClient_exports, {
  Fetch: () => Fetch,
  RequestInit: () => RequestInit,
  layer: () => layer11
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/fetchHttpClient.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var fetchTagKey = "@effect/platform/FetchHttpClient/Fetch";
var requestInitTagKey = "@effect/platform/FetchHttpClient/FetchOptions";
var fetch = /* @__PURE__ */ make73((request2, url2, signal, fiber) => {
  const context11 = fiber.getFiberRef(currentContext2);
  const fetch2 = context11.unsafeMap.get(fetchTagKey) ?? globalThis.fetch;
  const options4 = context11.unsafeMap.get(requestInitTagKey) ?? {};
  const headers = options4.headers ? merge11(fromInput3(options4.headers), request2.headers) : request2.headers;
  const send = /* @__PURE__ */ __name((body) => map20(tryPromise2({
    try: () => fetch2(url2, {
      ...options4,
      method: request2.method,
      headers,
      body,
      duplex: request2.body._tag === "Stream" ? "half" : void 0,
      signal
    }),
    catch: (cause3) => new RequestError({
      request: request2,
      reason: "Transport",
      cause: cause3
    })
  }), (response) => fromWeb(request2, response)), "send");
  switch (request2.body._tag) {
    case "Raw":
    case "Uint8Array":
      return send(request2.body.body);
    case "FormData":
      return send(request2.body.formData);
    case "Stream":
      return flatMap14(toReadableStreamEffect2(request2.body.stream), send);
  }
  return send(void 0);
});
var layer10 = /* @__PURE__ */ layerMergedContext(/* @__PURE__ */ succeed10(fetch));

// node_modules/.pnpm/@effect+platform@0.91.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/FetchHttpClient.js
var Fetch = class extends (/* @__PURE__ */ Tag2(fetchTagKey)()) {
};
__name(Fetch, "Fetch");
var RequestInit = class extends (/* @__PURE__ */ Tag2(requestInitTagKey)()) {
};
__name(RequestInit, "RequestInit");
var layer11 = layer10;

// node_modules/.pnpm/@effect+rpc@0.70.2_@effect+platform@0.91.1_effect@3.18.4__effect@3.18.4/node_modules/@effect/rpc/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Effect.js
var Effect_exports2 = {};
__export(Effect_exports2, {
  Do: () => Do3,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireReleaseLog: () => acquireReleaseLog,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  addFinalizerLog: () => addFinalizerLog,
  all: () => all7,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen6,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap2,
  as: () => as7,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid5,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind4,
  bindAll: () => bindAll2,
  bindTo: () => bindTo4,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  debugLogEnv: () => debugLogEnv,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die7,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either3,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring2,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventListener: () => eventListener,
  eventually: () => eventually2,
  every: () => every10,
  exists: () => exists4,
  exit: () => exit3,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter11,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap7,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst8,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap14,
  flatten: () => flatten10,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach10,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen3,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreIf: () => ignoreIf,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_4,
  liftPredicate: () => liftPredicate3,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logBefore: () => logBefore,
  logDebug: () => logDebug2,
  logDuration: () => logDuration,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarnIfTakesLongerThan: () => logWarnIfTakesLongerThan,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map20,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth4,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause3,
  mapInputContext: () => mapInputContext2,
  match: () => match14,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect3,
  merge: () => merge7,
  mergeAll: () => mergeAll4,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once3,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse6,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition6,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce12,
  reduceEffect: () => reduceEffect2,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scopeWithCloseable: () => scopeWithCloseable,
  scoped: () => scoped3,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanEvent: () => spanEvent,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed10,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync6,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapCauseLogPretty: () => tapCauseLogPretty,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  tapSync: () => tapSync,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutDie: () => timeoutDie,
  timeoutDieMsg: () => timeoutDieMsg,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  toForkedDeferred: () => toForkedDeferred,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_3,
  tryAll: () => tryAll,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withPerformanceMeasure: () => withPerformanceMeasure,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip8,
  zipLeft: () => zipLeft6,
  zipRight: () => zipRight6,
  zipWith: () => zipWith8
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/Tracer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/internal/tracer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var OtelApi = __toESM(require_src(), 1);

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/internal/utils.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var bigint1e92 = 1000000000n;
var nanosToHrTime = /* @__PURE__ */ __name((timestamp) => {
  return [Number(timestamp / bigint1e92), Number(timestamp % bigint1e92)];
}, "nanosToHrTime");
var recordToAttributes = /* @__PURE__ */ __name((value6) => Object.entries(value6).reduce((acc, [key, value7]) => {
  acc[key] = unknownToAttributeValue2(value7);
  return acc;
}, {}), "recordToAttributes");
var unknownToAttributeValue2 = /* @__PURE__ */ __name((value6) => {
  if (typeof value6 === "string" || typeof value6 === "number" || typeof value6 === "boolean") {
    return value6;
  } else if (typeof value6 === "bigint") {
    return Number(value6);
  }
  return toStringUnknown(value6);
}, "unknownToAttributeValue");

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/internal/tracer.js
var OtelSpanTypeId = /* @__PURE__ */ Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
var kindMap = {
  "internal": OtelApi.SpanKind.INTERNAL,
  "client": OtelApi.SpanKind.CLIENT,
  "server": OtelApi.SpanKind.SERVER,
  "producer": OtelApi.SpanKind.PRODUCER,
  "consumer": OtelApi.SpanKind.CONSUMER
};
var OtelSpan = class {
  name;
  parent;
  context;
  links;
  kind;
  [OtelSpanTypeId];
  _tag = "Span";
  span;
  spanId;
  traceId;
  attributes = /* @__PURE__ */ new Map();
  sampled;
  status;
  constructor(contextApi, tracer4, name, parent, context11, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context11;
    this.links = links;
    this.kind = kind;
    this[OtelSpanTypeId] = OtelSpanTypeId;
    const active2 = contextApi.active();
    this.span = tracer4.startSpan(name, {
      startTime: nanosToHrTime(startTime),
      links: links.length > 0 ? links.map((link) => ({
        context: makeSpanContext(link.span),
        attributes: recordToAttributes(link.attributes)
      })) : void 0,
      kind: kindMap[this.kind]
    }, parent._tag === "Some" ? populateContext(active2, parent.value, context11) : OtelApi.trace.deleteSpan(active2));
    const spanContext = this.span.spanContext();
    this.spanId = spanContext.spanId;
    this.traceId = spanContext.traceId;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED;
  }
  attribute(key, value6) {
    this.span.setAttribute(key, unknownToAttributeValue2(value6));
    this.attributes.set(key, value6);
  }
  addLinks(links) {
    this.links.push(...links);
    this.span.addLinks(links.map((link) => ({
      context: makeSpanContext(link.span),
      attributes: recordToAttributes(link.attributes)
    })));
  }
  end(endTime, exit4) {
    const hrTime = nanosToHrTime(endTime);
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
    if (exit4._tag === "Success") {
      this.span.setStatus({
        code: OtelApi.SpanStatusCode.OK
      });
    } else {
      if (isInterruptedOnly2(exit4.cause)) {
        this.span.setStatus({
          code: OtelApi.SpanStatusCode.OK,
          message: pretty3(exit4.cause)
        });
        this.span.setAttribute("span.label", "\u26A0\uFE0E Interrupted");
        this.span.setAttribute("status.interrupted", true);
      } else {
        const firstError = prettyErrors2(exit4.cause)[0];
        if (firstError) {
          firstError.stack = pretty3(exit4.cause, {
            renderErrorCause: true
          });
          this.span.recordException(firstError, hrTime);
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.ERROR,
            message: firstError.message
          });
        } else {
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.OK
          });
        }
      }
    }
    this.span.end(hrTime);
  }
  event(name, startTime, attributes) {
    this.span.addEvent(name, attributes ? recordToAttributes(attributes) : void 0, nanosToHrTime(startTime));
  }
};
__name(OtelSpan, "OtelSpan");
var traceFlagsTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
var traceStateTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
var currentOtelSpan = /* @__PURE__ */ flatMap14(currentSpan2, (span4) => {
  if (OtelSpanTypeId in span4) {
    return succeed10(span4.span);
  }
  return fail10(new NoSuchElementException2());
});
var populateContext = /* @__PURE__ */ __name((otelContext, span4, context11) => span4 instanceof OtelSpan ? OtelApi.trace.setSpan(otelContext, span4.span) : OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span4, context11)), "populateContext");
var makeSpanContext = /* @__PURE__ */ __name((span4, context11) => ({
  spanId: span4.spanId,
  traceId: span4.traceId,
  isRemote: span4._tag === "ExternalSpan",
  traceFlags: getOrElse(context11 ? extractTraceTag(span4, context11, traceFlagsTag) : getOption2(span4.context, traceFlagsTag), () => OtelApi.TraceFlags.SAMPLED),
  traceState: getOrUndefined(context11 ? extractTraceTag(span4, context11, traceStateTag) : getOption2(span4.context, traceStateTag))
}), "makeSpanContext");
var extractTraceTag = /* @__PURE__ */ __name((parent, context11, tag8) => orElse(getOption2(context11, tag8), () => getOption2(parent.context, tag8)), "extractTraceTag");

// node_modules/.pnpm/@effect+opentelemetry@0.57.0_@effect+platform@0.91.1_effect@3.18.4__@opentelemetry+api@_b8f8291b34b9ccd6cf7ab842dd959180/node_modules/@effect/opentelemetry/dist/esm/Tracer.js
var currentOtelSpan2 = currentOtelSpan;

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/mod.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/misc.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isDevEnv = /* @__PURE__ */ __name(() => {
  if (typeof process !== "undefined" && process.env !== void 0) {
    return true;
  }
  if (import.meta.env !== void 0) {
    return import.meta.env.DEV;
  }
  if (globalThis?.__DEV__) {
    return true;
  }
  return false;
}, "isDevEnv");
var objectToString = /* @__PURE__ */ __name((error3) => {
  const str = error3?.toString();
  if (str !== "[object Object]")
    return str;
  try {
    return JSON.stringify(error3, null, 2);
  } catch (e) {
    console.log(error3);
    return `Error while printing error: ${e}`;
  }
}, "objectToString");
var shouldNeverHappen = /* @__PURE__ */ __name((msg, ...args2) => {
  console.error(msg, ...args2);
  if (isDevEnv()) {
    debugger;
  }
  throw new Error(`This should never happen: ${msg}`);
}, "shouldNeverHappen");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/mod.js
function casesHandled(unexpectedCase) {
  debugger;
  throw new Error(`A case was not handled for value: ${truncate(objectToString(unexpectedCase), 1e3)}`);
}
__name(casesHandled, "casesHandled");
var truncate = /* @__PURE__ */ __name((str, length4) => {
  if (str.length > length4) {
    return `${str.slice(0, length4)}...`;
  } else {
    return str;
  }
}, "truncate");
var notYetImplemented = /* @__PURE__ */ __name((msg) => {
  debugger;
  throw new Error(`Not yet implemented: ${msg}`);
}, "notYetImplemented");
var memoizeByRef = /* @__PURE__ */ __name((fn2) => {
  const cache = /* @__PURE__ */ new Map();
  return (arg) => {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    const result = fn2(arg);
    cache.set(arg, result);
    return result;
  };
}, "memoizeByRef");
var isPromise2 = /* @__PURE__ */ __name((value6) => typeof value6?.then === "function", "isPromise");
var omitUndefineds = /* @__PURE__ */ __name((rec) => {
  return rec;
}, "omitUndefineds");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Error.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var UnknownError = class extends Schema_exports.TaggedError()("UnknownError", {
  cause: Schema_exports.Any,
  payload: Schema_exports.optional(Schema_exports.Any)
}) {
};
__name(UnknownError, "UnknownError");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Effect.js
var scopeWithCloseable = /* @__PURE__ */ __name((fn2) => Effect_exports.gen(function* () {
  const scope5 = yield* Scope_exports.make();
  yield* Effect_exports.addFinalizer((exit4) => Scope_exports.close(scope5, exit4));
  return yield* fn2(scope5).pipe(Scope_exports.extend(scope5));
}), "scopeWithCloseable");
var tryAll = /* @__PURE__ */ __name((fn2) => Effect_exports.try(() => fn2()).pipe(Effect_exports.andThen((fnRes) => Effect_exports.isEffect(fnRes) ? fnRes : isPromise2(fnRes) ? Effect_exports.promise(() => fnRes) : Effect_exports.succeed(fnRes))), "tryAll");
var acquireReleaseLog = /* @__PURE__ */ __name((label) => Effect_exports.acquireRelease(Effect_exports.log(`${label} acquire`), (_, ex) => Effect_exports.log(`${label} release`, ex)), "acquireReleaseLog");
var addFinalizerLog = /* @__PURE__ */ __name((...msgs) => Effect_exports.addFinalizer((exit4) => Effect_exports.log(...msgs, exit4._tag === "Success" ? "with success" : `with failure: ${Cause_exports.pretty(exit4.cause)}`)), "addFinalizerLog");
var logBefore = /* @__PURE__ */ __name((...msgs) => (eff) => Effect_exports.andThen(Effect_exports.log(...msgs), eff), "logBefore");
var tapCauseLogPretty = /* @__PURE__ */ __name((eff) => Effect_exports.tapErrorCause(eff, (cause3) => Effect_exports.gen(function* () {
  if (Cause_exports.isInterruptedOnly(cause3)) {
    return;
  }
  const span4 = yield* currentOtelSpan2.pipe(Effect_exports.catchTag("NoSuchElementException", (_) => Effect_exports.succeed(void 0)));
  const firstErrLine = cause3.toString().split("\n")[0];
  yield* Effect_exports.logError(firstErrLine, cause3).pipe((_) => span4 === void 0 ? _ : Effect_exports.annotateLogs({ spanId: span4.spanContext().spanId, traceId: span4.spanContext().traceId })(_));
})), "tapCauseLogPretty");
var ignoreIf = dual(2, (self2, predicate) => self2.pipe(Effect_exports.catchIf(predicate, () => Effect_exports.void)));
var eventListener = /* @__PURE__ */ __name((target2, type3, handler, options4) => Effect_exports.gen(function* () {
  const runtime6 = yield* Effect_exports.runtime();
  const handlerFn = /* @__PURE__ */ __name((event) => handler(event).pipe(Effect_exports.provide(runtime6), Effect_exports.runFork), "handlerFn");
  target2.addEventListener(type3, handlerFn, { once: options4?.once ?? false });
  yield* Effect_exports.addFinalizer(() => Effect_exports.sync(() => target2.removeEventListener(type3, handlerFn)));
}), "eventListener");
var spanEvent = /* @__PURE__ */ __name((message, attributes) => Effect_exports.locallyWith(Effect_exports.log(message).pipe(Effect_exports.annotateLogs(attributes ?? {})), FiberRef_exports.currentLoggers, () => HashSet_exports.make(Logger_exports.tracerLogger)), "spanEvent");
var logWarnIfTakesLongerThan = /* @__PURE__ */ __name(({ label, duration: duration3 }) => (eff) => Effect_exports.gen(function* () {
  const runtime6 = yield* Effect_exports.runtime();
  let tookLongerThanTimer = false;
  const timeoutFiber = Effect_exports.sleep(duration3).pipe(Effect_exports.tap(() => {
    tookLongerThanTimer = true;
    return Effect_exports.logWarning(`${label}: Took longer than ${duration3}ms`);
  }), Effect_exports.provide(runtime6), Effect_exports.runFork);
  const start3 = Date.now();
  const res = yield* eff.pipe(Effect_exports.exit, Effect_exports.onInterrupt(Effect_exports.fn(function* () {
    const end6 = Date.now();
    yield* Fiber_exports.interrupt(timeoutFiber);
    if (tookLongerThanTimer) {
      yield* Effect_exports.logWarning(`${label}: Interrupted after ${end6 - start3}ms`);
    }
  })));
  if (tookLongerThanTimer) {
    const end6 = Date.now();
    yield* Effect_exports.logWarning(`${label}: Actual duration: ${end6 - start3}ms`);
  }
  yield* Fiber_exports.interrupt(timeoutFiber);
  return yield* res;
}), "logWarnIfTakesLongerThan");
var logDuration = /* @__PURE__ */ __name((label) => (eff) => Effect_exports.gen(function* () {
  const start3 = Date.now();
  const res = yield* eff;
  const end6 = Date.now();
  yield* Effect_exports.log(`${label}: ${Duration_exports.format(end6 - start3)}`);
  return res;
}), "logDuration");
var tapSync = /* @__PURE__ */ __name((tapFn) => (eff) => Effect_exports.tap(eff, (a) => Effect_exports.sync(() => tapFn(a))), "tapSync");
var debugLogEnv = /* @__PURE__ */ __name((msg) => pipe(Effect_exports.context(), Effect_exports.tap((env) => log4(msg ?? "debugLogEnv", env))), "debugLogEnv");
var timeoutDie = /* @__PURE__ */ __name((options4) => (self2) => Effect_exports.orDie(Effect_exports.timeoutFail(options4)(self2)), "timeoutDie");
var timeoutDieMsg = /* @__PURE__ */ __name((options4) => (self2) => Effect_exports.orDie(Effect_exports.timeoutFail({ onTimeout: () => new UnknownError({ cause: options4.error }), duration: options4.duration })(self2)), "timeoutDieMsg");
var toForkedDeferred = /* @__PURE__ */ __name((eff) => pipe(Deferred_exports.make(), Effect_exports.tap((deferred) => pipe(Effect_exports.exit(eff), Effect_exports.flatMap((ex) => Deferred_exports.done(deferred, ex)), tapCauseLogPretty, Effect_exports.forkScoped))), "toForkedDeferred");
var withPerformanceMeasure = /* @__PURE__ */ __name((meaureLabel) => (eff) => Effect_exports.acquireUseRelease(Effect_exports.sync(() => globalThis.performance.mark(`${meaureLabel}:start`)), () => eff, () => Effect_exports.sync(() => {
  globalThis.performance.mark(`${meaureLabel}:end`);
  globalThis.performance.measure(meaureLabel, `${meaureLabel}:start`, `${meaureLabel}:end`);
})), "withPerformanceMeasure");
var getSpanTrace = /* @__PURE__ */ __name(() => {
  const fiberOption = Fiber_exports.getCurrentFiber();
  if (fiberOption._tag === "None" || fiberOption.value.currentSpan === void 0) {
    return "No current fiber";
  }
  return "";
}, "getSpanTrace");
var logSpanTrace = /* @__PURE__ */ __name(() => console.log(getSpanTrace()), "logSpanTrace");
globalThis.getSpanTrace = getSpanTrace;
globalThis.logSpanTrace = logSpanTrace;

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Logger.js
var Logger_exports2 = {};
__export(Logger_exports2, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add7,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  consoleLogger: () => consoleLogger,
  consoleWithThread: () => consoleWithThread,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json2,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make66,
  map: () => map31,
  mapInput: () => mapInput8,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none10,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  prettyWithThread: () => prettyWithThread,
  remove: () => remove10,
  replace: () => replace2,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed22,
  sync: () => sync16,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip14,
  zipLeft: () => zipLeft12,
  zipRight: () => zipRight14
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var defaultDateFormat2 = /* @__PURE__ */ __name((date4) => `${date4.getHours().toString().padStart(2, "0")}:${date4.getMinutes().toString().padStart(2, "0")}:${date4.getSeconds().toString().padStart(2, "0")}.${date4.getMilliseconds().toString().padStart(3, "0")}`, "defaultDateFormat");
var prettyWithThread = /* @__PURE__ */ __name((threadName3, options4 = {}) => Logger_exports.replace(Logger_exports.defaultLogger, Logger_exports.prettyLogger({
  formatDate: (date4) => `${defaultDateFormat2(date4)} ${threadName3}`,
  mode: options4.mode
})), "prettyWithThread");
var consoleLogger = /* @__PURE__ */ __name((threadName3) => Logger_exports.make(({ message, annotations: annotations3, date: date4, logLevel: logLevel2, cause: cause3 }) => {
  const isCloudflareWorker = typeof navigator !== "undefined" && true;
  const consoleFn = logLevel2 === LogLevel_exports.Debug ? (
    // Cloudflare Workers doesn't support console.debug 
    isCloudflareWorker ? console.log : console.debug
  ) : logLevel2 === LogLevel_exports.Info ? console.info : logLevel2 === LogLevel_exports.Warning ? console.warn : console.error;
  const annotationsObj = Object.fromEntries(HashMap_exports.entries(annotations3));
  const messages = Array.isArray(message) ? message : [message];
  if (Cause_exports.isEmpty(cause3) === false) {
    messages.push(Cause_exports.pretty(cause3, { renderErrorCause: true }));
  }
  if (Object.keys(annotationsObj).length > 0) {
    messages.push(annotationsObj);
  }
  consoleFn(`[${defaultDateFormat2(date4)} ${threadName3}]`, ...messages);
}), "consoleLogger");
var consoleWithThread = /* @__PURE__ */ __name((threadName3) => Logger_exports.replace(Logger_exports.defaultLogger, consoleLogger(threadName3)), "consoleWithThread");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Schema/index.js
var Schema_exports2 = {};
__export(Schema_exports2, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  Base64FromUint8Array: () => Base64FromUint8Array,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  JsonValue: () => JsonValue,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map25,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set7,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId19,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose3,
  debugDiff: () => debugDiff,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeSyncDebug: () => decodeSyncDebug,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeSyncDebug: () => encodeSyncDebug,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodeWithTransferables: () => encodeWithTransferables,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend3,
  failureSchema: () => failureSchema,
  filter: () => filter12,
  filterEffect: () => filterEffect,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  getResolvedPropertySignatures: () => getResolvedPropertySignatures,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  hash: () => hash3,
  head: () => head5,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length3,
  lessThan: () => lessThan10,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make47,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit4,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick4,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split2,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend7,
  swap: () => swap3,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Schema/debug-diff.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var debugDiff = /* @__PURE__ */ __name((base) => (a, b) => {
  const bag = [];
  debugDiffImpl(base.ast, a, b, "", bag);
  return bag;
}, "debugDiff");
var debugDiffImpl = /* @__PURE__ */ __name((ast, a, b, path, bag) => {
  const eq = Schema_exports.equivalence({ ast });
  if (eq(a, b) === false) {
    if (SchemaAST_exports.isUnion(ast)) {
      if (isTaggedUnion(ast)) {
        bag.push({ path, a, b, ast });
        return;
      } else {
        for (const type3 of ast.types) {
          try {
            debugDiffImpl(type3, a, b, path, bag);
            return;
          } catch {
          }
        }
      }
    } else if (SchemaAST_exports.isTypeLiteral(ast)) {
      const props = SchemaAST_exports.getPropertySignatures(ast);
      for (const prop of props) {
        debugDiffImpl(prop.type, a[prop.name], b[prop.name], `${path}.${prop.name.toString()}`, bag);
      }
    } else {
      bag.push({ path, a, b, ast });
    }
  }
}, "debugDiffImpl");
var isTaggedUnion = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.every((type3) => {
      if (SchemaAST_exports.isTypeLiteral(type3) === false)
        return false;
      const props = SchemaAST_exports.getPropertySignatures(type3);
      return props.some((prop) => prop.name.toString() === "_tag");
    });
  }
}, "isTaggedUnion");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Schema/index.js
var hash3 = /* @__PURE__ */ __name((schema3) => {
  try {
    return Hash_exports.string(JSON.stringify(schema3.ast, null, 2));
  } catch {
    console.warn(`Schema hashing failed, falling back to hashing the shortend schema AST string. This is less reliable and may cause false positives.`);
    return Hash_exports.hash(schema3.ast.toString());
  }
}, "hash");
var resolveStructAst = /* @__PURE__ */ __name((ast) => {
  if (isTransformation(ast)) {
    return resolveStructAst(ast.from);
  }
  return ast;
}, "resolveStructAst");
var getResolvedPropertySignatures = /* @__PURE__ */ __name((schema3) => {
  const resolvedAst = resolveStructAst(schema3.ast);
  return getPropertySignatures(resolvedAst);
}, "getResolvedPropertySignatures");
var encodeWithTransferables = /* @__PURE__ */ __name((schema3, options4) => (a, overrideOptions) => Effect_exports.gen(function* () {
  const collector = yield* Transferable_exports.makeCollector;
  const encoded = yield* Schema_exports.encode(schema3, options4)(a, overrideOptions).pipe(Effect_exports.provideService(Transferable_exports.Collector, collector));
  return [encoded, collector.unsafeRead()];
}), "encodeWithTransferables");
var decodeSyncDebug = /* @__PURE__ */ __name((schema3, options4) => (input, overrideOptions) => {
  const res = Schema_exports.decodeEither(schema3, options4)(input, overrideOptions);
  if (res._tag === "Left") {
    return shouldNeverHappen(`decodeSyncDebug failed:`, res.left);
  } else {
    return res.right;
  }
}, "decodeSyncDebug");
var encodeSyncDebug = /* @__PURE__ */ __name((schema3, options4) => (input, overrideOptions) => {
  const res = Schema_exports.encodeEither(schema3, options4)(input, overrideOptions);
  if (res._tag === "Left") {
    return shouldNeverHappen(`encodeSyncDebug failed:`, res.left);
  } else {
    return res.right;
  }
}, "encodeSyncDebug");
var swap3 = /* @__PURE__ */ __name((schema3) => Schema_exports.transformOrFail(Schema_exports.typeSchema(schema3), Schema_exports.encodedSchema(schema3), {
  decode: ParseResult_exports.encode(schema3),
  encode: ParseResult_exports.decode(schema3)
}), "swap");
var Base64FromUint8Array = swap3(Schema_exports.Uint8ArrayFromBase64);
var JsonValue = Schema_exports.Union(Schema_exports.String, Schema_exports.Number, Schema_exports.Boolean, Schema_exports.Null, Schema_exports.Array(Schema_exports.suspend(() => JsonValue)), Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.suspend(() => JsonValue) })).annotations({ title: "JsonValue" });

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/effect/Stream.js
var Stream_exports2 = {};
__export(Stream_exports2, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do5,
  StreamTypeId: () => StreamTypeId3,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as13,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind6,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo6,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer3,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  concatWithLastElement: () => concatWithLastElement,
  context: () => context9,
  contextWith: () => contextWith6,
  contextWithEffect: () => contextWithEffect6,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die13,
  dieMessage: () => dieMessage6,
  dieSync: () => dieSync9,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop5,
  dropRight: () => dropRight3,
  dropUntil: () => dropUntil5,
  dropUntilEffect: () => dropUntilEffect3,
  dropWhile: () => dropWhile6,
  dropWhileEffect: () => dropWhileEffect3,
  either: () => either6,
  emitIfEmpty: () => emitIfEmpty,
  empty: () => empty34,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith4,
  execute: () => execute2,
  fail: () => fail20,
  failCause: () => failCause17,
  failCauseSync: () => failCauseSync9,
  failSync: () => failSync10,
  filter: () => filter14,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap9,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect3,
  flatMap: () => flatMap22,
  flatten: () => flatten16,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect9,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub4,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue4,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity4,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_6,
  make: () => make61,
  map: () => map30,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth8,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect6,
  mapError: () => mapError10,
  mapErrorCause: () => mapErrorCause6,
  mapInputContext: () => mapInputContext7,
  merge: () => merge10,
  mergeAll: () => mergeAll8,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never8,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie7,
  orDieWith: () => orDieWith5,
  orElse: () => orElse13,
  orElseEither: () => orElseEither6,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition8,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext7,
  provideLayer: () => provideLayer3,
  provideService: () => provideService7,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext3,
  provideSomeLayer: () => provideSomeLayer4,
  race: () => race5,
  raceAll: () => raceAll4,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  repeat: () => repeat4,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect3,
  runCollectReadonlyArray: () => runCollectReadonlyArray,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFirst: () => runFirst,
  runFirstUnsafe: () => runFirstUnsafe,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped7,
  scopedWith: () => scopedWith5,
  share: () => share2,
  skipRepeated: () => skipRepeated,
  skipRepeated_: () => skipRepeated_,
  sliding: () => sliding8,
  slidingSize: () => slidingSize2,
  some: () => some11,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split4,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed21,
  suspend: () => suspend14,
  sync: () => sync15,
  take: () => take9,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap8,
  tapBoth: () => tapBoth4,
  tapChunk: () => tapChunk,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapLog: () => tapLog,
  tapLogWithLabel: () => tapLogWithLabel,
  tapSink: () => tapSink2,
  tapSync: () => tapSync2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold4,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped6,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService6,
  void: () => void_11,
  when: () => when4,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip13,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft11,
  zipRight: () => zipRight13,
  zipWith: () => zipWith15,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var tapLog = /* @__PURE__ */ __name((stream6) => tapChunk(Effect_exports.forEach((_) => Effect_exports.succeed(console.log(_))))(stream6), "tapLog");
var tapSync2 = /* @__PURE__ */ __name((tapFn) => (stream6) => Stream_exports.tap(stream6, (a) => Effect_exports.sync(() => tapFn(a))), "tapSync");
var tapLogWithLabel = /* @__PURE__ */ __name((label) => (stream6) => tapChunk(Effect_exports.forEach((_) => Effect_exports.succeed(console.log(label, _))))(stream6), "tapLogWithLabel");
var tapChunk = /* @__PURE__ */ __name((f) => (self2) => Stream_exports.mapChunksEffect(self2, (chunks3) => pipe(f(chunks3), Effect_exports.map(() => chunks3))), "tapChunk");
var isIdentity = /* @__PURE__ */ __name((a1, a2) => a1 === a2, "isIdentity");
var skipRepeated = /* @__PURE__ */ __name((isEqual3 = isIdentity) => (stream6) => skipRepeated_(stream6, isEqual3), "skipRepeated");
var skipRepeated_ = /* @__PURE__ */ __name((stream6, isEqual3 = isIdentity) => pipe(Ref_exports.make(Option_exports.none()), Stream_exports.fromEffect, Stream_exports.flatMap((ref) => pipe(stream6, Stream_exports.filterEffect((el) => pipe(Ref_exports.get(ref), Effect_exports.flatMap((prevEl) => {
  if (prevEl._tag === "None" || isEqual3(prevEl.value, el) === false) {
    return pipe(Ref_exports.set(ref, Option_exports.some(el)), Effect_exports.map(() => true));
  } else {
    return Effect_exports.succeed(false);
  }
})))))), "skipRepeated_");
var runFirst = /* @__PURE__ */ __name((stream6) => stream6.pipe(Stream_exports.take(1), Stream_exports.runCollect, Effect_exports.map(Chunk_exports.head)), "runFirst");
var runFirstUnsafe = /* @__PURE__ */ __name((stream6) => runFirst(stream6).pipe(Effect_exports.flatten), "runFirstUnsafe");
var runCollectReadonlyArray = /* @__PURE__ */ __name((stream6) => stream6.pipe(Stream_exports.runCollect, Effect_exports.map(Chunk_exports.toReadonlyArray)), "runCollectReadonlyArray");
var concatWithLastElement = dual(2, (stream1, getStream2) => pipe(Ref_exports.make(Option_exports.none()), Stream_exports.fromEffect, Stream_exports.flatMap((lastRef) => pipe(stream1, Stream_exports.tap((value6) => Ref_exports.set(lastRef, Option_exports.some(value6))), Stream_exports.concat(pipe(Ref_exports.get(lastRef), Effect_exports.map(getStream2), Stream_exports.unwrap))))));
var emitIfEmpty = dual(2, (stream6, fallbackValue) => concatWithLastElement(stream6, (lastElement) => lastElement._tag === "None" ? Stream_exports.make(fallbackValue) : Stream_exports.empty));

// node_modules/.pnpm/@livestore+common-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/common-cf/dist/do-rpc/server.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var toDurableObjectHandler = /* @__PURE__ */ __name((group2, options4) => (serializedPayload) => Effect_exports2.gen(function* () {
  const parser = RpcSerialization_exports.msgPack.unsafeMake();
  const decoded = parser.decode(serializedPayload);
  let requests;
  if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
    requests = decoded[0];
  } else if (Array.isArray(decoded)) {
    requests = decoded;
  } else {
    requests = [];
  }
  const context11 = yield* Effect_exports2.context();
  const responses = [];
  for (const request2 of requests) {
    if (request2._tag !== "Request") {
      continue;
    }
    const rpc = group2.requests.get(request2.tag);
    const entry = context11.unsafeMap.get(rpc.key);
    if (!rpc || !entry) {
      responses.push({
        _tag: "Exit",
        requestId: request2.id,
        exit: Exit_exports.die(`Unknown request tag: ${request2.tag}`)
      });
      continue;
    }
    const isStream3 = RpcSchema_exports.isStreamSchema(rpc.successSchema);
    if (isStream3 && requests.length === 1) {
      return yield* createStreamingResponse(rpc, entry, request2, parser, options4.layer);
    }
    const result = yield* Effect_exports2.gen(function* () {
      const handlerResult = entry.handler(request2.payload, {
        clientId: 0,
        // TODO: add proper clientId if needed
        headers: Headers_exports.fromInput({
          "x-rpc-request-id": request2.id.toString()
        })
      });
      let value6;
      if (Effect_exports2.isEffect(handlerResult)) {
        value6 = yield* handlerResult;
      } else {
        value6 = handlerResult;
      }
      const exitSchema3 = Rpc_exports.exitSchema(rpc);
      let encodedExit;
      if (exitSchema3) {
        const rawExit = Exit_exports.succeed(value6);
        encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
      } else {
        encodedExit = Exit_exports.succeed(value6);
      }
      return {
        _tag: "Exit",
        requestId: request2.id,
        exit: encodedExit
      };
    }).pipe(Effect_exports2.catchAllCause((cause3) => {
      const exitSchema3 = Rpc_exports.exitSchema(rpc);
      return Effect_exports2.gen(function* () {
        let encodedExit;
        if (exitSchema3) {
          const rawExit = Exit_exports.failCause(cause3);
          encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        } else {
          encodedExit = Exit_exports.failCause(cause3);
        }
        return {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
      });
    }));
    responses.push(result);
  }
  const encoded = parser.encode(responses);
  return encoded;
}).pipe(Effect_exports2.provide(options4.layer), Effect_exports2.scoped, Effect_exports2.orDie), "toDurableObjectHandler");
var emitStreamResponse = /* @__PURE__ */ __name(({ callerContext, env, requestId, values: values6 }) => Effect_exports2.gen(function* () {
  const clientDoNamespace = env[callerContext.bindingName];
  if (clientDoNamespace === void 0) {
    throw new Error(`Client DO namespace not found: ${callerContext.bindingName}`);
  }
  const clientDo = clientDoNamespace.get(clientDoNamespace.idFromString(callerContext.durableObjectId));
  const res = { _tag: "Chunk", requestId, values: values6 };
  yield* Effect_exports2.tryPromise(() => clientDo.syncUpdateRpc(res));
}).pipe(Effect_exports2.withSpan("do-rpc/emitStreamResponse")), "emitStreamResponse");
var createStreamingResponse = /* @__PURE__ */ __name((rpc, entry, request2, parser, layer13) => Effect_exports2.gen(function* () {
  const handlerResult = entry.handler(request2.payload, {
    clientId: 0,
    // TODO: add proper clientId if needed
    headers: Headers_exports.fromInput({
      "x-rpc-request-id": request2.id.toString()
    })
  });
  let stream6;
  if (Effect_exports2.isEffect(handlerResult)) {
    stream6 = yield* handlerResult;
  } else {
    stream6 = handlerResult;
  }
  const streamSchemas = RpcSchema_exports.getStreamSchemas(rpc.successSchema.ast);
  const chunkEncoder = Option_exports.isSome(streamSchemas) ? Schema_exports2.encodeUnknown(Schema_exports2.Array(streamSchemas.value.success)) : Schema_exports2.encodeUnknown(Schema_exports2.Array(Schema_exports2.Any));
  const readableStream = new ReadableStream({
    start(controller) {
      const runStream = Effect_exports2.gen(function* () {
        yield* Stream_exports2.runForEachChunk(stream6, (chunk4) => Effect_exports2.gen(function* () {
          const chunkArray = Chunk_exports.toReadonlyArray(chunk4);
          if (chunkArray.length === 0)
            return;
          const encodedValues = yield* chunkEncoder(chunkArray);
          const chunkMessage = {
            _tag: "Chunk",
            requestId: request2.id,
            values: encodedValues
          };
          const serialized = parser.encode([chunkMessage]);
          controller.enqueue(serialized);
        }));
        const rawExit = Exit_exports.void;
        const exitSchema3 = Rpc_exports.exitSchema(rpc);
        const encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        const exitMessage = {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
        const exitSerialized = parser.encode([exitMessage]);
        controller.enqueue(exitSerialized);
        controller.close();
      }).pipe(Effect_exports2.catchAllCause((cause3) => Effect_exports2.gen(function* () {
        const rawExit = Exit_exports.failCause(cause3);
        const exitSchema3 = Rpc_exports.exitSchema(rpc);
        const encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        const exitMessage = {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
        const exitSerialized = parser.encode([exitMessage]);
        controller.enqueue(exitSerialized);
        controller.close();
      })));
      runStream.pipe(Effect_exports2.provide(layer13), Effect_exports2.scoped, Effect_exports2.tapCauseLogPretty, Effect_exports2.runPromise);
    }
  });
  return readableStream;
}), "createStreamingResponse");

// node_modules/.pnpm/@livestore+common-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/common-cf/dist/ws-rpc/ws-rpc-server.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var setupDurableObjectWebSocketRpc = /* @__PURE__ */ __name(({ doSelf, rpcLayer, webSocketMode, onMessage, mainLayer }) => {
  if (webSocketMode === "accept") {
    return notYetImplemented(`WebSocket mode 'accept' is not yet implemented`);
  }
  const serverCtxMap = /* @__PURE__ */ new Map();
  const launchServer = /* @__PURE__ */ __name((ws) => Effect_exports2.gen(function* () {
    if (serverCtxMap.has(ws)) {
      return serverCtxMap.get(ws);
    }
    yield* Effect_exports2.logDebug(`Launching WebSocket Effect RPC server`);
    const scope5 = yield* Scope_exports.make();
    const incomingQueue = yield* Mailbox_exports.make();
    yield* Scope_exports.addFinalizer(scope5, incomingQueue.shutdown);
    const ProtocolLive = layerRpcServerWebsocket({
      ws,
      incomingQueue,
      ...omitUndefineds({ onMessage })
    }).pipe(Layer_exports.provide(RpcSerialization_exports.layerJson));
    const ServerLive = rpcLayer.pipe(Layer_exports.provide(ProtocolLive));
    yield* Layer_exports.launch(ServerLive).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkIn(scope5));
    const runtime6 = yield* Effect_exports2.runtime();
    const ctx = {
      scope: scope5,
      onMessage: (message) => incomingQueue.offer(message).pipe(Effect_exports2.asVoid, Effect_exports2.withSpan("ws-rpc-server/onMessage", { root: true }), Effect_exports2.provide(runtime6), Effect_exports2.runPromise)
    };
    serverCtxMap.set(ws, ctx);
    return ctx;
  }).pipe(
    Effect_exports2.tapCauseLogPretty,
    Logger_exports2.withMinimumLogLevel(LogLevel_exports.Debug),
    // Useful for debugging
    Effect_exports2.provide(Layer_exports.mergeAll(Logger_exports2.consoleWithThread("ws-rpc-server"), mainLayer ?? Layer_exports.empty)),
    Effect_exports2.withSpan("effect-ws-rpc-server"),
    Effect_exports2.runPromise
  ), "launchServer");
  const webSocketMessage = /* @__PURE__ */ __name(async (ws, message) => {
    const { onMessage: onMessage2 } = await launchServer(ws);
    await onMessage2(message);
  }, "webSocketMessage");
  const webSocketClose = /* @__PURE__ */ __name(async (ws, _code, _reason, _wasClean) => {
    const ctx = serverCtxMap.get(ws);
    if (ctx) {
      await Scope_exports.close(ctx.scope, Exit_exports.void).pipe(Effect_exports2.runPromise);
      serverCtxMap.delete(ws);
    }
  }, "webSocketClose");
  doSelf.webSocketMessage = webSocketMessage.bind(doSelf);
  doSelf.webSocketClose = webSocketClose.bind(doSelf);
  return {
    webSocketMessage,
    webSocketClose
  };
}, "setupDurableObjectWebSocketRpc");
var layerRpcServerWebsocket = /* @__PURE__ */ __name((args2) => Layer_exports.scoped(RpcServer_exports.Protocol, makeSocketProtocol2(args2)), "layerRpcServerWebsocket");
var makeSocketProtocol2 = /* @__PURE__ */ __name(({ incomingQueue, ws, onMessage }) => Effect_exports2.gen(function* () {
  const serialization = yield* RpcSerialization_exports.RpcSerialization;
  const disconnects = yield* Mailbox_exports.make();
  const writeRaw = /* @__PURE__ */ __name((msg) => Effect_exports2.succeed(ws.send(msg)), "writeRaw");
  let writeRequest;
  const parser = serialization.unsafeMake();
  const id3 = 0;
  const write3 = /* @__PURE__ */ __name((response) => {
    try {
      const encoded = parser.encode(response);
      if (encoded === void 0) {
        return Effect_exports2.void;
      }
      return Effect_exports2.orDie(writeRaw(encoded));
    } catch (cause3) {
      return Effect_exports2.orDie(writeRaw(parser.encode(RpcMessage_exports.ResponseDefectEncoded(cause3))));
    }
  }, "write");
  const protocol = yield* RpcServer_exports.Protocol.make((writeRequest_) => {
    writeRequest = writeRequest_;
    const startProcessing = Mailbox_exports.toStream(incomingQueue).pipe(Stream_exports2.tap((data) => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0)
          return Effect_exports2.void;
        let i = 0;
        return Effect_exports2.whileLoop({
          while: () => i < decoded.length,
          body: () => {
            const request2 = decoded[i++];
            if (onMessage) {
              onMessage(request2, ws);
            }
            return writeRequest(id3, request2);
          },
          step: constVoid
        });
      } catch (cause3) {
        return Effect_exports2.orDie(writeRaw(parser.encode(RpcMessage_exports.ResponseDefectEncoded(cause3))));
      }
    }), Stream_exports2.runDrain, Effect_exports2.tapCauseLogPretty, Effect_exports2.fork);
    return Effect_exports2.map(startProcessing, () => ({
      disconnects,
      send: (_clientId, response) => Effect_exports2.orDie(write3(response)),
      end(_clientId) {
        return Effect_exports2.void;
      },
      // Always just one client
      clientIds: Effect_exports2.sync(() => /* @__PURE__ */ new Set([id3])),
      initialMessage: Effect_exports2.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    }));
  });
  return protocol;
}), "makeSocketProtocol");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/shared.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/mod.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/http-rpc-schema.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/adapter-types.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/errors.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var _UnexpectedError = class extends Schema_exports2.TaggedError()("LiveStore.UnexpectedError", {
  cause: Schema_exports2.Defect,
  note: Schema_exports2.optional(Schema_exports2.String),
  payload: Schema_exports2.optional(Schema_exports2.Any)
}) {
};
var UnexpectedError = _UnexpectedError;
__name(UnexpectedError, "UnexpectedError");
__publicField(UnexpectedError, "mapToUnexpectedError", (effect4) => effect4.pipe(Effect_exports2.mapError((cause3) => Schema_exports2.is(_UnexpectedError)(cause3) ? cause3 : new _UnexpectedError({ cause: cause3 })), Effect_exports2.catchAllDefect((cause3) => new _UnexpectedError({ cause: cause3 }))));
__publicField(UnexpectedError, "mapToUnexpectedErrorLayer", (layer13) => layer13.pipe(Layer_exports.catchAllCause((cause3) => Cause_exports.isFailType(cause3) && Schema_exports2.is(_UnexpectedError)(cause3.error) ? Layer_exports.fail(cause3.error) : Layer_exports.fail(new _UnexpectedError({ cause: cause3 })))));
__publicField(UnexpectedError, "mapToUnexpectedErrorStream", (stream6) => stream6.pipe(Stream_exports2.mapError((cause3) => Schema_exports2.is(_UnexpectedError)(cause3) ? cause3 : new _UnexpectedError({ cause: cause3 }))));
var MaterializerHashMismatchError = class extends Schema_exports2.TaggedError()("LiveStore.MaterializerHashMismatchError", {
  eventName: Schema_exports2.String,
  note: Schema_exports2.optionalWith(Schema_exports2.String, {
    default: () => "Please make sure your event materializer is a pure function without side effects."
  })
}) {
};
__name(MaterializerHashMismatchError, "MaterializerHashMismatchError");
var IntentionalShutdownCause = class extends Schema_exports2.TaggedError()("LiveStore.IntentionalShutdownCause", {
  reason: Schema_exports2.Literal("devtools-reset", "devtools-import", "adapter-reset", "manual")
}) {
};
__name(IntentionalShutdownCause, "IntentionalShutdownCause");
var StoreInterrupted = class extends Schema_exports2.TaggedError()("LiveStore.StoreInterrupted", {
  reason: Schema_exports2.String
}) {
};
__name(StoreInterrupted, "StoreInterrupted");
var SqliteError = class extends Schema_exports2.TaggedError()("LiveStore.SqliteError", {
  query: Schema_exports2.optional(Schema_exports2.Struct({
    sql: Schema_exports2.String,
    bindValues: Schema_exports2.Union(Schema_exports2.Record({ key: Schema_exports2.String, value: Schema_exports2.Any }), Schema_exports2.Array(Schema_exports2.Any))
  })),
  /** The SQLite result code */
  // code: Schema.optional(Schema.Number),
  // Added string support for Expo SQLite (we should refactor this to have a unified error type)
  code: Schema_exports2.optional(Schema_exports2.Union(Schema_exports2.Number, Schema_exports2.String)),
  /** The original SQLite3 error */
  cause: Schema_exports2.Defect,
  note: Schema_exports2.optional(Schema_exports2.String)
}) {
};
__name(SqliteError, "SqliteError");
var MaterializeError = class extends Schema_exports2.TaggedError()("LiveStore.MaterializeError", {
  cause: Schema_exports2.Union(MaterializerHashMismatchError, SqliteError),
  note: Schema_exports2.optional(Schema_exports2.String)
}) {
};
__name(MaterializeError, "MaterializeError");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/adapter-types.js
var BootStateProgress = Schema_exports2.Struct({
  done: Schema_exports2.Number,
  total: Schema_exports2.Number
});
var BootStatus = Schema_exports2.Union(Schema_exports2.Struct({ stage: Schema_exports2.Literal("loading") }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("migrating"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("rehydrating"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("syncing"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("done") })).annotations({ title: "BootStatus" });
var SessionIdSymbol = Symbol.for("@livestore/session-id");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/util.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SqlValueSchema = Schema_exports2.Union(Schema_exports2.String, Schema_exports2.Number, Schema_exports2.Uint8Array, Schema_exports2.Null);
var PreparedBindValues = Schema_exports2.Union(Schema_exports2.Array(SqlValueSchema), Schema_exports2.Record({ key: Schema_exports2.String, value: SqlValueSchema })).pipe(Schema_exports2.brand("PreparedBindValues"));
var sql = /* @__PURE__ */ __name((template, ...args2) => {
  let str = "";
  for (const [i, arg] of args2.entries()) {
    str += template[i] + String(arg);
  }
  return str + template[template.length - 1];
}, "sql");

// node_modules/.pnpm/@livestore+utils@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/utils/dist/nanoid/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
var nanoid = /* @__PURE__ */ __name((size18 = 21) => {
  let id3 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size18 |= 0));
  while (size18--) {
    id3 += urlAlphabet[bytes[size18] & 63];
  }
  return id3;
}, "nanoid");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/mod.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/EventDef.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var defineFacts = /* @__PURE__ */ __name((record4) => record4, "defineFacts");
var defineEvent = /* @__PURE__ */ __name((args2) => {
  const { name, schema: schema3, ...options4 } = args2;
  const makePartialEvent = /* @__PURE__ */ __name((args3) => {
    const res = Schema_exports2.validateEither(schema3)(args3);
    if (res._tag === "Left") {
      shouldNeverHappen(`Invalid event args for event '${name}':`, res.left.message, "\n");
    }
    return { name, args: args3 };
  }, "makePartialEvent");
  Object.defineProperty(makePartialEvent, "name", { value: name });
  Object.defineProperty(makePartialEvent, "schema", { value: schema3 });
  Object.defineProperty(makePartialEvent, "encoded", {
    value: (args3) => ({ name, args: args3 })
  });
  Object.defineProperty(makePartialEvent, "options", {
    value: {
      clientOnly: options4?.clientOnly ?? false,
      facts: options4?.facts ? (args3, currentFacts) => {
        const res = options4.facts(args3, currentFacts);
        return {
          modify: {
            set: res.modify?.set ? new Set(res.modify.set) : /* @__PURE__ */ new Set(),
            unset: res.modify?.unset ? new Set(res.modify.unset) : /* @__PURE__ */ new Set()
          },
          require: res.require ? new Set(res.require) : /* @__PURE__ */ new Set()
        };
      } : void 0,
      derived: options4?.derived ?? false
    }
  });
  return makePartialEvent;
}, "defineEvent");
var synced = /* @__PURE__ */ __name((args2) => defineEvent({ ...args2, clientOnly: false }), "synced");
var clientOnly = /* @__PURE__ */ __name((args2) => defineEvent({ ...args2, clientOnly: true }), "clientOnly");
var defineMaterializer = /* @__PURE__ */ __name((_eventDef, materializer) => {
  return materializer;
}, "defineMaterializer");
var materializers = /* @__PURE__ */ __name((_eventDefRecord, handlers) => {
  return handlers;
}, "materializers");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/EventSequenceNumber.js
var EventSequenceNumber_exports = {};
__export(EventSequenceNumber_exports, {
  ClientEventSequenceNumber: () => ClientEventSequenceNumber,
  EventSequenceNumber: () => EventSequenceNumber,
  GlobalEventSequenceNumber: () => GlobalEventSequenceNumber,
  ROOT: () => ROOT,
  clientDefault: () => clientDefault,
  compare: () => compare2,
  diff: () => diff8,
  fromGlobal: () => fromGlobal,
  fromString: () => fromString3,
  globalEventSequenceNumber: () => globalEventSequenceNumber,
  isEqual: () => isEqual2,
  isGreaterThan: () => isGreaterThan,
  isGreaterThanOrEqual: () => isGreaterThanOrEqual,
  localEventSequenceNumber: () => localEventSequenceNumber,
  make: () => make92,
  max: () => max7,
  nextPair: () => nextPair,
  rebaseGenerationDefault: () => rebaseGenerationDefault,
  toString: () => toString4
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var localEventSequenceNumber = Brand_exports.nominal();
var ClientEventSequenceNumber = Schema_exports2.fromBrand(localEventSequenceNumber)(Schema_exports2.Int);
var globalEventSequenceNumber = Brand_exports.nominal();
var GlobalEventSequenceNumber = Schema_exports2.fromBrand(globalEventSequenceNumber)(Schema_exports2.Int);
var clientDefault = 0;
var rebaseGenerationDefault = 0;
var EventSequenceNumber = Schema_exports2.Struct({
  global: GlobalEventSequenceNumber,
  /** Only increments for clientOnly events */
  client: ClientEventSequenceNumber,
  // TODO also provide a way to see "confirmation level" of event (e.g. confirmed by leader/sync backend)
  // Client only
  rebaseGeneration: Schema_exports2.Int
}).annotations({
  title: "LiveStore.EventSequenceNumber",
  pretty: () => (seqNum) => toString4(seqNum)
});
var compare2 = /* @__PURE__ */ __name((a, b) => {
  if (a.global !== b.global) {
    return a.global - b.global;
  }
  if (a.client !== b.client) {
    return a.client - b.client;
  }
  return a.rebaseGeneration - b.rebaseGeneration;
}, "compare");
var toString4 = /* @__PURE__ */ __name((seqNum) => {
  const rebaseGenerationStr = seqNum.rebaseGeneration > 0 ? `r${seqNum.rebaseGeneration}` : "";
  return seqNum.client === 0 ? `e${seqNum.global}${rebaseGenerationStr}` : `e${seqNum.global}+${seqNum.client}${rebaseGenerationStr}`;
}, "toString");
var fromString3 = /* @__PURE__ */ __name((str) => {
  if (!str.startsWith("e")) {
    throw new Error('Invalid event sequence number string: must start with "e"');
  }
  const remaining = str.slice(1);
  let rebaseGeneration = rebaseGenerationDefault;
  let withoutRebase = remaining;
  const rebaseMatch = remaining.match(/r(\d+)$/);
  if (rebaseMatch !== null) {
    rebaseGeneration = Number.parseInt(rebaseMatch[1], 10);
    withoutRebase = remaining.slice(0, -rebaseMatch[0].length);
  }
  const parts2 = withoutRebase.split("+");
  if (parts2[0] === "" || !/^\d+$/.test(parts2[0])) {
    throw new Error("Invalid event sequence number string: invalid number format");
  }
  if (parts2.length > 1 && parts2[1] !== void 0 && (parts2[1] === "" || !/^\d+$/.test(parts2[1]))) {
    throw new Error("Invalid event sequence number string: invalid number format");
  }
  const global2 = Number.parseInt(parts2[0], 10);
  const client = parts2.length > 1 && parts2[1] !== void 0 ? Number.parseInt(parts2[1], 10) : 0;
  if (Number.isNaN(global2) || Number.isNaN(client) || Number.isNaN(rebaseGeneration)) {
    throw new TypeError("Invalid event sequence number string: invalid number format");
  }
  return {
    global: global2,
    client,
    rebaseGeneration
  };
}, "fromString");
var fromGlobal = /* @__PURE__ */ __name((seqNum) => ({
  global: seqNum,
  client: clientDefault,
  rebaseGeneration: rebaseGenerationDefault
}), "fromGlobal");
var isEqual2 = /* @__PURE__ */ __name((a, b) => a.global === b.global && a.client === b.client && a.rebaseGeneration === b.rebaseGeneration, "isEqual");
var ROOT = {
  global: 0,
  client: clientDefault,
  rebaseGeneration: rebaseGenerationDefault
};
var isGreaterThan = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client > b.client;
}, "isGreaterThan");
var isGreaterThanOrEqual = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client >= b.client;
}, "isGreaterThanOrEqual");
var max7 = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client > b.client ? a : b;
}, "max");
var diff8 = /* @__PURE__ */ __name((a, b) => {
  return {
    global: a.global - b.global,
    client: a.client - b.client
  };
}, "diff");
var make92 = /* @__PURE__ */ __name((seqNum) => {
  return Schema_exports2.is(EventSequenceNumber)(seqNum) ? seqNum : Schema_exports2.decodeSync(EventSequenceNumber)({
    ...seqNum,
    rebaseGeneration: seqNum.rebaseGeneration ?? rebaseGenerationDefault
  });
}, "make");
var nextPair = /* @__PURE__ */ __name(({ seqNum, isClient, rebaseGeneration }) => {
  if (isClient) {
    return {
      seqNum: {
        global: seqNum.global,
        client: seqNum.client + 1,
        rebaseGeneration: rebaseGeneration ?? seqNum.rebaseGeneration
      },
      parentSeqNum: seqNum
    };
  }
  return {
    seqNum: {
      global: seqNum.global + 1,
      client: clientDefault,
      rebaseGeneration: rebaseGenerationDefault
    },
    // NOTE we always point to `client: 0` for non-clientOnly events
    parentSeqNum: { global: seqNum.global, client: clientDefault, rebaseGeneration: seqNum.rebaseGeneration }
  };
}, "nextPair");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/LiveStoreEvent.js
var LiveStoreEvent_exports = {};
__export(LiveStoreEvent_exports, {
  AnyDecoded: () => AnyDecoded,
  AnyEncoded: () => AnyEncoded,
  AnyEncodedGlobal: () => AnyEncodedGlobal,
  EncodedWithMeta: () => EncodedWithMeta,
  PartialAnyEncoded: () => PartialAnyEncoded,
  encodedFromGlobal: () => encodedFromGlobal,
  isEqualEncoded: () => isEqualEncoded,
  isPartialEventDef: () => isPartialEventDef,
  makeEventDefPartialSchema: () => makeEventDefPartialSchema,
  makeEventDefSchema: () => makeEventDefSchema,
  makeEventDefSchemaMemo: () => makeEventDefSchemaMemo
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var AnyDecoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyDecoded" });
var AnyEncoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyEncoded" });
var AnyEncodedGlobal = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: GlobalEventSequenceNumber,
  parentSeqNum: GlobalEventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyEncodedGlobal" });
var PartialAnyEncoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any
});
var isPartialEventDef = /* @__PURE__ */ __name((event) => "num" in event === false && "parentSeqNum" in event === false, "isPartialEventDef");
var makeEventDefSchema = /* @__PURE__ */ __name((schema3) => Schema_exports2.Union(...[...schema3.eventsDefsMap.values()].map((def) => Schema_exports2.Struct({
  name: Schema_exports2.Literal(def.name),
  args: def.schema,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}))).annotations({ title: "EventDef" }), "makeEventDefSchema");
var makeEventDefPartialSchema = /* @__PURE__ */ __name((schema3) => Schema_exports2.Union(...[...schema3.eventsDefsMap.values()].map((def) => Schema_exports2.Struct({
  name: Schema_exports2.Literal(def.name),
  args: def.schema
}))).annotations({ title: "EventDefPartial" }), "makeEventDefPartialSchema");
var makeEventDefSchemaMemo = memoizeByRef(makeEventDefSchema);
var encodedFromGlobal = /* @__PURE__ */ __name((event) => ({
  ...event,
  seqNum: fromGlobal(event.seqNum),
  parentSeqNum: fromGlobal(event.parentSeqNum)
}), "encodedFromGlobal");
var _EncodedWithMeta = class extends Schema_exports2.Class("LiveStoreEvent.EncodedWithMeta")({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String,
  // TODO get rid of `meta` again by cleaning up the usage implementations
  meta: Schema_exports2.Struct({
    sessionChangeset: Schema_exports2.Union(Schema_exports2.TaggedStruct("sessionChangeset", {
      data: Schema_exports2.Uint8Array,
      debug: Schema_exports2.Any.pipe(Schema_exports2.optional)
    }), Schema_exports2.TaggedStruct("no-op", {}), Schema_exports2.TaggedStruct("unset", {})),
    syncMetadata: Schema_exports2.Option(Schema_exports2.JsonValue),
    /** Used to detect if the materializer is side effecting (during dev) */
    materializerHashLeader: Schema_exports2.Option(Schema_exports2.Number),
    materializerHashSession: Schema_exports2.Option(Schema_exports2.Number)
  }).pipe(Schema_exports2.mutable, Schema_exports2.optional, Schema_exports2.withDefaults({
    constructor: () => ({
      sessionChangeset: { _tag: "unset" },
      syncMetadata: Option_exports.none(),
      materializerHashLeader: Option_exports.none(),
      materializerHashSession: Option_exports.none()
    }),
    decoding: () => ({
      sessionChangeset: { _tag: "unset" },
      syncMetadata: Option_exports.none(),
      materializerHashLeader: Option_exports.none(),
      materializerHashSession: Option_exports.none()
    })
  }))
}) {
  toJSON = () => {
    return {
      seqNum: `${toString4(this.seqNum)} \u2192 ${toString4(this.parentSeqNum)} (${this.clientId}, ${this.sessionId})`,
      name: this.name,
      args: this.args
    };
  };
  /**
   * Example: (global event)
   * For event e2  e1 which should be rebased on event e3  e2
   * the resulting event num will be e4  e3
   *
   * Example: (client event)
   * For event e2+1  e2 which should be rebased on event e3  e2
   * the resulting event num will be e3+1  e3
   *
   * Syntax: e2+2  e2+1
   *          ^ ^    ^ ^
   *          | |    | +- client parent number
   *          | |    +--- global parent number
   *          | +-- client number
   *          +---- global number
   * Client num is ommitted for global events
   */
  rebase = ({ parentSeqNum, isClient, rebaseGeneration }) => new _EncodedWithMeta({
    ...this,
    ...nextPair({ seqNum: parentSeqNum, isClient, rebaseGeneration })
  });
  toGlobal = () => ({
    ...this,
    seqNum: this.seqNum.global,
    parentSeqNum: this.parentSeqNum.global
  });
};
var EncodedWithMeta = _EncodedWithMeta;
__name(EncodedWithMeta, "EncodedWithMeta");
__publicField(EncodedWithMeta, "fromGlobal", (event, meta) => new _EncodedWithMeta({
  ...event,
  seqNum: {
    global: event.seqNum,
    client: clientDefault,
    rebaseGeneration: rebaseGenerationDefault
  },
  parentSeqNum: {
    global: event.parentSeqNum,
    client: clientDefault,
    rebaseGeneration: rebaseGenerationDefault
  },
  meta: {
    sessionChangeset: { _tag: "unset" },
    syncMetadata: meta.syncMetadata,
    materializerHashLeader: meta.materializerHashLeader,
    materializerHashSession: meta.materializerHashSession
  }
}));
var isEqualEncoded = /* @__PURE__ */ __name((a, b) => a.seqNum.global === b.seqNum.global && a.seqNum.client === b.seqNum.client && a.name === b.name && a.clientId === b.clientId && a.sessionId === b.sessionId && JSON.stringify(a.args) === JSON.stringify(b.args), "isEqualEncoded");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/client-document-def.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/mod.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/ast/sqlite.js
var sqlite_exports = {};
__export(sqlite_exports, {
  column: () => column,
  dbSchema: () => dbSchema,
  hash: () => hash4,
  index: () => index,
  structSchemaForTable: () => structSchemaForTable,
  table: () => table2
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/hash.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var hashCode = /* @__PURE__ */ __name((str) => {
  let hash5 = 0;
  let i;
  let chr;
  if (str.length === 0)
    return hash5;
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash5 = (hash5 << 5) - hash5 + chr;
    hash5 = Math.trunc(hash5);
  }
  return hash5;
}, "hashCode");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/ast/sqlite.js
var column = /* @__PURE__ */ __name((props) => ({ _tag: "column", ...props }), "column");
var index = /* @__PURE__ */ __name((columns, name, unique, primaryKey) => ({
  _tag: "index",
  columns,
  ...omitUndefineds({ name, unique, primaryKey })
}), "index");
var table2 = /* @__PURE__ */ __name((name, columns, indexes) => ({
  _tag: "table",
  name,
  columns,
  indexes
}), "table");
var dbSchema = /* @__PURE__ */ __name((tables) => ({ _tag: "dbSchema", tables }), "dbSchema");
var isJsonColumn = /* @__PURE__ */ __name((column4) => {
  if (column4.type._tag !== "text")
    return false;
  const ast = column4.schema.ast;
  return ast._tag === "Transformation" && ast.annotations.schemaId === SchemaAST_exports.ParseJsonSchemaId;
}, "isJsonColumn");
var hash4 = /* @__PURE__ */ __name((obj) => hashCode(JSON.stringify(trimInfoForHasing(obj))), "hash");
var trimInfoForHasing = /* @__PURE__ */ __name((obj) => {
  switch (obj._tag) {
    case "table": {
      return {
        _tag: "table",
        name: obj.name,
        columns: obj.columns.map((column4) => trimInfoForHasing(column4)),
        indexes: obj.indexes.map((index2) => trimInfoForHasing(index2))
      };
    }
    case "column": {
      const baseInfo = {
        _tag: "column",
        name: obj.name,
        type: obj.type._tag,
        primaryKey: obj.primaryKey,
        nullable: obj.nullable,
        autoIncrement: obj.autoIncrement,
        default: obj.default
      };
      if (isJsonColumn(obj) && obj.schema) {
        baseInfo.jsonSchemaHash = Schema_exports2.hash(obj.schema);
      }
      return baseInfo;
    }
    case "index": {
      return {
        _tag: "index",
        columns: obj.columns,
        name: obj.name,
        unique: obj.unique,
        primaryKey: obj.primaryKey
      };
    }
    case "foreignKey": {
      return {
        _tag: "foreignKey",
        references: obj.references,
        key: obj.key,
        columns: obj.columns
      };
    }
    case "dbSchema": {
      return {
        _tag: "dbSchema",
        tables: obj.tables.map(trimInfoForHasing)
      };
    }
    default: {
      throw new Error(`Unreachable: ${obj}`);
    }
  }
}, "trimInfoForHasing");
var structSchemaForTable = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.columns.map((column4) => [column4.name, column4.schema]))), "structSchemaForTable");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/mod.js
var mod_exports2 = {};
__export(mod_exports2, {
  NoDefault: () => NoDefault,
  blob: () => blob,
  boolean: () => boolean4,
  column: () => column2,
  datetime: () => datetime,
  datetimeInteger: () => datetimeInteger,
  defaultSchemaForColumnType: () => defaultSchemaForColumnType,
  insertStructSchemaForTable: () => insertStructSchemaForTable,
  integer: () => integer3,
  isColumnDefinition: () => isColumnDefinition,
  isSqlDefaultValue: () => isSqlDefaultValue,
  json: () => json6,
  makeDbSchema: () => makeDbSchema,
  real: () => real,
  structSchemaForTable: () => structSchemaForTable2,
  table: () => table3,
  text: () => text4
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/field-defs.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var isColumnDefinition = /* @__PURE__ */ __name((value6) => {
  const validColumnTypes = ["text", "integer", "real", "blob"];
  return typeof value6 === "object" && value6 !== null && "columnType" in value6 && validColumnTypes.includes(value6.columnType);
}, "isColumnDefinition");
var NoDefault = Symbol.for("NoDefault");
var isSqlDefaultValue = /* @__PURE__ */ __name((value6) => {
  return typeof value6 === "object" && value6 !== null && "sql" in value6 && typeof value6.sql === "string";
}, "isSqlDefaultValue");
var makeColDef = /* @__PURE__ */ __name((columnType) => (def) => {
  const nullable = def?.nullable ?? false;
  const schemaWithoutNull = def?.schema ?? defaultSchemaForColumnType(columnType);
  const schema3 = nullable === true ? Schema_exports2.NullOr(schemaWithoutNull) : schemaWithoutNull;
  const default_ = def?.default === void 0 || def.default === NoDefault ? Option_exports.none() : Option_exports.some(def.default);
  return {
    columnType,
    schema: schema3,
    default: default_,
    nullable,
    primaryKey: def?.primaryKey ?? false,
    autoIncrement: def?.autoIncrement ?? false
  };
}, "makeColDef");
var column2 = /* @__PURE__ */ __name((columnType) => makeColDef(columnType), "column");
var text4 = makeColDef("text");
var integer3 = makeColDef("integer");
var real = makeColDef("real");
var blob = makeColDef("blob");
var makeSpecializedColDef = /* @__PURE__ */ __name((columnType, opts) => (def) => {
  const nullable = def?.nullable ?? false;
  const schemaWithoutNull = opts._tag === "baseSchemaFn" ? opts.baseSchemaFn(def?.schema) : opts.baseSchema;
  const schema3 = nullable === true ? Schema_exports2.NullOr(schemaWithoutNull) : schemaWithoutNull;
  const default_ = def?.default === void 0 || def.default === NoDefault ? Option_exports.none() : Option_exports.some(def.default);
  return {
    columnType,
    schema: schema3,
    default: default_,
    nullable,
    primaryKey: def?.primaryKey ?? false,
    autoIncrement: def?.autoIncrement ?? false
  };
}, "makeSpecializedColDef");
var json6 = makeSpecializedColDef("text", {
  _tag: "baseSchemaFn",
  baseSchemaFn: (customSchema) => Schema_exports2.parseJson(customSchema ?? Schema_exports2.Any)
});
var datetime = makeSpecializedColDef("text", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.Date
});
var datetimeInteger = makeSpecializedColDef("integer", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.transform(Schema_exports2.Number, Schema_exports2.DateFromSelf, {
    decode: (ms) => new Date(ms),
    encode: (date4) => date4.getTime()
  })
});
var boolean4 = makeSpecializedColDef("integer", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.transform(Schema_exports2.Number, Schema_exports2.Boolean, {
    decode: (_) => _ === 1,
    encode: (_) => _ ? 1 : 0
  })
});
var defaultSchemaForColumnType = /* @__PURE__ */ __name((columnType) => {
  switch (columnType) {
    case "text": {
      return Schema_exports2.String;
    }
    case "integer": {
      return Schema_exports2.Number;
    }
    case "real": {
      return Schema_exports2.Number;
    }
    case "blob": {
      return Schema_exports2.Uint8ArrayFromSelf;
    }
    default: {
      return casesHandled(columnType);
    }
  }
}, "defaultSchemaForColumnType");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/mod.js
var makeDbSchema = /* @__PURE__ */ __name((schema3) => {
  return Array.isArray(schema3) ? Object.fromEntries(schema3.map((_) => [_.name, _])) : schema3;
}, "makeDbSchema");
var table3 = /* @__PURE__ */ __name((name, columns, indexes) => {
  const ast = {
    _tag: "table",
    name,
    columns: columsToAst(columns),
    indexes: indexesToAst(indexes ?? [])
  };
  return { name, columns, ...omitUndefineds({ indexes }), ast };
}, "table");
var structSchemaForTable2 = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.ast.columns.map((column4) => [column4.name, column4.schema]))).annotations({
  title: tableDef.name
}), "structSchemaForTable");
var insertStructSchemaForTable = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.ast.columns.map((column4) => [
  column4.name,
  column4.nullable === true || column4.default._tag === "Some" ? Schema_exports2.optional(column4.schema) : column4.schema
]))).annotations({
  title: tableDef.name
}), "insertStructSchemaForTable");
var columsToAst = /* @__PURE__ */ __name((columns) => {
  return Object.entries(columns).map(([name, column4]) => {
    return {
      _tag: "column",
      name,
      schema: column4.schema,
      default: column4.default,
      nullable: column4.nullable ?? false,
      primaryKey: column4.primaryKey ?? false,
      autoIncrement: column4.autoIncrement ?? false,
      type: { _tag: column4.columnType }
    };
  });
}, "columsToAst");
var indexesToAst = /* @__PURE__ */ __name((indexes) => {
  return indexes.map((_) => ({ _tag: "index", columns: _.columns, name: _.name, unique: _.isUnique ?? false }));
}, "indexesToAst");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/api.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var QueryBuilderAstSymbol = Symbol.for("QueryBuilderAst");
var QueryBuilderResultSymbol = Symbol.for("QueryBuilderResult");
var QueryBuilderTypeId = Symbol.for("QueryBuilder");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/impl.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/astToSql.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var formatWhereClause = /* @__PURE__ */ __name((whereConditions, tableDef, bindValues) => {
  if (whereConditions.length === 0)
    return "";
  const whereClause = whereConditions.map(({ col, op, value: value6 }) => {
    if (value6 === null) {
      if (op !== "=" && op !== "!=") {
        throw new Error(`Unsupported operator for NULL value: ${op}`);
      }
      const opStmt = op === "=" ? "IS" : "IS NOT";
      return `${col} ${opStmt} NULL`;
    }
    const colDef = tableDef.sqliteDef.columns[col];
    if (colDef === void 0) {
      throw new Error(`Column ${col} not found`);
    }
    const isArray2 = op === "IN" || op === "NOT IN";
    if (isArray2) {
      if (!Array.isArray(value6)) {
        return shouldNeverHappen(`Expected array value for ${op} operator but got`, value6);
      }
      if (value6.length === 0) {
        return op === "IN" ? "0=1" : "1=1";
      }
      const encodedValues = value6.map((v) => Schema_exports2.encodeSync(colDef.schema)(v));
      bindValues.push(...encodedValues);
      const placeholders = encodedValues.map(() => "?").join(", ");
      return `${col} ${op} (${placeholders})`;
    } else {
      const encodedValue = Schema_exports2.encodeSync(colDef.schema)(value6);
      bindValues.push(encodedValue);
      return `${col} ${op} ?`;
    }
  }).join(" AND ");
  return `WHERE ${whereClause}`;
}, "formatWhereClause");
var formatReturningClause = /* @__PURE__ */ __name((returning) => {
  if (!returning || returning.length === 0)
    return "";
  return ` RETURNING ${returning.join(", ")}`;
}, "formatReturningClause");
var astToSql = /* @__PURE__ */ __name((ast) => {
  const bindValues = [];
  const usedTables = /* @__PURE__ */ new Set([ast.tableDef.sqliteDef.name]);
  if (ast._tag === "InsertQuery") {
    const columns = Object.keys(ast.values);
    const placeholders = columns.map(() => "?").join(", ");
    const encodedValues = Schema_exports2.encodeSync(ast.tableDef.insertSchema)(ast.values);
    columns.forEach((col) => {
      bindValues.push(encodedValues[col]);
    });
    let insertVerb = "INSERT";
    let conflictClause = "";
    if (ast.onConflict) {
      if (ast.onConflict.action._tag === "replace") {
        insertVerb = "INSERT OR REPLACE";
      } else {
        conflictClause = ` ON CONFLICT (${ast.onConflict.targets.join(", ")}) `;
        if (ast.onConflict.action._tag === "ignore") {
          conflictClause += "DO NOTHING";
        } else {
          const updateValues = ast.onConflict.action.update;
          const updateCols = Object.keys(updateValues);
          if (updateCols.length === 0) {
            throw new Error("No update columns provided for ON CONFLICT DO UPDATE");
          }
          const updates = updateCols.map((col) => {
            const value6 = updateValues[col];
            return value6 === void 0 ? `${col} = excluded.${col}` : `${col} = ?`;
          }).join(", ");
          updateCols.forEach((col) => {
            const value6 = updateValues[col];
            if (value6 !== void 0) {
              const colDef = ast.tableDef.sqliteDef.columns[col];
              if (colDef === void 0) {
                throw new Error(`Column ${col} not found`);
              }
              const encodedValue = Schema_exports2.encodeSync(colDef.schema)(value6);
              bindValues.push(encodedValue);
            }
          });
          conflictClause += `DO UPDATE SET ${updates}`;
        }
      }
    }
    let query2 = `${insertVerb} INTO '${ast.tableDef.sqliteDef.name}' (${columns.join(", ")}) VALUES (${placeholders})`;
    query2 += conflictClause;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "UpdateQuery") {
    const setColumns = Object.keys(ast.values);
    if (setColumns.length === 0) {
      console.warn(`UPDATE query requires at least one column to set (for table ${ast.tableDef.sqliteDef.name}). Running no-op query instead to skip this update query.`);
      return { query: "SELECT 1", bindValues: [], usedTables };
    }
    const encodedValues = Schema_exports2.encodeSync(Schema_exports2.partial(ast.tableDef.rowSchema))(ast.values);
    setColumns.forEach((col) => {
      bindValues.push(encodedValues[col]);
    });
    let query2 = `UPDATE '${ast.tableDef.sqliteDef.name}' SET ${setColumns.map((col) => `${col} = ?`).join(", ")}`;
    const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
    if (whereClause)
      query2 += ` ${whereClause}`;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "DeleteQuery") {
    let query2 = `DELETE FROM '${ast.tableDef.sqliteDef.name}'`;
    const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
    if (whereClause)
      query2 += ` ${whereClause}`;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "CountQuery") {
    const query2 = [
      `SELECT COUNT(*) as count FROM '${ast.tableDef.sqliteDef.name}'`,
      formatWhereClause(ast.where, ast.tableDef, bindValues)
    ].filter((clause) => clause.length > 0).join(" ");
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "RowQuery") {
    const idColDef = ast.tableDef.sqliteDef.columns.id;
    if (idColDef === void 0) {
      throw new Error("Column id not found for ROW query");
    }
    const encodedId = ast.id === SessionIdSymbol ? ast.id : Schema_exports2.encodeSync(idColDef.schema)(ast.id);
    return {
      query: `SELECT * FROM '${ast.tableDef.sqliteDef.name}' WHERE id = ?`,
      bindValues: [encodedId],
      usedTables
    };
  }
  const columnsStmt = ast.select.columns.length === 0 ? "*" : ast.select.columns.join(", ");
  const selectStmt = `SELECT ${columnsStmt}`;
  const fromStmt = `FROM '${ast.tableDef.sqliteDef.name}'`;
  const whereStmt = formatWhereClause(ast.where, ast.tableDef, bindValues);
  const orderByStmt = ast.orderBy.length > 0 ? `ORDER BY ${ast.orderBy.map(({ col, direction }) => `${col} ${direction}`).join(", ")}` : "";
  const limitStmt = ast.limit._tag === "Some" ? `LIMIT ?` : "";
  const offsetStmt = ast.offset._tag === "Some" ? `OFFSET ?` : "";
  if (ast.offset._tag === "Some")
    bindValues.push(ast.offset.value);
  if (ast.limit._tag === "Some")
    bindValues.push(ast.limit.value);
  const query = [selectStmt, fromStmt, whereStmt, orderByStmt, offsetStmt, limitStmt].map((clause) => clause.trim()).filter((clause) => clause.length > 0).join(" ");
  return { query, bindValues, usedTables };
}, "astToSql");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/impl.js
var makeQueryBuilder = /* @__PURE__ */ __name((tableDef, ast = emptyAst(tableDef)) => {
  const api = {
    select() {
      assertSelectQueryBuilderAst(ast);
      const params2 = [...arguments];
      if (params2.length === 1) {
        const [col] = params2;
        return makeQueryBuilder(tableDef, {
          ...ast,
          resultSchemaSingle: ast.resultSchemaSingle.pipe(Schema_exports2.pluck(col)),
          select: { columns: [col] }
        });
      }
      const columns = params2;
      return makeQueryBuilder(tableDef, {
        ...ast,
        resultSchemaSingle: columns.length === 0 ? ast.resultSchemaSingle : ast.resultSchemaSingle.pipe(Schema_exports2.pick(...columns)),
        select: { columns }
      });
    },
    // biome-ignore lint/complexity/useArrowFunction: prefer function over arrow function for this case
    where: function() {
      if (ast._tag === "InsertQuery")
        return invalidQueryBuilder("Cannot use where with insert");
      if (ast._tag === "RowQuery")
        return invalidQueryBuilder("Cannot use where with row");
      if (arguments.length === 1) {
        const params2 = arguments[0];
        const newOps = Object.entries(params2).filter(([, value7]) => value7 !== void 0).map(([col2, value7]) => Predicate_exports.hasProperty(value7, "op") && Predicate_exports.hasProperty(value7, "value") ? { col: col2, op: value7.op, value: value7.value } : { col: col2, op: "=", value: value7 });
        switch (ast._tag) {
          case "CountQuery":
          case "SelectQuery":
          case "UpdateQuery":
          case "DeleteQuery": {
            return makeQueryBuilder(tableDef, {
              ...ast,
              where: [...ast.where, ...newOps]
            });
          }
          default: {
            return casesHandled(ast);
          }
        }
      }
      const [col, opOrValue, valueOrUndefined] = arguments;
      const op = valueOrUndefined === void 0 ? "=" : opOrValue;
      const value6 = valueOrUndefined === void 0 ? opOrValue : valueOrUndefined;
      switch (ast._tag) {
        case "CountQuery":
        case "SelectQuery":
        case "UpdateQuery":
        case "DeleteQuery": {
          return makeQueryBuilder(tableDef, {
            ...ast,
            where: [...ast.where, { col, op, value: value6 }]
          });
        }
        default: {
          return casesHandled(ast);
        }
      }
    },
    orderBy() {
      assertSelectQueryBuilderAst(ast);
      if (arguments.length === 0 || arguments.length > 2)
        return invalidQueryBuilder();
      if (arguments.length === 1) {
        const params2 = arguments[0];
        return makeQueryBuilder(tableDef, {
          ...ast,
          orderBy: [...ast.orderBy, ...params2]
        });
      }
      const [col, direction] = arguments;
      return makeQueryBuilder(tableDef, {
        ...ast,
        orderBy: [...ast.orderBy, { col, direction }]
      });
    },
    limit: (limit) => {
      assertSelectQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, { ...ast, limit: Option_exports.some(limit) });
    },
    offset: (offset) => {
      assertSelectQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, { ...ast, offset: Option_exports.some(offset) });
    },
    count: () => {
      if (isRowQuery(ast) || ast._tag === "InsertQuery" || ast._tag === "UpdateQuery" || ast._tag === "DeleteQuery")
        return invalidQueryBuilder();
      return makeQueryBuilder(tableDef, {
        _tag: "CountQuery",
        tableDef,
        where: ast.where,
        resultSchema: Schema_exports2.Struct({ count: Schema_exports2.Number }).pipe(Schema_exports2.pluck("count"), Schema_exports2.Array, Schema_exports2.headOrElse())
      });
    },
    first: (behaviour) => {
      assertSelectQueryBuilderAst(ast);
      if (ast.limit._tag === "Some")
        return invalidQueryBuilder(`.first() can't be called after .limit()`);
      return makeQueryBuilder(tableDef, {
        ...ast,
        limit: Option_exports.some(1),
        pickFirst: { _tag: "enabled", ...behaviour ?? { behaviour: "undefined" } }
      });
    },
    //
    // getOrCreate() {
    //   if (tableDef.options.isClientDocumentTable === false) {
    //     return invalidQueryBuilder(`getOrCreate() is not allowed when table is not a client document table`)
    //   }
    //
    //   const params = [...arguments]
    //   let id: string | number
    //   // TODO refactor to handle default id
    //   id = params[0] as string | number
    //   if (id === undefined) {
    //     invalidQueryBuilder(`Id missing for row query on non-singleton table ${tableDef.sqliteDef.name}`)
    //   }
    //   // TODO validate all required columns are present and values are matching the schema
    //   const insertValues: Record<string, unknown> = params[1]?.insertValues ?? {}
    //   return makeQueryBuilder(tableDef, {
    //     _tag: 'RowQuery',
    //     id,
    //     tableDef,
    //     insertValues,
    //   }) as any
    // },
    insert: (values6) => {
      const filteredValues = Object.fromEntries(Object.entries(values6).filter(([, value6]) => value6 !== void 0));
      return makeQueryBuilder(tableDef, {
        _tag: "InsertQuery",
        tableDef,
        values: filteredValues,
        onConflict: void 0,
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    },
    onConflict: (targetOrTargets, action, updateValues) => {
      const targets = Array.isArray(targetOrTargets) ? targetOrTargets : [targetOrTargets];
      assertInsertQueryBuilderAst(ast);
      const onConflict = Match_exports.value(action).pipe(Match_exports.when("ignore", () => ({ targets, action: { _tag: "ignore" } })), Match_exports.when("replace", () => ({ targets, action: { _tag: "replace" } })), Match_exports.when("update", () => ({ targets, action: { _tag: "update", update: updateValues } })), Match_exports.exhaustive);
      return makeQueryBuilder(tableDef, {
        ...ast,
        onConflict
      });
    },
    returning: (...columns) => {
      assertWriteQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, {
        ...ast,
        returning: columns,
        resultSchema: tableDef.rowSchema.pipe(Schema_exports2.pick(...columns), Schema_exports2.Array)
      });
    },
    update: (values6) => {
      const filteredValues = Object.fromEntries(Object.entries(values6).filter(([, value6]) => value6 !== void 0));
      const whereClause = ast._tag === "SelectQuery" ? ast.where : [];
      return makeQueryBuilder(tableDef, {
        _tag: "UpdateQuery",
        tableDef,
        values: filteredValues,
        where: whereClause,
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    },
    delete: () => {
      const whereClause = ast._tag === "SelectQuery" ? ast.where : [];
      return makeQueryBuilder(tableDef, {
        _tag: "DeleteQuery",
        tableDef,
        where: whereClause,
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    }
  };
  return {
    [QueryBuilderTypeId]: QueryBuilderTypeId,
    [QueryBuilderAstSymbol]: ast,
    ResultType: "only-for-type-inference",
    asSql: () => astToSql(ast),
    toString: () => {
      try {
        return astToSql(ast).query;
      } catch (cause3) {
        console.debug(`QueryBuilder.toString(): Error converting query builder to string`, cause3, ast);
        return `Error converting query builder to string`;
      }
    },
    ...api
  };
}, "makeQueryBuilder");
var emptyAst = /* @__PURE__ */ __name((tableDef) => ({
  _tag: "SelectQuery",
  columns: [],
  pickFirst: { _tag: "disabled" },
  select: { columns: [] },
  orderBy: [],
  offset: Option_exports.none(),
  limit: Option_exports.none(),
  tableDef,
  where: [],
  resultSchemaSingle: tableDef.rowSchema
}), "emptyAst");
function assertSelectQueryBuilderAst(ast) {
  if (ast._tag !== "SelectQuery") {
    return shouldNeverHappen(`Expected SelectQuery but got ${ast._tag}`);
  }
}
__name(assertSelectQueryBuilderAst, "assertSelectQueryBuilderAst");
function assertInsertQueryBuilderAst(ast) {
  if (ast._tag !== "InsertQuery") {
    return shouldNeverHappen(`Expected InsertQuery but got ${ast._tag}`);
  }
}
__name(assertInsertQueryBuilderAst, "assertInsertQueryBuilderAst");
function assertWriteQueryBuilderAst(ast) {
  if (ast._tag !== "InsertQuery" && ast._tag !== "UpdateQuery" && ast._tag !== "DeleteQuery") {
    return shouldNeverHappen(`Expected WriteQuery but got ${ast._tag}`);
  }
}
__name(assertWriteQueryBuilderAst, "assertWriteQueryBuilderAst");
var isRowQuery = /* @__PURE__ */ __name((ast) => ast._tag === "RowQuery", "isRowQuery");
var invalidQueryBuilder = /* @__PURE__ */ __name((msg) => {
  return shouldNeverHappen(`Invalid query builder${msg ? `: ${msg}` : ""}`);
}, "invalidQueryBuilder");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/table-def.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-def.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-annotations.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var PrimaryKeyId = Symbol.for("livestore/state/sqlite/annotations/primary-key");
var ColumnType = Symbol.for("livestore/state/sqlite/annotations/column-type");
var Default2 = Symbol.for("livestore/state/sqlite/annotations/default");
var AutoIncrement = Symbol.for("livestore/state/sqlite/annotations/auto-increment");
var Unique = Symbol.for("livestore/state/sqlite/annotations/unique");
var withPrimaryKey = /* @__PURE__ */ __name((schema3) => applyAnnotations(schema3, { [PrimaryKeyId]: true }), "withPrimaryKey");
var withColumnType = dual(2, (schema3, type3) => {
  validateSchemaColumnTypeCompatibility(schema3, type3);
  return applyAnnotations(schema3, { [ColumnType]: type3 });
});
var withAutoIncrement = /* @__PURE__ */ __name((schema3) => applyAnnotations(schema3, { [AutoIncrement]: true }), "withAutoIncrement");
var withUnique = /* @__PURE__ */ __name((schema3) => applyAnnotations(schema3, { [Unique]: true }), "withUnique");
var withDefault3 = dual(2, (schema3, value6) => applyAnnotations(schema3, { [Default2]: value6 }));
var validateSchemaColumnTypeCompatibility = /* @__PURE__ */ __name((_schema, _columnType) => {
}, "validateSchemaColumnTypeCompatibility");
var applyAnnotations = /* @__PURE__ */ __name((schema3, overrides) => {
  const identifier2 = SchemaAST_exports.getIdentifierAnnotation(schema3.ast);
  const shouldPreserveIdentifier = Option_exports.isSome(identifier2) && !(SchemaAST_exports.IdentifierAnnotationId in overrides);
  const annotations3 = shouldPreserveIdentifier ? { ...overrides, [SchemaAST_exports.IdentifierAnnotationId]: identifier2.value } : overrides;
  return schema3.annotations(annotations3);
}, "applyAnnotations");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-def.js
var getColumnDefForSchema = /* @__PURE__ */ __name((schema3, propertySignature2, forceNullable = false) => {
  const ast = schema3.ast;
  const getAnnotation2 = /* @__PURE__ */ __name((annotationId) => propertySignature2 ? hasPropertyAnnotation(propertySignature2, annotationId) : SchemaAST_exports.getAnnotation(annotationId)(ast), "getAnnotation");
  const columnType = SchemaAST_exports.getAnnotation(ColumnType)(ast);
  const isNullable2 = forceNullable || hasNull(ast) || hasUndefined(ast);
  const baseColumn = Option_exports.isSome(columnType) ? getColumnForType(columnType.value, isNullable2) : getColumnForSchema(schema3, isNullable2);
  const primaryKey = getAnnotation2(PrimaryKeyId).pipe(Option_exports.getOrElse(() => false));
  const autoIncrement = getAnnotation2(AutoIncrement).pipe(Option_exports.getOrElse(() => false));
  const defaultValue = getAnnotation2(Default2);
  return {
    ...baseColumn,
    ...primaryKey && { primaryKey: true },
    ...autoIncrement && { autoIncrement: true },
    ...Option_exports.isSome(defaultValue) && { default: Option_exports.some(defaultValue.value) }
  };
}, "getColumnDefForSchema");
var hasPropertyAnnotation = /* @__PURE__ */ __name((propertySignature2, annotationId) => {
  if ("annotations" in propertySignature2 && propertySignature2.annotations) {
    const annotation = SchemaAST_exports.getAnnotation(annotationId)(propertySignature2);
    if (Option_exports.isSome(annotation))
      return annotation;
  }
  return SchemaAST_exports.getAnnotation(annotationId)(propertySignature2.type);
}, "hasPropertyAnnotation");
var schemaFieldsToColumns = /* @__PURE__ */ __name((propertySignatures) => {
  const columns = {};
  const uniqueColumns = [];
  for (const prop of propertySignatures) {
    if (typeof prop.name !== "string")
      continue;
    const fieldSchema = Schema_exports2.make(prop.type);
    if (prop.isOptional) {
      const { hasNull: hasNull2, hasUndefined: hasUndefined2 } = checkNullUndefined(fieldSchema.ast);
      if (hasNull2 && hasUndefined2) {
        console.warn(`Field '${prop.name}' has both null and undefined - treating | undefined as | null`);
      }
    }
    const columnDef = getColumnDefForSchema(fieldSchema, prop, prop.isOptional);
    const hasPrimaryKey = hasPropertyAnnotation(prop, PrimaryKeyId).pipe(Option_exports.getOrElse(() => false));
    const hasUnique = hasPropertyAnnotation(prop, Unique).pipe(Option_exports.getOrElse(() => false));
    columns[prop.name] = {
      ...columnDef,
      ...hasPrimaryKey && { primaryKey: true }
    };
    const column4 = columns[prop.name];
    if (column4?.primaryKey && column4.nullable) {
      throw new Error("Primary key columns cannot be nullable");
    }
    if (hasUnique)
      uniqueColumns.push(prop.name);
  }
  return { columns, uniqueColumns };
}, "schemaFieldsToColumns");
var checkNullUndefined = /* @__PURE__ */ __name((ast) => {
  let hasNull2 = false;
  let hasUndefined2 = false;
  const visit = /* @__PURE__ */ __name((type3) => {
    if (SchemaAST_exports.isUndefinedKeyword(type3))
      hasUndefined2 = true;
    else if (SchemaAST_exports.isLiteral(type3) && type3.literal === null)
      hasNull2 = true;
    else if (SchemaAST_exports.isUnion(type3))
      type3.types.forEach(visit);
  }, "visit");
  visit(ast);
  return { hasNull: hasNull2, hasUndefined: hasUndefined2 };
}, "checkNullUndefined");
var hasNull = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isLiteral(ast) && ast.literal === null)
    return true;
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.some((type3) => hasNull(type3));
  }
  return false;
}, "hasNull");
var hasUndefined = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isUndefinedKeyword(ast))
    return true;
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.some((type3) => hasUndefined(type3));
  }
  return false;
}, "hasUndefined");
var getColumnForType = /* @__PURE__ */ __name((columnType, nullable = false) => {
  switch (columnType) {
    case "text":
      return mod_exports2.text({ nullable });
    case "integer":
      return mod_exports2.integer({ nullable });
    case "real":
      return mod_exports2.real({ nullable });
    case "blob":
      return mod_exports2.blob({ nullable });
    default:
      return shouldNeverHappen(`Unsupported column type: ${columnType}`);
  }
}, "getColumnForType");
var getColumnForSchema = /* @__PURE__ */ __name((schema3, nullable = false) => {
  const ast = schema3.ast;
  const coreAst = stripNullable(ast);
  const coreSchema = stripNullable(ast) === ast ? schema3 : Schema_exports2.make(coreAst);
  if (SchemaAST_exports.isBooleanKeyword(coreAst)) {
    return mod_exports2.boolean({ nullable });
  }
  const encodedAst = Schema_exports2.encodedSchema(coreSchema).ast;
  if (SchemaAST_exports.isStringKeyword(encodedAst)) {
    return mod_exports2.text({ schema: coreSchema, nullable });
  }
  if (SchemaAST_exports.isNumberKeyword(encodedAst)) {
    const id3 = SchemaAST_exports.getIdentifierAnnotation(coreAst).pipe(Option_exports.getOrElse(() => ""));
    if (id3 === "Int" || id3 === "DateFromNumber") {
      return mod_exports2.integer({ schema: coreSchema, nullable });
    }
    return mod_exports2.real({ schema: coreSchema, nullable });
  }
  if (SchemaAST_exports.isLiteral(coreAst)) {
    const value6 = coreAst.literal;
    if (typeof value6 === "boolean")
      return mod_exports2.boolean({ nullable });
  }
  if (SchemaAST_exports.isLiteral(encodedAst)) {
    const value6 = encodedAst.literal;
    if (typeof value6 === "string")
      return mod_exports2.text({ schema: coreSchema, nullable });
    if (typeof value6 === "number") {
      const id3 = SchemaAST_exports.getIdentifierAnnotation(coreAst).pipe(Option_exports.getOrElse(() => ""));
      if (id3 === "Int") {
        return mod_exports2.integer({ schema: coreSchema, nullable });
      }
      return mod_exports2.real({ schema: coreSchema, nullable });
    }
  }
  return mod_exports2.json({ schema: coreSchema, nullable });
}, "getColumnForSchema");
var stripNullable = /* @__PURE__ */ __name((ast) => {
  if (!SchemaAST_exports.isUnion(ast))
    return ast;
  const core = ast.types.find((type3) => !(SchemaAST_exports.isLiteral(type3) && type3.literal === null) && !SchemaAST_exports.isUndefinedKeyword(type3));
  return core || ast;
}, "stripNullable");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/table-def.js
var { blob: blob2, boolean: boolean5, column: column3, datetime: datetime2, integer: integer4, isColumnDefinition: isColumnDefinition2, json: json7, real: real2, text: text5 } = mod_exports2;
var TableDefInternalsSymbol = Symbol("TableDefInternals");
function table4(args2) {
  const { ...options4 } = args2;
  let tableName;
  let columns;
  let additionalIndexes = [];
  if ("columns" in args2) {
    tableName = args2.name;
    const columnOrColumns = args2.columns;
    columns = mod_exports2.isColumnDefinition(columnOrColumns) ? { value: columnOrColumns } : columnOrColumns;
    additionalIndexes = [];
  } else if ("schema" in args2) {
    const result = schemaFieldsToColumns(Schema_exports2.getResolvedPropertySignatures(args2.schema));
    columns = result.columns;
    let tempTableName;
    if ("name" in args2) {
      tempTableName = args2.name;
    } else {
      tempTableName = SchemaAST_exports.getTitleAnnotation(args2.schema.ast).pipe(Option_exports.orElse(() => SchemaAST_exports.getIdentifierAnnotation(args2.schema.ast)), Option_exports.getOrElse(() => shouldNeverHappen("When using schema without explicit name, the schema must have a title or identifier annotation")));
    }
    tableName = tempTableName;
    additionalIndexes = (result.uniqueColumns || []).map((columnName) => ({
      name: `idx_${tableName}_${columnName}_unique`,
      columns: [columnName],
      isUnique: true
    }));
  } else {
    return shouldNeverHappen("Either `columns` or `schema` must be provided when calling `table()`");
  }
  const options_ = {
    isClientDocumentTable: false
  };
  const allIndexes = [...options4?.indexes ?? [], ...additionalIndexes];
  const sqliteDef = mod_exports2.table(tableName, columns, allIndexes);
  const rowSchema = mod_exports2.structSchemaForTable(sqliteDef);
  const insertSchema = mod_exports2.insertStructSchemaForTable(sqliteDef);
  const tableDef = {
    sqliteDef,
    options: options_,
    rowSchema,
    insertSchema
  };
  const query = makeQueryBuilder(tableDef);
  for (const key of Object.keys(query)) {
    tableDef[key] = query[key];
  }
  tableDef[QueryBuilderAstSymbol] = query[QueryBuilderAstSymbol];
  tableDef[QueryBuilderTypeId] = query[QueryBuilderTypeId];
  return tableDef;
}
__name(table4, "table");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/client-document-def.js
var clientDocument = /* @__PURE__ */ __name(({ name, schema: valueSchema, ...inputOptions }) => {
  const options4 = {
    partialSet: inputOptions.partialSet ?? true,
    default: {
      id: inputOptions.default.id,
      value: inputOptions.default.value
    }
  };
  const optimisticColumnSchema = createOptimisticEventSchema({
    valueSchema,
    defaultValue: options4.default.value,
    partialSet: false
    // Column always stores full documents
  });
  const columns = {
    id: mod_exports2.text({ primaryKey: true }),
    value: mod_exports2.json({ schema: optimisticColumnSchema })
  };
  const tableDef = table4({ name, columns });
  tableDef.options.isClientDocumentTable = true;
  const { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer } = deriveEventAndMaterializer({
    name,
    valueSchema,
    defaultValue: options4.default.value,
    partialSet: options4.partialSet
  });
  const setEventDef = /* @__PURE__ */ __name((...args2) => {
    const [value6, id3 = options4.default.id] = args2;
    return derivedSetEventDef({ id: id3, value: value6 });
  }, "setEventDef");
  Object.defineProperty(setEventDef, "name", { value: `${name}Set` });
  Object.defineProperty(setEventDef, "schema", {
    value: Schema_exports2.Struct({
      id: Schema_exports2.String,
      value: options4.partialSet ? Schema_exports2.partial(valueSchema) : valueSchema
    }).annotations({ title: `${name}Set:Args` })
  });
  Object.defineProperty(setEventDef, "options", { value: { derived: true, clientOnly: true, facts: void 0 } });
  const clientDocumentTableDefTrait = {
    get: makeGetQueryBuilder(() => clientDocumentTableDef),
    set: setEventDef,
    Value: "only-for-type-inference",
    default: options4.default,
    valueSchema,
    [ClientDocumentTableDefSymbol]: {
      derived: {
        setEventDef: derivedSetEventDef,
        setMaterializer: derivedSetMaterializer
      },
      options: options4
    }
  };
  const clientDocumentTableDef = {
    ...tableDef,
    ...clientDocumentTableDefTrait
  };
  return clientDocumentTableDef;
}, "clientDocument");
var mergeDefaultValues = /* @__PURE__ */ __name((defaultValues, explicitDefaultValues) => {
  if (typeof defaultValues !== "object" || typeof explicitDefaultValues !== "object" || defaultValues === null || explicitDefaultValues === null) {
    return explicitDefaultValues;
  }
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(defaultValues), ...Object.keys(explicitDefaultValues)]);
  return Array.from(allKeys).reduce((acc, key) => {
    acc[key] = explicitDefaultValues[key] ?? defaultValues[key];
    return acc;
  }, {});
}, "mergeDefaultValues");
var createOptimisticEventSchema = /* @__PURE__ */ __name(({ valueSchema, defaultValue, partialSet }) => {
  const targetSchema = partialSet ? Schema_exports2.partial(valueSchema) : valueSchema;
  return Schema_exports2.transform(
    Schema_exports2.Unknown,
    // Accept any historical event structure
    targetSchema,
    // Output current schema
    {
      decode: (eventValue) => {
        try {
          return Schema_exports2.decodeUnknownSync(targetSchema)(eventValue);
        } catch {
          if (typeof eventValue !== "object" || eventValue === null) {
            console.warn(`Client document: Non-object event value, using ${partialSet ? "empty partial" : "defaults"}`);
            return partialSet ? {} : defaultValue;
          }
          if (partialSet) {
            const partialResult = {};
            let hasValidFields = false;
            for (const [key, value6] of Object.entries(eventValue)) {
              if (key in defaultValue) {
                partialResult[key] = value6;
                hasValidFields = true;
              }
            }
            if (hasValidFields) {
              try {
                return Schema_exports2.decodeUnknownSync(targetSchema)(partialResult);
              } catch {
                console.warn("Client document: Partial fields incompatible, returning empty partial");
                return {};
              }
            }
            return {};
          } else {
            const merged = { ...defaultValue };
            for (const [key, value6] of Object.entries(eventValue)) {
              if (key in defaultValue) {
                merged[key] = value6;
              }
            }
            try {
              return Schema_exports2.decodeUnknownSync(valueSchema)(merged);
            } catch {
              console.warn("Client document: Could not preserve event data, using defaults");
              return defaultValue;
            }
          }
        }
      },
      encode: (value6) => value6
      // Pass-through for encoding
    }
  );
}, "createOptimisticEventSchema");
var deriveEventAndMaterializer = /* @__PURE__ */ __name(({ name, valueSchema, defaultValue, partialSet }) => {
  const derivedSetEventDef = defineEvent({
    name: `${name}Set`,
    schema: Schema_exports2.Struct({
      id: Schema_exports2.Union(Schema_exports2.String, Schema_exports2.UniqueSymbolFromSelf(SessionIdSymbol)),
      value: createOptimisticEventSchema({ valueSchema, defaultValue, partialSet })
    }).annotations({ title: `${name}Set:Args` }),
    clientOnly: true,
    derived: true
  });
  const derivedSetMaterializer = defineMaterializer(derivedSetEventDef, ({ id: id3, value: value6 }) => {
    if (id3 === SessionIdSymbol) {
      return shouldNeverHappen(`SessionIdSymbol needs to be replaced before materializing the set event`);
    }
    const schemaProps = Schema_exports2.getResolvedPropertySignatures(valueSchema);
    if (schemaProps.length === 0 || partialSet === false) {
      const valueColJsonSchema = Schema_exports2.parseJson(valueSchema);
      const encodedInsertValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(value6 ?? defaultValue);
      const encodedUpdateValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(value6);
      return {
        sql: `INSERT INTO '${name}' (id, value) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET value = ?`,
        bindValues: [id3, encodedInsertValue, encodedUpdateValue],
        writeTables: /* @__PURE__ */ new Set([name])
      };
    } else {
      const valueColJsonSchema = Schema_exports2.parseJson(Schema_exports2.partial(valueSchema));
      const encodedInsertValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(mergeDefaultValues(defaultValue, value6));
      let jsonSetSql = "value";
      const setBindValues = [];
      const keys6 = Object.keys(value6);
      const partialUpdateSchema = valueSchema.pipe(Schema_exports2.pick(...keys6));
      const encodedPartialUpdate = Schema_exports2.encodeSyncDebug(partialUpdateSchema)(value6);
      for (const key in encodedPartialUpdate) {
        const encodedValueForKey = encodedPartialUpdate[key];
        if (encodedValueForKey === void 0) {
          continue;
        }
        jsonSetSql = `json_set(${jsonSetSql}, ?, json(?))`;
        setBindValues.push(`$.${key}`, JSON.stringify(encodedValueForKey));
      }
      const onConflictClause = setBindValues.length > 0 ? `ON CONFLICT (id) DO UPDATE SET value = ${jsonSetSql}` : "ON CONFLICT (id) DO NOTHING";
      const sqlQuery = `
      INSERT INTO '${name}' (id, value)
      VALUES (?, ?)
      ${onConflictClause}
    `;
      return {
        sql: sqlQuery,
        bindValues: [id3, encodedInsertValue, ...setBindValues],
        writeTables: /* @__PURE__ */ new Set([name])
      };
    }
  });
  return { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer };
}, "deriveEventAndMaterializer");
var tableIsClientDocumentTable = /* @__PURE__ */ __name((tableDef) => tableDef.options.isClientDocumentTable === true, "tableIsClientDocumentTable");
var makeGetQueryBuilder = /* @__PURE__ */ __name((getTableDef) => {
  return (...args2) => {
    const tableDef = getTableDef();
    const [id3 = tableDef[ClientDocumentTableDefSymbol].options.default.id, options4 = {}] = args2;
    const explicitDefaultValues = options4.default ?? tableDef[ClientDocumentTableDefSymbol].options.default.value;
    const ast = {
      _tag: "RowQuery",
      tableDef,
      id: id3,
      explicitDefaultValues
    };
    const query = sql`SELECT * FROM '${tableDef.sqliteDef.name}' WHERE id = ?`;
    return {
      [QueryBuilderTypeId]: QueryBuilderTypeId,
      [QueryBuilderAstSymbol]: ast,
      ResultType: "only-for-type-inference",
      asSql: () => ({ query, bindValues: [id3] }),
      toString: () => query.toString(),
      ...{}
      // Needed for type cast
    };
  };
}, "makeGetQueryBuilder");
var ClientDocumentTableDefSymbol = Symbol("ClientDocumentTableDef");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/system-tables.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SCHEMA_META_TABLE = "__livestore_schema";
var schemaMetaTable = table4({
  name: SCHEMA_META_TABLE,
  columns: {
    tableName: mod_exports2.text({ primaryKey: true }),
    schemaHash: mod_exports2.integer({ nullable: false }),
    /** ISO date format */
    updatedAt: mod_exports2.text({ nullable: false })
  }
});
var SCHEMA_EVENT_DEFS_META_TABLE = "__livestore_schema_event_defs";
var schemaEventDefsMetaTable = table4({
  name: SCHEMA_EVENT_DEFS_META_TABLE,
  columns: {
    eventName: mod_exports2.text({ primaryKey: true }),
    schemaHash: mod_exports2.integer({ nullable: false }),
    /** ISO date format */
    updatedAt: mod_exports2.text({ nullable: false })
  }
});
var SESSION_CHANGESET_META_TABLE = "__livestore_session_changeset";
var sessionChangesetMetaTable = table4({
  name: SESSION_CHANGESET_META_TABLE,
  columns: {
    // TODO bring back primary key
    seqNumGlobal: mod_exports2.integer({ schema: GlobalEventSequenceNumber }),
    seqNumClient: mod_exports2.integer({ schema: ClientEventSequenceNumber }),
    seqNumRebaseGeneration: mod_exports2.integer({}),
    changeset: mod_exports2.blob({ nullable: true }),
    debug: mod_exports2.json({ nullable: true })
  },
  indexes: [{ columns: ["seqNumGlobal", "seqNumClient"], name: "idx_session_changeset_id" }]
});
var stateSystemTables = [schemaMetaTable, schemaEventDefsMetaTable, sessionChangesetMetaTable];
var EVENTLOG_META_TABLE = "eventlog";
var eventlogMetaTable = table4({
  name: EVENTLOG_META_TABLE,
  columns: {
    // TODO Adjust modeling so a global event never needs a client id component
    seqNumGlobal: mod_exports2.integer({ primaryKey: true, schema: GlobalEventSequenceNumber }),
    seqNumClient: mod_exports2.integer({ primaryKey: true, schema: ClientEventSequenceNumber }),
    seqNumRebaseGeneration: mod_exports2.integer({ primaryKey: true }),
    parentSeqNumGlobal: mod_exports2.integer({ schema: GlobalEventSequenceNumber }),
    parentSeqNumClient: mod_exports2.integer({ schema: ClientEventSequenceNumber }),
    parentSeqNumRebaseGeneration: mod_exports2.integer({}),
    /** Event definition name */
    name: mod_exports2.text({}),
    argsJson: mod_exports2.text({ schema: Schema_exports2.parseJson(Schema_exports2.Any) }),
    clientId: mod_exports2.text({}),
    sessionId: mod_exports2.text({}),
    schemaHash: mod_exports2.integer({}),
    syncMetadataJson: mod_exports2.text({ schema: Schema_exports2.parseJson(Schema_exports2.Option(Schema_exports2.JsonValue)) })
  },
  indexes: [
    { columns: ["seqNumGlobal"], name: "idx_eventlog_seqNumGlobal" },
    { columns: ["seqNumGlobal", "seqNumClient", "seqNumRebaseGeneration"], name: "idx_eventlog_seqNum" }
  ]
});
var SYNC_STATUS_TABLE = "__livestore_sync_status";
var syncStatusTable = table4({
  name: SYNC_STATUS_TABLE,
  columns: {
    head: mod_exports2.integer({ primaryKey: true }),
    // Null means the sync backend is not yet connected and we haven't yet seen a backend ID
    backendId: mod_exports2.text({ nullable: true })
  }
});

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/mod.js
var mod_exports4 = {};
__export(mod_exports4, {
  QueryBuilderAstSymbol: () => QueryBuilderAstSymbol,
  QueryBuilderTypeId: () => QueryBuilderTypeId,
  SQLite: () => mod_exports3
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/mod.js
var mod_exports3 = {};
__export(mod_exports3, {
  AutoIncrement: () => AutoIncrement,
  ClientDocumentTableDefSymbol: () => ClientDocumentTableDefSymbol,
  ColumnType: () => ColumnType,
  Default: () => Default2,
  PrimaryKeyId: () => PrimaryKeyId,
  TableDefInternalsSymbol: () => TableDefInternalsSymbol,
  Unique: () => Unique,
  blob: () => blob2,
  boolean: () => boolean5,
  clientDocument: () => clientDocument,
  clientOnly: () => clientOnly,
  column: () => column3,
  createOptimisticEventSchema: () => createOptimisticEventSchema,
  datetime: () => datetime2,
  defineEvent: () => defineEvent,
  defineFacts: () => defineFacts,
  defineMaterializer: () => defineMaterializer,
  getColumnDefForSchema: () => getColumnDefForSchema,
  integer: () => integer4,
  isColumnDefinition: () => isColumnDefinition2,
  json: () => json7,
  makeColumnSpec: () => makeColumnSpec,
  makeState: () => makeState2,
  materializers: () => materializers,
  real: () => real2,
  synced: () => synced,
  table: () => table4,
  tableIsClientDocumentTable: () => tableIsClientDocumentTable,
  text: () => text5,
  withAutoIncrement: () => withAutoIncrement,
  withColumnType: () => withColumnType,
  withDefault: () => withDefault3,
  withPrimaryKey: () => withPrimaryKey,
  withUnique: () => withUnique
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-spec.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var makeColumnSpec = /* @__PURE__ */ __name((tableAst) => {
  const primaryKeys = tableAst.columns.filter((_) => _.primaryKey).map((_) => `'${_.name}'`);
  const columnDefStrs = tableAst.columns.map(toSqliteColumnSpec);
  if (primaryKeys.length > 0) {
    columnDefStrs.push(`PRIMARY KEY (${primaryKeys.join(", ")})`);
  }
  return columnDefStrs.join(", ");
}, "makeColumnSpec");
var toSqliteColumnSpec = /* @__PURE__ */ __name((column4) => {
  const columnTypeStr = column4.type._tag;
  const nullableStr = column4.nullable === false ? "not null" : "";
  const autoIncrementStr = column4.autoIncrement ? "autoincrement" : "";
  const defaultValueStr = (() => {
    if (column4.default._tag === "None")
      return "";
    if (column4.default.value === null)
      return "default null";
    if (mod_exports2.isSqlDefaultValue(column4.default.value))
      return `default ${column4.default.value.sql}`;
    const encodeValue = Schema_exports2.encodeSync(column4.schema);
    const encodedDefaultValue = encodeValue(column4.default.value);
    if (columnTypeStr === "text")
      return `default '${encodedDefaultValue}'`;
    return `default ${encodedDefaultValue}`;
  })();
  return `'${column4.name}' ${columnTypeStr} ${nullableStr} ${autoIncrementStr} ${defaultValueStr}`;
}, "toSqliteColumnSpec");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/schema/state/sqlite/mod.js
var makeState2 = /* @__PURE__ */ __name((inputSchema) => {
  const inputTables = Array.isArray(inputSchema.tables) ? inputSchema.tables : Object.values(inputSchema.tables);
  const tables = /* @__PURE__ */ new Map();
  for (const tableDef of inputTables) {
    const sqliteDef = tableDef.sqliteDef;
    if (tables.has(sqliteDef.ast.name)) {
      shouldNeverHappen(`Duplicate table name: ${sqliteDef.ast.name}. Please use unique names for tables.`);
    }
    tables.set(sqliteDef.ast.name, tableDef);
  }
  for (const tableDef of stateSystemTables) {
    tables.set(tableDef.sqliteDef.name, tableDef);
  }
  const materializers2 = /* @__PURE__ */ new Map();
  for (const [name, materializer] of Object.entries(inputSchema.materializers)) {
    materializers2.set(name, materializer);
  }
  for (const tableDef of inputTables) {
    if (tableIsClientDocumentTable(tableDef)) {
      materializers2.set(tableDef[ClientDocumentTableDefSymbol].derived.setEventDef.name, tableDef[ClientDocumentTableDefSymbol].derived.setMaterializer);
    }
  }
  const hash5 = sqlite_exports.hash({
    _tag: "dbSchema",
    tables: [...tables.values()].map((_) => _.sqliteDef.ast)
  });
  return { sqlite: { tables, migrations: inputSchema.migrations ?? { strategy: "auto" }, hash: hash5 }, materializers: materializers2 };
}, "makeState");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/sync/errors.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var IsOfflineError = class extends Schema_exports2.TaggedError()("IsOfflineError", {
  cause: Schema_exports2.Defect
}) {
};
__name(IsOfflineError, "IsOfflineError");
var BackendId = Schema_exports2.String.annotations({ title: "@livestore/sync-cf:BackendId" });
var BackendIdMismatchError = class extends Schema_exports2.TaggedError()("BackendIdMismatchError", {
  expected: BackendId,
  received: BackendId
}) {
};
__name(BackendIdMismatchError, "BackendIdMismatchError");
var ServerAheadError = class extends Schema_exports2.TaggedError()("ServerAheadError", {
  minimumExpectedNum: EventSequenceNumber_exports.GlobalEventSequenceNumber,
  providedNum: EventSequenceNumber_exports.GlobalEventSequenceNumber
}) {
};
__name(ServerAheadError, "ServerAheadError");
var InvalidPushError = class extends Schema_exports2.TaggedError()("InvalidPushError", {
  cause: Schema_exports2.Union(UnexpectedError, ServerAheadError, BackendIdMismatchError)
}) {
};
__name(InvalidPushError, "InvalidPushError");
var InvalidPullError = class extends Schema_exports2.TaggedError()("InvalidPullError", {
  cause: Schema_exports2.Defect
}) {
};
__name(InvalidPullError, "InvalidPullError");
var LeaderAheadError = class extends Schema_exports2.TaggedError()("LeaderAheadError", {
  minimumExpectedNum: EventSequenceNumber_exports.EventSequenceNumber,
  providedNum: EventSequenceNumber_exports.EventSequenceNumber
  /** Generation number the client session should use for subsequent pushes */
  // nextGeneration: Schema.Number,
}) {
};
__name(LeaderAheadError, "LeaderAheadError");
var SyncError = Schema_exports2.Union(InvalidPushError, InvalidPullError);

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/sync/sync-backend.js
var sync_backend_exports = {};
__export(sync_backend_exports, {
  PullResPageInfo: () => PullResPageInfo,
  cursorFromPullResItem: () => cursorFromPullResItem,
  makeBackendIdHelper: () => makeBackendIdHelper,
  of: () => of6,
  pageInfoMoreKnown: () => pageInfoMoreKnown,
  pageInfoMoreUnknown: () => pageInfoMoreUnknown,
  pageInfoNoMore: () => pageInfoNoMore,
  pullResItemEmpty: () => pullResItemEmpty
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/sync/sync-backend-kv.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var makeBackendIdHelper = Effect_exports2.gen(function* () {
  const kv = yield* KeyValueStore_exports.KeyValueStore;
  const backendIdKey = `backendId`;
  const backendIdRef = { current: yield* kv.get(backendIdKey).pipe(UnexpectedError.mapToUnexpectedError) };
  const setBackendId = /* @__PURE__ */ __name((backendId) => Effect_exports2.gen(function* () {
    if (backendIdRef.current._tag === "None" || backendIdRef.current.value !== backendId) {
      backendIdRef.current = Option_exports.some(backendId);
      yield* kv.set(backendIdKey, backendId);
    }
  }).pipe(UnexpectedError.mapToUnexpectedError), "setBackendId");
  return {
    lazySet: setBackendId,
    get: () => backendIdRef.current
  };
});

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/sync/sync-backend.js
var PullResPageInfo = Schema_exports2.Union(Schema_exports2.TaggedStruct("MoreUnknown", {}), Schema_exports2.TaggedStruct("MoreKnown", {
  remaining: Schema_exports2.Number
}), Schema_exports2.TaggedStruct("NoMore", {}));
var pageInfoNoMore = { _tag: "NoMore" };
var pageInfoMoreUnknown = { _tag: "MoreUnknown" };
var pageInfoMoreKnown = /* @__PURE__ */ __name((remaining) => ({ _tag: "MoreKnown", remaining }), "pageInfoMoreKnown");
var pullResItemEmpty = /* @__PURE__ */ __name(() => ({
  batch: [],
  pageInfo: pageInfoNoMore
}), "pullResItemEmpty");
var of6 = /* @__PURE__ */ __name((obj) => obj, "of");
var cursorFromPullResItem = /* @__PURE__ */ __name((item) => {
  const lastEvent = item.batch.at(-1);
  if (!lastEvent) {
    return Option_exports.none();
  }
  return Option_exports.some({ eventSequenceNumber: lastEvent.eventEncoded.seqNum, metadata: lastEvent.metadata });
}, "cursorFromPullResItem");

// node_modules/.pnpm/@livestore+common@0.4.0-dev.9_ec5cc462648115ba525263a6e0ed49ec/node_modules/@livestore/common/dist/sync/sync.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/sync-message-types.js
var sync_message_types_exports = {};
__export(sync_message_types_exports, {
  AdminInfoRequest: () => AdminInfoRequest,
  AdminInfoResponse: () => AdminInfoResponse,
  AdminResetRoomRequest: () => AdminResetRoomRequest,
  AdminResetRoomResponse: () => AdminResetRoomResponse,
  BackendToClientMessage: () => BackendToClientMessage,
  ClientToBackendMessage: () => ClientToBackendMessage,
  Message: () => Message,
  Ping: () => Ping,
  Pong: () => Pong,
  PullRequest: () => PullRequest,
  PullResponse: () => PullResponse,
  PushAck: () => PushAck,
  PushRequest: () => PushRequest,
  SyncMetadata: () => SyncMetadata,
  emptyPullResponse: () => emptyPullResponse
});
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SyncMetadata = Schema_exports2.TaggedStruct("SyncMessage.SyncMetadata", {
  /** ISO date format */
  createdAt: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:SyncMetadata" });
var PullRequest = Schema_exports2.Struct({
  /** Omitting the cursor will start from the beginning */
  cursor: Schema_exports2.Option(Schema_exports2.Struct({
    backendId: BackendId,
    eventSequenceNumber: EventSequenceNumber_exports.GlobalEventSequenceNumber
  }))
}).annotations({ title: "@livestore/sync-cf:PullRequest" });
var PullResponse = Schema_exports2.Struct({
  batch: Schema_exports2.Array(Schema_exports2.Struct({
    eventEncoded: LiveStoreEvent_exports.AnyEncodedGlobal,
    metadata: Schema_exports2.Option(SyncMetadata)
  })),
  pageInfo: sync_backend_exports.PullResPageInfo,
  backendId: BackendId
}).annotations({ title: "@livestore/sync-cf:PullResponse" });
var emptyPullResponse = /* @__PURE__ */ __name((backendId) => PullResponse.make({
  batch: [],
  pageInfo: sync_backend_exports.pageInfoNoMore,
  backendId
}), "emptyPullResponse");
var PushRequest = Schema_exports2.Struct({
  batch: Schema_exports2.Array(LiveStoreEvent_exports.AnyEncodedGlobal),
  backendId: Schema_exports2.Option(BackendId)
}).annotations({ title: "@livestore/sync-cf:PushRequest" });
var PushAck = Schema_exports2.Struct({}).annotations({
  title: "@livestore/sync-cf:PushAck"
});
var Ping = Schema_exports2.TaggedStruct("SyncMessage.Ping", {}).annotations({ title: "@livestore/sync-cf:Ping" });
var Pong = Schema_exports2.TaggedStruct("SyncMessage.Pong", {}).annotations({ title: "@livestore/sync-cf:Pong" });
var AdminResetRoomRequest = Schema_exports2.TaggedStruct("SyncMessage.AdminResetRoomRequest", {
  adminSecret: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:AdminResetRoomRequest" });
var AdminResetRoomResponse = Schema_exports2.TaggedStruct("SyncMessage.AdminResetRoomResponse", {}).annotations({
  title: "@livestore/sync-cf:AdminResetRoomResponse"
});
var AdminInfoRequest = Schema_exports2.TaggedStruct("SyncMessage.AdminInfoRequest", {
  adminSecret: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:AdminInfoRequest" });
var AdminInfoResponse = Schema_exports2.TaggedStruct("SyncMessage.AdminInfoResponse", {
  info: Schema_exports2.Struct({
    durableObjectId: Schema_exports2.String
  })
}).annotations({ title: "@livestore/sync-cf:AdminInfoResponse" });
var BackendToClientMessage = Schema_exports2.Union(PullResponse, PushAck, Pong, AdminResetRoomResponse, AdminInfoResponse);
var ClientToBackendMessage = Schema_exports2.Union(PullRequest, PushRequest, Ping, AdminResetRoomRequest, AdminInfoRequest);
var Message = Schema_exports2.Union(BackendToClientMessage, ClientToBackendMessage);

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/http-rpc-schema.js
var SyncHttpRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncHttpRpc.Pull", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PullRequest.fields
  }),
  success: PullResponse,
  error: InvalidPullError,
  stream: true
}), Rpc_exports.make("SyncHttpRpc.Push", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PushRequest.fields
  }),
  success: PushAck,
  error: InvalidPushError
}), Rpc_exports.make("SyncHttpRpc.Ping", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue)
  }),
  success: Pong,
  error: UnexpectedError
})) {
};
__name(SyncHttpRpc, "SyncHttpRpc");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/mod.js
var SearchParamsSchema = Schema_exports2.Struct({
  storeId: Schema_exports2.String,
  payload: Schema_exports2.compose(Schema_exports2.StringFromUriComponent, Schema_exports2.parseJson(Schema_exports2.JsonValue)).pipe(Schema_exports2.UndefinedOr),
  // NOTE `do-rpc` is handled differently
  transport: Schema_exports2.Union(Schema_exports2.Literal("http"), Schema_exports2.Literal("ws"))
});

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/shared.js
var PERSISTENCE_FORMAT_VERSION = 7;
var encodeOutgoingMessage = Schema_exports2.encodeSync(Schema_exports2.parseJson(sync_message_types_exports.BackendToClientMessage));
var encodeIncomingMessage = Schema_exports2.encodeSync(Schema_exports2.parseJson(sync_message_types_exports.ClientToBackendMessage));
var matchSyncRequest = /* @__PURE__ */ __name((request2) => {
  const url2 = new URL(request2.url);
  const urlParams3 = UrlParams_exports.fromInput(url2.searchParams);
  const paramsResult = UrlParams_exports.schemaStruct(SearchParamsSchema)(urlParams3).pipe(Effect_exports2.option, Effect_exports2.runSync);
  if (paramsResult._tag === "None") {
    return void 0;
  }
  return paramsResult.value;
}, "matchSyncRequest");
var MAX_PULL_EVENTS_PER_MESSAGE = 100;
var MAX_WS_MESSAGE_BYTES = 9e5;
var WebSocketAttachmentSchema = Schema_exports2.parseJson(Schema_exports2.Struct({
  // Same across all websocket connections
  storeId: Schema_exports2.String,
  // Different for each websocket connection
  payload: Schema_exports2.optional(Schema_exports2.JsonValue),
  pullRequestIds: Schema_exports2.Array(Schema_exports2.String)
}));

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/layer.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/sqlite.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var eventlogTable = mod_exports4.SQLite.table({
  // NOTE actual table name is determined at runtime to use proper storeId
  name: `eventlog_${PERSISTENCE_FORMAT_VERSION}_$storeId`,
  columns: {
    seqNum: mod_exports4.SQLite.integer({ primaryKey: true, schema: EventSequenceNumber_exports.GlobalEventSequenceNumber }),
    parentSeqNum: mod_exports4.SQLite.integer({ schema: EventSequenceNumber_exports.GlobalEventSequenceNumber }),
    name: mod_exports4.SQLite.text({}),
    args: mod_exports4.SQLite.text({ schema: Schema_exports2.parseJson(Schema_exports2.Any), nullable: true }),
    /** ISO date format. Currently only used for debugging purposes. */
    createdAt: mod_exports4.SQLite.text({}),
    clientId: mod_exports4.SQLite.text({}),
    sessionId: mod_exports4.SQLite.text({})
  }
});
var contextTable = mod_exports4.SQLite.table({
  name: `context_${PERSISTENCE_FORMAT_VERSION}`,
  columns: {
    storeId: mod_exports4.SQLite.text({ primaryKey: true }),
    currentHead: mod_exports4.SQLite.integer({ schema: EventSequenceNumber_exports.GlobalEventSequenceNumber }),
    backendId: mod_exports4.SQLite.text({})
  }
});

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/sync-storage.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var makeStorage = /* @__PURE__ */ __name((ctx, env, storeId) => {
  const dbName = `eventlog_${PERSISTENCE_FORMAT_VERSION}_${toValidTableName(storeId)}`;
  const execDb = /* @__PURE__ */ __name((cb) => Effect_exports2.tryPromise({
    try: () => cb(env.DB),
    catch: (error3) => new UnexpectedError({ cause: error3, payload: { dbName } })
  }).pipe(Effect_exports2.map((_) => _.results), Effect_exports2.withSpan("@livestore/sync-cf:durable-object:execDb")), "execDb");
  const D1_MAX_JSON_RESPONSE_BYTES = 1e6;
  const D1_RESPONSE_SAFETY_MARGIN_BYTES = 64 * 1024;
  const D1_TARGET_RESPONSE_BYTES = D1_MAX_JSON_RESPONSE_BYTES - D1_RESPONSE_SAFETY_MARGIN_BYTES;
  const D1_INITIAL_PAGE_SIZE = 256;
  const D1_MIN_PAGE_SIZE = 1;
  const decodeEventlogRows = Schema_exports2.decodeUnknownSync(Schema_exports2.Array(eventlogTable.rowSchema));
  const textEncoder3 = new TextEncoder();
  const decreaseLimit = /* @__PURE__ */ __name((limit) => Math.max(D1_MIN_PAGE_SIZE, Math.floor(limit / 2)), "decreaseLimit");
  const increaseLimit = /* @__PURE__ */ __name((limit) => Math.min(D1_INITIAL_PAGE_SIZE, limit * 2), "increaseLimit");
  const computeNextLimit = /* @__PURE__ */ __name((limit, encodedSize) => {
    if (encodedSize > D1_TARGET_RESPONSE_BYTES && limit > D1_MIN_PAGE_SIZE) {
      const next = decreaseLimit(limit);
      return next === limit ? limit : next;
    }
    if (encodedSize < D1_TARGET_RESPONSE_BYTES / 2 && limit < D1_INITIAL_PAGE_SIZE) {
      const next = increaseLimit(limit);
      return next === limit ? limit : next;
    }
    return limit;
  }, "computeNextLimit");
  const getEvents = /* @__PURE__ */ __name((cursor) => Effect_exports2.gen(function* () {
    const countStatement = cursor === void 0 ? `SELECT COUNT(*) as total FROM ${dbName}` : `SELECT COUNT(*) as total FROM ${dbName} WHERE seqNum > ?`;
    const countRows = yield* execDb((db) => {
      const prepared = db.prepare(countStatement);
      return cursor === void 0 ? prepared.all() : prepared.bind(cursor).all();
    });
    const total = Number(countRows[0]?.total ?? 0);
    const initialState = { cursor, limit: D1_INITIAL_PAGE_SIZE };
    const fetchPage = /* @__PURE__ */ __name((state) => Effect_exports2.gen(function* () {
      const statement = state.cursor === void 0 ? `SELECT * FROM ${dbName} ORDER BY seqNum ASC LIMIT ?` : `SELECT * FROM ${dbName} WHERE seqNum > ? ORDER BY seqNum ASC LIMIT ?`;
      const rawEvents = yield* execDb((db) => {
        const prepared = db.prepare(statement);
        return state.cursor === void 0 ? prepared.bind(state.limit).all() : prepared.bind(state.cursor, state.limit).all();
      });
      if (rawEvents.length === 0) {
        return Option_exports.none();
      }
      const encodedSize = textEncoder3.encode(JSON.stringify(rawEvents)).byteLength;
      if (encodedSize > D1_TARGET_RESPONSE_BYTES && state.limit > D1_MIN_PAGE_SIZE) {
        const nextLimit = decreaseLimit(state.limit);
        if (nextLimit !== state.limit) {
          return yield* fetchPage({ cursor: state.cursor, limit: nextLimit });
        }
      }
      const decodedRows = Chunk_exports.fromIterable(decodeEventlogRows(rawEvents));
      const eventsChunk = Chunk_exports.map(decodedRows, ({ createdAt, ...eventEncoded }) => ({
        eventEncoded,
        metadata: Option_exports.some(SyncMetadata.make({ createdAt }))
      }));
      const lastSeqNum = Chunk_exports.unsafeLast(decodedRows).seqNum;
      const nextState = { cursor: lastSeqNum, limit: computeNextLimit(state.limit, encodedSize) };
      return Option_exports.some([eventsChunk, nextState]);
    }), "fetchPage");
    const stream6 = Stream_exports2.unfoldChunkEffect(initialState, fetchPage);
    return { total, stream: stream6 };
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("@livestore/sync-cf:durable-object:getEvents", { attributes: { dbName, cursor } })), "getEvents");
  const appendEvents = /* @__PURE__ */ __name((batch, createdAt) => Effect_exports2.gen(function* () {
    if (batch.length === 0)
      return;
    const CHUNK_SIZE = 14;
    for (let i = 0; i < batch.length; i += CHUNK_SIZE) {
      const chunk4 = batch.slice(i, i + CHUNK_SIZE);
      const valuesPlaceholders = chunk4.map(() => "(?, ?, ?, ?, ?, ?, ?)").join(", ");
      const sql2 = `INSERT INTO ${dbName} (seqNum, parentSeqNum, args, name, createdAt, clientId, sessionId) VALUES ${valuesPlaceholders}`;
      const params2 = chunk4.flatMap((event) => [
        event.seqNum,
        event.parentSeqNum,
        event.args === void 0 ? null : JSON.stringify(event.args),
        event.name,
        createdAt,
        event.clientId,
        event.sessionId
      ]);
      yield* execDb((db) => db.prepare(sql2).bind(...params2).run());
    }
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("@livestore/sync-cf:durable-object:appendEvents", {
    attributes: { dbName, batchLength: batch.length }
  })), "appendEvents");
  const resetStore = Effect_exports2.promise(() => ctx.storage.deleteAll()).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("@livestore/sync-cf:durable-object:resetStore"));
  return {
    dbName,
    // getHead,
    getEvents,
    appendEvents,
    resetStore
  };
}, "makeStorage");
var toValidTableName = /* @__PURE__ */ __name((str) => str.replaceAll(/[^a-zA-Z0-9]/g, "_"), "toValidTableName");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/layer.js
var CacheSymbol = Symbol("Cache");
var DoCtx = class extends Effect_exports2.Service()("DoCtx", {
  effect: Effect_exports2.fn(function* ({ doSelf, doOptions, from }) {
    if (doSelf[CacheSymbol] !== void 0) {
      return doSelf[CacheSymbol];
    }
    const getStoreId = /* @__PURE__ */ __name((from2) => {
      if (Predicate_exports.hasProperty(from2, "url")) {
        const url2 = new URL(from2.url);
        return url2.searchParams.get("storeId") ?? shouldNeverHappen(`No storeId provided in request URL search params`);
      }
      return from2.storeId;
    }, "getStoreId");
    const storeId = getStoreId(from);
    const storage = makeStorage(doSelf.ctx, doSelf.env, storeId);
    {
      const colSpec = mod_exports4.SQLite.makeColumnSpec(eventlogTable.sqliteDef.ast);
      yield* Effect_exports2.promise(() => doSelf.env.DB.exec(`CREATE TABLE IF NOT EXISTS "${storage.dbName}" (${colSpec}) strict`));
    }
    {
      const colSpec = mod_exports4.SQLite.makeColumnSpec(contextTable.sqliteDef.ast);
      doSelf.ctx.storage.sql.exec(`CREATE TABLE IF NOT EXISTS "${contextTable.sqliteDef.name}" (${colSpec}) strict`);
    }
    const storageRow = doSelf.ctx.storage.sql.exec(`SELECT * FROM "${contextTable.sqliteDef.name}" WHERE storeId = ?`, storeId).toArray()[0];
    const currentHeadRef = { current: storageRow?.currentHead ?? EventSequenceNumber_exports.ROOT.global };
    const backendId = storageRow?.backendId ?? nanoid();
    const updateCurrentHead = /* @__PURE__ */ __name((currentHead) => {
      doSelf.ctx.storage.sql.exec(`INSERT OR REPLACE INTO "${contextTable.sqliteDef.name}" (storeId, currentHead, backendId) VALUES (?, ?, ?)`, storeId, currentHead, backendId);
      currentHeadRef.current = currentHead;
      doSelf[CacheSymbol].currentHeadRef = { current: currentHead };
    }, "updateCurrentHead");
    const rpcSubscriptions = /* @__PURE__ */ new Map();
    const storageCache = {
      storeId,
      backendId,
      currentHeadRef,
      updateCurrentHead,
      storage,
      doOptions,
      env: doSelf.env,
      ctx: doSelf.ctx,
      rpcSubscriptions
    };
    doSelf[CacheSymbol] = storageCache;
    if (storageRow === void 0) {
      updateCurrentHead(EventSequenceNumber_exports.ROOT.global);
    }
    return storageCache;
  }, UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("@livestore/sync-cf:durable-object:makeDoCtx"))
}) {
};
__name(DoCtx, "DoCtx");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/do-rpc-server.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/do-rpc-schema.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var commonPayloadFields = {
  /**
   * While the storeId is already implied by the durable object, we still need the explicit storeId
   * since a DO doesn't know its own id.name value. 
   * https://community.cloudflare.com/t/how-can-i-get-the-name-of-a-durable-object-from-itself/505961/8
   */
  storeId: Schema_exports2.String,
  /** Needed for various reasons (e.g. auth) */
  payload: Schema_exports2.optional(Schema_exports2.JsonValue)
};
var SyncDoRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncDoRpc.Pull", {
  payload: {
    /** Omitting the cursor will start from the beginning */
    cursor: PullRequest.fields.cursor,
    // TODO rename
    /** Whether to keep the pull stream alive and wait for more events */
    rpcContext: Schema_exports2.optional(Schema_exports2.Struct({
      callerContext: Schema_exports2.Struct({
        bindingName: Schema_exports2.String,
        durableObjectId: Schema_exports2.String
      })
    })),
    ...commonPayloadFields
  },
  success: Schema_exports2.Struct({
    rpcRequestId: Schema_exports2.String,
    ...PullResponse.fields
  }),
  error: InvalidPullError,
  stream: true
}), Rpc_exports.make("SyncDoRpc.Push", {
  payload: {
    ...PushRequest.fields,
    ...commonPayloadFields
  },
  success: PushAck,
  error: InvalidPushError
}), Rpc_exports.make("SyncDoRpc.Ping", {
  payload: {
    ...commonPayloadFields
  },
  success: Schema_exports2.Void
})) {
};
__name(SyncDoRpc, "SyncDoRpc");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/pull.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/ws-chunking.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var textEncoder2 = new TextEncoder();
var splitChunkBySize = /* @__PURE__ */ __name((options4) => (chunk4) => {
  const maxItems2 = Math.max(1, options4.maxItems);
  const maxBytes = Math.max(1, options4.maxBytes);
  const encode7 = options4.encode;
  const measure = /* @__PURE__ */ __name((items2) => {
    const encoded = encode7(items2);
    return textEncoder2.encode(JSON.stringify(encoded)).byteLength;
  }, "measure");
  const items = Chunk_exports.toReadonlyArray(chunk4);
  if (items.length === 0) {
    return Chunk_exports.fromIterable([]);
  }
  const result = [];
  let current2 = [];
  const flushCurrent = /* @__PURE__ */ __name(() => {
    if (current2.length > 0) {
      result.push(Chunk_exports.fromIterable(current2));
      current2 = [];
    }
  }, "flushCurrent");
  for (const item of items) {
    current2.push(item);
    const exceedsLimit = current2.length > maxItems2 || measure(current2) > maxBytes;
    if (exceedsLimit) {
      const last5 = current2.pop();
      flushCurrent();
      if (last5 !== void 0) {
        current2 = [last5];
        const singleItemTooLarge = measure(current2) > maxBytes;
        if (singleItemTooLarge || current2.length > maxItems2) {
          result.push(Chunk_exports.of(last5));
          current2 = [];
        }
      }
    }
  }
  flushCurrent();
  return Chunk_exports.fromIterable(result);
}, "splitChunkBySize");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/pull.js
var encodePullResponse = Schema_exports2.encodeSync(sync_message_types_exports.PullResponse);
var makeEndingPullStream = /* @__PURE__ */ __name((req, payload) => Effect_exports2.gen(function* () {
  const { doOptions, backendId, storeId, storage } = yield* DoCtx;
  if (doOptions?.onPull) {
    yield* Effect_exports2.tryAll(() => doOptions.onPull(req, { storeId, payload })).pipe(UnexpectedError.mapToUnexpectedError);
  }
  if (req.cursor._tag === "Some" && req.cursor.value.backendId !== backendId) {
    return yield* new BackendIdMismatchError({ expected: backendId, received: req.cursor.value.backendId });
  }
  const { stream: storedEvents, total } = yield* storage.getEvents(Option_exports.getOrUndefined(req.cursor)?.eventSequenceNumber);
  return storedEvents.pipe(Stream_exports2.mapChunks(splitChunkBySize({
    maxItems: MAX_PULL_EVENTS_PER_MESSAGE,
    maxBytes: MAX_WS_MESSAGE_BYTES,
    encode: (batch) => encodePullResponse(sync_message_types_exports.PullResponse.make({ batch, pageInfo: sync_backend_exports.pageInfoNoMore, backendId }))
  })), Stream_exports2.mapAccum(total, (remaining, chunk4) => {
    const asArray = Chunk_exports.toReadonlyArray(chunk4);
    const nextRemaining = Math.max(0, remaining - asArray.length);
    return [
      nextRemaining,
      sync_message_types_exports.PullResponse.make({
        batch: asArray,
        pageInfo: nextRemaining > 0 ? sync_backend_exports.pageInfoMoreKnown(nextRemaining) : sync_backend_exports.pageInfoNoMore,
        backendId
      })
    ];
  }), Stream_exports2.tap(Effect_exports2.fn(function* (res) {
    if (doOptions?.onPullRes) {
      yield* Effect_exports2.tryAll(() => doOptions.onPullRes(res)).pipe(UnexpectedError.mapToUnexpectedError);
    }
  })), Stream_exports2.emitIfEmpty(sync_message_types_exports.emptyPullResponse(backendId)));
}).pipe(Stream_exports2.unwrap, Stream_exports2.mapError((cause3) => InvalidPullError.make({ cause: cause3 })), Stream_exports2.withSpan("cloudflare-provider:pull")), "makeEndingPullStream");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/push.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var encodePullResponse2 = Schema_exports2.encodeSync(sync_message_types_exports.PullResponse);
var makePush2 = /* @__PURE__ */ __name(({ payload, options: options4, storeId, ctx, env }) => (pushRequest) => Effect_exports2.gen(function* () {
  const { backendId, storage, currentHeadRef, updateCurrentHead, rpcSubscriptions } = yield* DoCtx;
  if (pushRequest.batch.length === 0) {
    return sync_message_types_exports.PushAck.make({});
  }
  if (options4?.onPush) {
    yield* Effect_exports2.tryAll(() => options4.onPush(pushRequest, { storeId, payload })).pipe(UnexpectedError.mapToUnexpectedError);
  }
  if (pushRequest.backendId._tag === "Some" && pushRequest.backendId.value !== backendId) {
    return yield* new BackendIdMismatchError({ expected: backendId, received: pushRequest.backendId.value });
  }
  const { createdAt } = yield* Effect_exports2.gen(function* () {
    const currentHead = currentHeadRef.current;
    const firstEventParent = pushRequest.batch[0].parentSeqNum;
    if (firstEventParent !== currentHead) {
      return yield* new ServerAheadError({ minimumExpectedNum: currentHead, providedNum: firstEventParent });
    }
    const createdAt2 = (/* @__PURE__ */ new Date()).toISOString();
    yield* storage.appendEvents(pushRequest.batch, createdAt2);
    updateCurrentHead(pushRequest.batch.at(-1).seqNum);
    return { createdAt: createdAt2 };
  }).pipe(blockConcurrencyWhile(ctx));
  yield* Effect_exports2.gen(function* () {
    const connectedClients = ctx.getWebSockets();
    const responses = Chunk_exports.fromIterable(pushRequest.batch).pipe(splitChunkBySize({
      maxItems: MAX_PULL_EVENTS_PER_MESSAGE,
      maxBytes: MAX_WS_MESSAGE_BYTES,
      encode: (items) => encodePullResponse2(sync_message_types_exports.PullResponse.make({
        batch: items.map((eventEncoded) => ({
          eventEncoded,
          metadata: Option_exports.some(sync_message_types_exports.SyncMetadata.make({ createdAt }))
        })),
        pageInfo: sync_backend_exports.pageInfoNoMore,
        backendId
      }))
    }), Chunk_exports.map((eventsChunk) => {
      const batchWithMetadata = Chunk_exports.toReadonlyArray(eventsChunk).map((eventEncoded) => ({
        eventEncoded,
        metadata: Option_exports.some(sync_message_types_exports.SyncMetadata.make({ createdAt }))
      }));
      const response = sync_message_types_exports.PullResponse.make({
        batch: batchWithMetadata,
        pageInfo: sync_backend_exports.pageInfoNoMore,
        backendId
      });
      return {
        response,
        encoded: Schema_exports2.encodeSync(sync_message_types_exports.PullResponse)(response)
      };
    }));
    if (connectedClients.length > 0) {
      for (const { response, encoded } of responses) {
        if (options4?.onPullRes) {
          yield* Effect_exports2.tryAll(() => options4.onPullRes(response)).pipe(UnexpectedError.mapToUnexpectedError);
        }
        for (const conn of connectedClients) {
          const attachment = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(conn.deserializeAttachment());
          for (const requestId of attachment.pullRequestIds) {
            const res = {
              _tag: "Chunk",
              requestId,
              values: [encoded]
            };
            conn.send(JSON.stringify(res));
          }
        }
      }
      yield* Effect_exports2.logDebug(`Broadcasted to ${connectedClients.length} WebSocket clients`);
    }
    if (rpcSubscriptions.size > 0) {
      for (const subscription of rpcSubscriptions.values()) {
        for (const { encoded } of responses) {
          yield* emitStreamResponse({
            callerContext: subscription.callerContext,
            env,
            requestId: subscription.requestId,
            values: [encoded]
          }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.exit);
        }
      }
      yield* Effect_exports2.logDebug(`Broadcasted to ${rpcSubscriptions.size} RPC clients`);
    }
  }).pipe(
    Effect_exports2.tapCauseLogPretty,
    Effect_exports2.withSpan("push-rpc-broadcast"),
    Effect_exports2.uninterruptible,
    // We need to make sure Effect RPC doesn't interrupt this fiber
    Effect_exports2.fork
  );
  yield* Effect_exports2.yieldNow();
  return sync_message_types_exports.PushAck.make({});
}).pipe(Effect_exports2.tap(Effect_exports2.fn(function* (message) {
  if (options4?.onPushRes) {
    yield* Effect_exports2.tryAll(() => options4.onPushRes(message)).pipe(UnexpectedError.mapToUnexpectedError);
  }
})), Effect_exports2.mapError((cause3) => InvalidPushError.make({ cause: cause3 })), Effect_exports2.withSpan("sync-cf:do:push", { attributes: { storeId, batchSize: pushRequest.batch.length } })), "makePush");
var blockConcurrencyWhile = /* @__PURE__ */ __name((ctx) => (eff) => Effect_exports2.gen(function* () {
  const runtime6 = yield* Effect_exports2.runtime();
  const exit4 = yield* Effect_exports2.promise(() => ctx.blockConcurrencyWhile(() => eff.pipe(Effect_exports2.provide(runtime6), Effect_exports2.runPromiseExit)));
  return yield* exit4;
}), "blockConcurrencyWhile");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/do-rpc-server.js
var createDoRpcHandler = /* @__PURE__ */ __name((options4) => Effect_exports2.gen(void 0, function* () {
  const { payload, input } = options4;
  const RpcLive = SyncDoRpc.toLayer({
    "SyncDoRpc.Ping": (_req) => {
      return Effect_exports2.succeed(sync_message_types_exports.Pong.make({}));
    },
    "SyncDoRpc.Pull": (req, { headers }) => Effect_exports2.gen(this, function* () {
      const { rpcSubscriptions } = yield* DoCtx;
      if (req.rpcContext) {
        rpcSubscriptions.set(req.storeId, {
          storeId: req.storeId,
          payload: req.payload,
          subscribedAt: Date.now(),
          requestId: Headers_exports.get(headers, "x-rpc-request-id").pipe(Option_exports.getOrThrow),
          callerContext: req.rpcContext.callerContext
        });
      }
      return makeEndingPullStream(req, req.payload);
    }).pipe(Stream_exports2.unwrap, Stream_exports2.map((res) => ({
      ...res,
      rpcRequestId: Headers_exports.get(headers, "x-rpc-request-id").pipe(Option_exports.getOrThrow)
    })), Stream_exports2.provideLayer(DoCtx.Default({ ...input, from: { storeId: req.storeId } })), Stream_exports2.mapError((cause3) => cause3._tag === "InvalidPullError" ? cause3 : InvalidPullError.make({ cause: cause3 })), Stream_exports2.tapErrorCause(Effect_exports2.log)),
    "SyncDoRpc.Push": (req) => Effect_exports2.gen(this, function* () {
      const { doOptions, ctx, env, storeId } = yield* DoCtx;
      const push = makePush2({ storeId, payload: req.payload, options: doOptions, ctx, env });
      return yield* push(req);
    }).pipe(Effect_exports2.provide(DoCtx.Default({ ...input, from: { storeId: req.storeId } })), Effect_exports2.mapError((cause3) => cause3._tag === "InvalidPushError" ? cause3 : InvalidPushError.make({ cause: cause3 })), Effect_exports2.tapCauseLogPretty)
  });
  const handler = toDurableObjectHandler(SyncDoRpc, {
    layer: Layer_exports.mergeAll(RpcLive, RpcSerialization_exports.layerJson, HttpServer_exports.layerContext).pipe(Layer_exports.provide(Logger_exports2.consoleWithThread("SyncDo")), Layer_exports.provide(Logger_exports2.minimumLogLevel(LogLevel_exports.Debug)))
  });
  return yield* handler(payload);
}).pipe(Effect_exports2.withSpan("createDoRpcHandler")), "createDoRpcHandler");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/http-rpc-server.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var createHttpRpcHandler = /* @__PURE__ */ __name(({ request: request2 }) => Effect_exports2.gen(function* () {
  const handlerLayer = createHttpRpcLayer;
  const httpApp = RpcServer_exports.toHttpApp(SyncHttpRpc).pipe(Effect_exports2.provide(handlerLayer));
  const webHandler = yield* httpApp.pipe(Effect_exports2.map(HttpApp_exports.toWebHandler));
  return yield* Effect_exports2.promise(() => webHandler(request2)).pipe(Effect_exports2.timeout(1e4));
}).pipe(Effect_exports2.withSpan("createHttpRpcHandler")), "createHttpRpcHandler");
var createHttpRpcLayer = (
  // TODO implement admin requests
  SyncHttpRpc.toLayer({
    "SyncHttpRpc.Pull": (req) => makeEndingPullStream(req, req.payload),
    "SyncHttpRpc.Push": (req) => Effect_exports2.gen(function* () {
      const { ctx, env, doOptions, storeId } = yield* DoCtx;
      const push = makePush2({ payload: void 0, options: doOptions, storeId, ctx, env });
      return yield* push(req);
    }),
    "SyncHttpRpc.Ping": () => Effect_exports2.succeed(Pong.make({}))
  }).pipe(Layer_exports.provideMerge(RpcServer_exports.layerProtocolHttp({ path: "/http-rpc" })), Layer_exports.provideMerge(RpcSerialization_exports.layerJson))
);

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/ws-rpc-server.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/common/ws-rpc-schema.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var SyncWsRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncWsRpc.Pull", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    /** Whether to keep the pull stream alive and wait for more events */
    live: Schema_exports2.Boolean,
    ...PullRequest.fields
  }),
  success: PullResponse,
  error: InvalidPullError,
  stream: true
}), Rpc_exports.make("SyncWsRpc.Push", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PushRequest.fields
  }),
  success: PushAck,
  error: InvalidPushError
})) {
};
__name(SyncWsRpc, "SyncWsRpc");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/ws-rpc-server.js
var makeRpcServer = /* @__PURE__ */ __name(({ doSelf, doOptions }) => {
  const handlersLayer = SyncWsRpc.toLayer({
    "SyncWsRpc.Pull": (req) => makeEndingPullStream(req, req.payload).pipe(
      // Needed to keep the stream alive on the client side for phase 2 (i.e. not send the `Exit` stream RPC message)
      req.live ? Stream_exports2.concat(Stream_exports2.never) : identity,
      Stream_exports2.provideLayer(DoCtx.Default({ doSelf, doOptions, from: { storeId: req.storeId } })),
      Stream_exports2.mapError((cause3) => cause3._tag === "InvalidPullError" ? cause3 : InvalidPullError.make({ cause: cause3 }))
    ),
    "SyncWsRpc.Push": (req) => Effect_exports2.gen(function* () {
      const { doOptions: doOptions2, storeId, ctx, env } = yield* DoCtx;
      const push = makePush2({ options: doOptions2, storeId, payload: req.payload, ctx, env });
      return yield* push(req);
    }).pipe(Effect_exports2.provide(DoCtx.Default({ doSelf, doOptions, from: { storeId: req.storeId } })), Effect_exports2.mapError((cause3) => cause3._tag === "InvalidPushError" ? cause3 : InvalidPushError.make({ cause: cause3 })), Effect_exports2.tapCauseLogPretty)
  });
  return RpcServer_exports.layer(SyncWsRpc).pipe(Layer_exports.provide(handlersLayer));
}, "makeRpcServer");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/do/durable-object.js
var DurableObjectBase = DurableObject;
var makeDurableObject = /* @__PURE__ */ __name((options4) => {
  const enabledTransports = options4?.enabledTransports ?? /* @__PURE__ */ new Set(["http", "ws", "do-rpc"]);
  const Logging = Logger_exports2.consoleWithThread("SyncDo");
  const Observability = options4?.otel?.baseUrl ? Otlp_exports.layer({
    baseUrl: options4.otel.baseUrl,
    tracerExportInterval: 50,
    resource: {
      serviceName: options4.otel.serviceName ?? "sync-cf-do"
    }
  }).pipe(Layer_exports.provide(FetchHttpClient_exports.layer)) : Layer_exports.empty;
  return /* @__PURE__ */ __name(class SyncBackendDOBase extends DurableObjectBase {
    __DURABLE_OBJECT_BRAND = "SyncBackendDOBase";
    constructor(ctx, env) {
      super(ctx, env);
      const WebSocketRpcServerLive = makeRpcServer({ doSelf: this, doOptions: options4 });
      if (enabledTransports.has("ws")) {
        setupDurableObjectWebSocketRpc({
          doSelf: this,
          rpcLayer: WebSocketRpcServerLive,
          webSocketMode: "hibernate",
          // See `pull.ts` for more details how `pull` Effect RPC requests streams are handled
          // in combination with DO hibernation
          onMessage: (request2, ws) => {
            if (request2._tag === "Request" && request2.tag === "SyncWsRpc.Pull") {
              const attachment = ws.deserializeAttachment();
              const { pullRequestIds, ...rest } = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(attachment);
              ws.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({
                ...rest,
                pullRequestIds: [...pullRequestIds, request2.id]
              }));
            } else if (request2._tag === "Interrupt") {
              const attachment = ws.deserializeAttachment();
              const { pullRequestIds, ...rest } = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(attachment);
              ws.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({
                ...rest,
                pullRequestIds: pullRequestIds.filter((id3) => id3 !== request2.requestId)
              }));
            }
          },
          mainLayer: Observability
        });
      }
    }
    fetch = async (request2) => Effect_exports2.gen(this, function* () {
      const searchParams = matchSyncRequest(request2);
      if (searchParams === void 0) {
        throw new Error("No search params found in request URL");
      }
      const { storeId, payload, transport } = searchParams;
      if (enabledTransports.has(transport) === false) {
        throw new Error(`Transport ${transport} is not enabled (based on \`options.enabledTransports\`)`);
      }
      if (transport === "http") {
        return yield* this.handleHttp(request2);
      }
      if (transport === "ws") {
        const { 0: client, 1: server } = new WebSocketPair();
        server.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({ storeId, payload, pullRequestIds: [] }));
        this.ctx.acceptWebSocket(server);
        this.ctx.setWebSocketAutoResponse(new WebSocketRequestResponsePair(JSON.stringify(RpcMessage_exports.constPing), JSON.stringify(RpcMessage_exports.constPong)));
        return new Response(null, {
          status: 101,
          webSocket: client
        });
      }
      console.error("Invalid path", request2.url);
      return new Response("Invalid path", {
        status: 400,
        statusText: "Bad Request"
      });
    }).pipe(
      Effect_exports2.tapCauseLogPretty,
      // Also log errors to console before catching them
      Effect_exports2.catchAllCause((cause3) => Effect_exports2.succeed(new Response("Error", { status: 500, statusText: cause3.toString() }))),
      Effect_exports2.withSpan("@livestore/sync-cf:durable-object:fetch"),
      Effect_exports2.provide(DoCtx.Default({ doSelf: this, doOptions: options4, from: request2 })),
      this.runEffectAsPromise
    );
    /**
     * Handles DO <-> DO RPC calls
     */
    async rpc(payload) {
      if (enabledTransports.has("do-rpc") === false) {
        throw new Error("Do RPC transport is not enabled (based on `options.enabledTransports`)");
      }
      return createDoRpcHandler({ payload, input: { doSelf: this, doOptions: options4 } }).pipe(Effect_exports2.withSpan("@livestore/sync-cf:durable-object:rpc"), this.runEffectAsPromise);
    }
    /**
     * Handles HTTP RPC calls
     *
     * Requires the `enable_request_signal` compatibility flag to properly support `pull` streaming responses
     */
    handleHttp = (request2) => createHttpRpcHandler({
      request: request2
    }).pipe(Effect_exports2.withSpan("@livestore/sync-cf:durable-object:handleHttp"));
    runEffectAsPromise = (effect4) => effect4.pipe(Effect_exports2.tapCauseLogPretty, Logger_exports2.withMinimumLogLevel(LogLevel_exports.Debug), Effect_exports2.provide(Layer_exports.mergeAll(Observability, Logging)), Effect_exports2.scoped, Effect_exports2.runPromise);
  }, "SyncBackendDOBase");
}, "makeDurableObject");

// node_modules/.pnpm/@livestore+sync-cf@0.4.0-dev.9_8ad9fe54e443feefa26f071e362bf945/node_modules/@livestore/sync-cf/dist/cf-worker/worker.js
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var makeWorker = /* @__PURE__ */ __name((options4) => {
  return {
    fetch: async (request2, env, _ctx) => {
      const url2 = new URL(request2.url);
      const corsHeaders = options4.enableCORS ? {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": request2.headers.get("Access-Control-Request-Headers") ?? "*"
      } : {};
      if (request2.method === "OPTIONS" && options4.enableCORS) {
        return new Response(null, {
          status: 204,
          headers: corsHeaders
        });
      }
      const searchParams = matchSyncRequest(request2);
      if (searchParams !== void 0) {
        return handleSyncRequest({
          request: request2,
          searchParams,
          env,
          ctx: _ctx,
          syncBackendBinding: options4.syncBackendBinding,
          headers: corsHeaders,
          validatePayload: options4.validatePayload
        });
      }
      if (request2.method === "GET" && url2.pathname === "/") {
        return new Response("Info: Sync backend endpoint for @livestore/sync-cf.", {
          status: 200,
          headers: { "Content-Type": "text/plain" }
        });
      }
      console.error("Invalid path", url2.pathname);
      return new Response("Invalid path", {
        status: 400,
        statusText: "Bad Request",
        headers: {
          ...corsHeaders,
          "Content-Type": "text/plain"
        }
      });
    }
  };
}, "makeWorker");
var handleSyncRequest = /* @__PURE__ */ __name(({ request: request2, searchParams: { storeId, payload, transport }, env, syncBackendBinding, headers, validatePayload }) => Effect_exports2.gen(function* () {
  if (validatePayload !== void 0) {
    const result = yield* Effect_exports2.promise(async () => validatePayload(payload, { storeId })).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.either);
    if (result._tag === "Left") {
      console.error("Invalid payload", result.left);
      return new Response(result.left.toString(), { status: 400, headers });
    }
  }
  if (!(syncBackendBinding in env)) {
    return new Response(`Failed dependency: Required Durable Object binding '${syncBackendBinding}' not available`, {
      status: 424,
      headers
    });
  }
  const durableObjectNamespace = env[syncBackendBinding];
  const id3 = durableObjectNamespace.idFromName(storeId);
  const durableObject = durableObjectNamespace.get(id3);
  const upgradeHeader = request2.headers.get("Upgrade");
  if (transport === "ws" && (upgradeHeader === null || upgradeHeader !== "websocket")) {
    return new Response("Durable Object expected Upgrade: websocket", {
      status: 426,
      headers
    });
  }
  return yield* Effect_exports2.promise(() => durableObject.fetch(request2));
}).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.runPromise), "handleSyncRequest");

// src/index.ts
var SyncDurableObject = class extends makeDurableObject({
  // Basic configuration - no auth for spike
  allowAnonymous: true
}) {
};
__name(SyncDurableObject, "SyncDurableObject");
var src_default = makeWorker({
  // Basic configuration for spike
  allowAnonymous: true,
  // CORS settings for local development
  cors: {
    origin: "*",
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    headers: ["Content-Type", "Authorization"]
  }
});

// node_modules/.pnpm/wrangler@3.114.15_@cloudflare+workers-types@4.20251004.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var drainBody = /* @__PURE__ */ __name(async (request2, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env);
  } finally {
    try {
      if (request2.body !== null && !request2.bodyUsed) {
        const reader = request2.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/.pnpm/wrangler@3.114.15_@cloudflare+workers-types@4.20251004.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request2, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-gWfDcw/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/.pnpm/wrangler@3.114.15_@cloudflare+workers-types@4.20251004.0/node_modules/wrangler/templates/middleware/common.ts
init_strip_cf_connecting_ip_header();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args2) {
  __facade_middleware__.push(...args2.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request2, env, ctx, dispatch, middlewareChain) {
  const [head10, ...tail2] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail2);
    }
  };
  return head10(request2, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request2, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request2, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-gWfDcw/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron2, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron2;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
__name(__Facade_ScheduledController__, "__Facade_ScheduledController__");
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request2, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request2, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request2, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type3, init) {
        if (type3 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request2, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  return class extends klass {
    #fetchDispatcher = (request2, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request2);
    };
    #dispatcher = (type3, init) => {
      if (type3 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request2) {
      return __facade_invoke__(
        request2,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  SyncDurableObject,
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
//# sourceMappingURL=index.js.map
